{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n  return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n  var _a;\n\n  var path = originalPath.slice();\n  var errors = [];\n  var root = parseTree(text, errors);\n  var parent = void 0;\n  var lastSegment = void 0;\n\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = (_a = {}, _a[lastSegment] = value, _a);\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, formattingOptions);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    var existing = findNodeAtLocation(parent, [lastSegment]);\n\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n\n        var propertyIndex = parent.children.indexOf(existing.parent);\n        var removeBegin = void 0;\n        var removeEnd = existing.parent.offset + existing.parent.length;\n\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          var previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            var next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, formattingOptions);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, formattingOptions);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n      var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) {\n        return p.children[0].value;\n      })) : parent.children.length;\n      var edit = void 0;\n\n      if (index > 0) {\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    var insertIndex = lastSegment;\n\n    if (insertIndex === -1) {\n      // Insert\n      var newProperty = \"\" + JSON.stringify(value);\n      var edit = void 0;\n\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        var previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    } else {\n      if (value === void 0 && parent.children.length >= 0) {\n        //Removal\n        var removalIndex = lastSegment;\n        var toRemove = parent.children[removalIndex];\n        var edit = void 0;\n\n        if (parent.children.length === 1) {\n          // only item\n          edit = {\n            offset: parent.offset + 1,\n            length: parent.length - 2,\n            content: ''\n          };\n        } else if (parent.children.length - 1 === removalIndex) {\n          // last item\n          var previous = parent.children[removalIndex - 1];\n          var offset = previous.offset + previous.length;\n          var parentEndOffset = parent.offset + parent.length;\n          edit = {\n            offset: offset,\n            length: parentEndOffset - 2 - offset,\n            content: ''\n          };\n        } else {\n          edit = {\n            offset: toRemove.offset,\n            length: parent.children[removalIndex + 1].offset - toRemove.offset,\n            content: ''\n          };\n        }\n\n        return withFormatting(text, edit, formattingOptions);\n      } else {\n        throw new Error('Array modification not supported yet');\n      }\n    }\n  } else {\n    throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n  }\n}\n\nfunction withFormatting(text, edit, formattingOptions) {\n  // apply the edit\n  var newText = applyEdit(text, edit); // format the new text\n\n  var begin = edit.offset;\n  var end = edit.offset + edit.content.length;\n\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n\n  var edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, formattingOptions); // apply the formatting edits and track the begin and end offsets of the changes\n\n  for (var i = edits.length - 1; i >= 0; i--) {\n    var edit_1 = edits[i];\n    newText = applyEdit(newText, edit_1);\n    begin = Math.min(begin, edit_1.offset);\n    end = Math.max(end, edit_1.offset + edit_1.length);\n    end += edit_1.content.length - edit_1.length;\n  } // create a single edit with all changes\n\n\n  var editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\n\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/edit.js"],"names":["format","isEOL","parseTree","findNodeAtLocation","removeProperty","text","path","formattingOptions","setProperty","originalPath","value","getInsertionIndex","_a","slice","errors","root","parent","lastSegment","length","pop","Error","withFormatting","offset","content","JSON","stringify","type","Array","isArray","children","existing","propertyIndex","indexOf","removeBegin","removeEnd","previous","next","newProperty","index","map","p","edit","insertIndex","removalIndex","toRemove","parentEndOffset","newText","applyEdit","begin","end","edits","i","edit_1","Math","min","max","editLength","substring","isWS","charAt"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n    return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n        else {\n            if (value === void 0 && parent.children.length >= 0) {\n                //Removal\n                var removalIndex = lastSegment;\n                var toRemove = parent.children[removalIndex];\n                var edit = void 0;\n                if (parent.children.length === 1) {\n                    // only item\n                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                }\n                else if (parent.children.length - 1 === removalIndex) {\n                    // last item\n                    var previous = parent.children[removalIndex - 1];\n                    var offset = previous.offset + previous.length;\n                    var parentEndOffset = parent.offset + parent.length;\n                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                }\n                else {\n                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                throw new Error('Array modification not supported yet');\n            }\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, formattingOptions) {\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"]},"metadata":{},"sourceType":"module"}