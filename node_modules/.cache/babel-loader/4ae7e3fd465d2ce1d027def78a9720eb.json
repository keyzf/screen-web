{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\n\nvar FoldingModel =\n/** @class */\nfunction () {\n  function FoldingModel(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n    this._isInitialized = false;\n  }\n\n  Object.defineProperty(FoldingModel.prototype, \"regions\", {\n    get: function () {\n      return this._regions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"textModel\", {\n    get: function () {\n      return this._textModel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\n    get: function () {\n      return this._isInitialized;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FoldingModel.prototype.toggleCollapseState = function (regions) {\n    var _this = this;\n\n    if (!regions.length) {\n      return;\n    }\n\n    var processed = {};\n\n    this._decorationProvider.changeDecorations(function (accessor) {\n      for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n        var region = regions_1[_i];\n        var index = region.regionIndex;\n        var editorDecorationId = _this._editorDecorationIds[index];\n\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          var newCollapseState = !_this._regions.isCollapsed(index);\n\n          _this._regions.setCollapsed(index, newCollapseState);\n\n          accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\n        }\n      }\n    });\n\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: regions\n    });\n  };\n\n  FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\n    var _this = this;\n\n    if (blockedLineNumers === void 0) {\n      blockedLineNumers = [];\n    }\n\n    var newEditorDecorations = [];\n\n    var isBlocked = function (startLineNumber, endLineNumber) {\n      for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\n        var blockedLineNumber = blockedLineNumers_1[_i];\n\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    var initRange = function (index, isCollapsed) {\n      var startLineNumber = newRegions.getStartLineNumber(index);\n\n      if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n        isCollapsed = false;\n      }\n\n      newRegions.setCollapsed(index, isCollapsed);\n\n      var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\n\n      var decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: maxColumn,\n        endLineNumber: startLineNumber,\n        endColumn: maxColumn\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: _this._decorationProvider.getDecorationOption(isCollapsed)\n      });\n    };\n\n    var i = 0;\n\n    var nextCollapsed = function () {\n      while (i < _this._regions.length) {\n        var isCollapsed = _this._regions.isCollapsed(i);\n\n        i++;\n\n        if (isCollapsed) {\n          return i - 1;\n        }\n      }\n\n      return -1;\n    };\n\n    var k = 0;\n    var collapsedIndex = nextCollapsed();\n\n    while (collapsedIndex !== -1 && k < newRegions.length) {\n      // get the latest range\n      var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n\n      if (decRange) {\n        var collapsedStartLineNumber = decRange.startLineNumber;\n\n        if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) {\n          // test that the decoration is still at the end otherwise it got deleted\n          while (k < newRegions.length) {\n            var startLineNumber = newRegions.getStartLineNumber(k);\n\n            if (collapsedStartLineNumber >= startLineNumber) {\n              initRange(k, collapsedStartLineNumber === startLineNumber);\n              k++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      collapsedIndex = nextCollapsed();\n    }\n\n    while (k < newRegions.length) {\n      initRange(k, false);\n      k++;\n    }\n\n    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n    this._regions = newRegions;\n    this._isInitialized = true;\n\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  };\n  /**\r\n   * Collapse state memento, for persistence only\r\n   */\n\n\n  FoldingModel.prototype.getMemento = function () {\n    var collapsedRanges = [];\n\n    for (var i = 0; i < this._regions.length; i++) {\n      if (this._regions.isCollapsed(i)) {\n        var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\n        if (range) {\n          var startLineNumber = range.startLineNumber;\n\n          var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n\n          collapsedRanges.push({\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber\n          });\n        }\n      }\n    }\n\n    if (collapsedRanges.length > 0) {\n      return collapsedRanges;\n    }\n\n    return undefined;\n  };\n  /**\r\n   * Apply persisted state, for persistence only\r\n   */\n\n\n  FoldingModel.prototype.applyMemento = function (state) {\n    if (!Array.isArray(state)) {\n      return;\n    }\n\n    var toToogle = [];\n\n    for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n      var range = state_1[_i];\n      var region = this.getRegionAtLine(range.startLineNumber);\n\n      if (region && !region.isCollapsed) {\n        toToogle.push(region);\n      }\n    }\n\n    this.toggleCollapseState(toToogle);\n  };\n\n  FoldingModel.prototype.dispose = function () {\n    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n  };\n\n  FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\n    var result = [];\n\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n\n      var level = 1;\n\n      while (index >= 0) {\n        var current = this._regions.toRegion(index);\n\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n\n        level++;\n        index = current.parentIndex;\n      }\n    }\n\n    return result;\n  };\n\n  FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n\n    return null;\n  };\n\n  FoldingModel.prototype.getRegionsInside = function (region, filter) {\n    var result = [];\n    var index = region ? region.regionIndex + 1 : 0;\n    var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n    if (filter && filter.length === 2) {\n      var levelStack = [];\n\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n\n          levelStack.push(current);\n\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  return FoldingModel;\n}();\n\nexport { FoldingModel };\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\n\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  var toToggle = [];\n\n  var _loop_1 = function (lineNumber) {\n    var region = foldingModel.getRegionAtLine(lineNumber);\n\n    if (region) {\n      var doCollapse_1 = !region.isCollapsed;\n      toToggle.push(region);\n\n      if (levels > 1) {\n        var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n          return r.isCollapsed !== doCollapse_1 && level < levels;\n        });\n        toToggle.push.apply(toToggle, regionsInside);\n      }\n    }\n  };\n\n  for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\n    var lineNumber = lineNumbers_1[_i];\n\n    _loop_1(lineNumber);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\n\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\n  if (levels === void 0) {\n    levels = Number.MAX_VALUE;\n  }\n\n  var toToggle = [];\n\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\n      var lineNumber = lineNumbers_2[_i];\n      var region = foldingModel.getRegionAtLine(lineNumber);\n\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n\n        if (levels > 1) {\n          var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n            return r.isCollapsed !== doCollapse && level < levels;\n          });\n          toToggle.push.apply(toToggle, regionsInside);\n        }\n      }\n    }\n  } else {\n    var regionsInside = foldingModel.getRegionsInside(null, function (r, level) {\n      return r.isCollapsed !== doCollapse && level < levels;\n    });\n    toToggle.push.apply(toToggle, regionsInside);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\n\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  var toToggle = [];\n\n  for (var _i = 0, lineNumbers_3 = lineNumbers; _i < lineNumbers_3.length; _i++) {\n    var lineNumber = lineNumbers_3[_i];\n    var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) {\n      return region.isCollapsed !== doCollapse && level <= levels;\n    });\n    toToggle.push.apply(toToggle, regions);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\n\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  var toToggle = [];\n\n  for (var _i = 0, lineNumbers_4 = lineNumbers; _i < lineNumbers_4.length; _i++) {\n    var lineNumber = lineNumbers_4[_i];\n    var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region) {\n      return region.isCollapsed !== doCollapse;\n    });\n\n    if (regions.length > 0) {\n      toToggle.push(regions[0]);\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\n\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  var filter = function (region, level) {\n    return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) {\n      return region.containsLine(line);\n    });\n  };\n\n  var toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\n\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  var editorModel = foldingModel.textModel;\n  var regions = foldingModel.regions;\n  var toToggle = [];\n\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      var startLineNumber = regions.getStartLineNumber(i);\n\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\n\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  var regions = foldingModel.regions;\n  var toToggle = [];\n\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js"],"names":["Emitter","FoldingRegions","FoldingModel","textModel","decorationProvider","_updateEventEmitter","onDidChange","event","_textModel","_decorationProvider","_regions","Uint32Array","_editorDecorationIds","_isInitialized","Object","defineProperty","prototype","get","enumerable","configurable","toggleCollapseState","regions","_this","length","processed","changeDecorations","accessor","_i","regions_1","region","index","regionIndex","editorDecorationId","newCollapseState","isCollapsed","setCollapsed","changeDecorationOptions","getDecorationOption","fire","model","collapseStateChanged","update","newRegions","blockedLineNumers","newEditorDecorations","isBlocked","startLineNumber","endLineNumber","blockedLineNumers_1","blockedLineNumber","initRange","getStartLineNumber","getEndLineNumber","maxColumn","getLineMaxColumn","decorationRange","startColumn","endColumn","push","range","options","i","nextCollapsed","k","collapsedIndex","decRange","getDecorationRange","collapsedStartLineNumber","deltaDecorations","getMemento","collapsedRanges","undefined","applyMemento","state","Array","isArray","toToogle","state_1","getRegionAtLine","dispose","getAllRegionsAtLine","lineNumber","filter","result","findRange","level","current","toRegion","parentIndex","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","_loop_1","doCollapse_1","regionsInside","r","apply","lineNumbers_1","setCollapseStateLevelsDown","doCollapse","lineNumbers_2","setCollapseStateLevelsUp","lineNumbers_3","setCollapseStateUp","lineNumbers_4","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForMatchingLines","regExp","editorModel","test","getLineContent","setCollapseStateForType","type","getType"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { FoldingRegions } from './foldingRanges.js';\r\nvar FoldingModel = /** @class */ (function () {\r\n    function FoldingModel(textModel, decorationProvider) {\r\n        this._updateEventEmitter = new Emitter();\r\n        this.onDidChange = this._updateEventEmitter.event;\r\n        this._textModel = textModel;\r\n        this._decorationProvider = decorationProvider;\r\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\r\n        this._editorDecorationIds = [];\r\n        this._isInitialized = false;\r\n    }\r\n    Object.defineProperty(FoldingModel.prototype, \"regions\", {\r\n        get: function () { return this._regions; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FoldingModel.prototype, \"textModel\", {\r\n        get: function () { return this._textModel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\r\n        get: function () { return this._isInitialized; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FoldingModel.prototype.toggleCollapseState = function (regions) {\r\n        var _this = this;\r\n        if (!regions.length) {\r\n            return;\r\n        }\r\n        var processed = {};\r\n        this._decorationProvider.changeDecorations(function (accessor) {\r\n            for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\r\n                var region = regions_1[_i];\r\n                var index = region.regionIndex;\r\n                var editorDecorationId = _this._editorDecorationIds[index];\r\n                if (editorDecorationId && !processed[editorDecorationId]) {\r\n                    processed[editorDecorationId] = true;\r\n                    var newCollapseState = !_this._regions.isCollapsed(index);\r\n                    _this._regions.setCollapsed(index, newCollapseState);\r\n                    accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\r\n                }\r\n            }\r\n        });\r\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });\r\n    };\r\n    FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\r\n        var _this = this;\r\n        if (blockedLineNumers === void 0) { blockedLineNumers = []; }\r\n        var newEditorDecorations = [];\r\n        var isBlocked = function (startLineNumber, endLineNumber) {\r\n            for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\r\n                var blockedLineNumber = blockedLineNumers_1[_i];\r\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        var initRange = function (index, isCollapsed) {\r\n            var startLineNumber = newRegions.getStartLineNumber(index);\r\n            if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\r\n                isCollapsed = false;\r\n            }\r\n            newRegions.setCollapsed(index, isCollapsed);\r\n            var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\r\n            var decorationRange = {\r\n                startLineNumber: startLineNumber,\r\n                startColumn: maxColumn,\r\n                endLineNumber: startLineNumber,\r\n                endColumn: maxColumn\r\n            };\r\n            newEditorDecorations.push({ range: decorationRange, options: _this._decorationProvider.getDecorationOption(isCollapsed) });\r\n        };\r\n        var i = 0;\r\n        var nextCollapsed = function () {\r\n            while (i < _this._regions.length) {\r\n                var isCollapsed = _this._regions.isCollapsed(i);\r\n                i++;\r\n                if (isCollapsed) {\r\n                    return i - 1;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        var k = 0;\r\n        var collapsedIndex = nextCollapsed();\r\n        while (collapsedIndex !== -1 && k < newRegions.length) {\r\n            // get the latest range\r\n            var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\r\n            if (decRange) {\r\n                var collapsedStartLineNumber = decRange.startLineNumber;\r\n                if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted\r\n                    while (k < newRegions.length) {\r\n                        var startLineNumber = newRegions.getStartLineNumber(k);\r\n                        if (collapsedStartLineNumber >= startLineNumber) {\r\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\r\n                            k++;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            collapsedIndex = nextCollapsed();\r\n        }\r\n        while (k < newRegions.length) {\r\n            initRange(k, false);\r\n            k++;\r\n        }\r\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\r\n        this._regions = newRegions;\r\n        this._isInitialized = true;\r\n        this._updateEventEmitter.fire({ model: this });\r\n    };\r\n    /**\r\n     * Collapse state memento, for persistence only\r\n     */\r\n    FoldingModel.prototype.getMemento = function () {\r\n        var collapsedRanges = [];\r\n        for (var i = 0; i < this._regions.length; i++) {\r\n            if (this._regions.isCollapsed(i)) {\r\n                var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\r\n                if (range) {\r\n                    var startLineNumber = range.startLineNumber;\r\n                    var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\r\n                    collapsedRanges.push({ startLineNumber: startLineNumber, endLineNumber: endLineNumber });\r\n                }\r\n            }\r\n        }\r\n        if (collapsedRanges.length > 0) {\r\n            return collapsedRanges;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Apply persisted state, for persistence only\r\n     */\r\n    FoldingModel.prototype.applyMemento = function (state) {\r\n        if (!Array.isArray(state)) {\r\n            return;\r\n        }\r\n        var toToogle = [];\r\n        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\r\n            var range = state_1[_i];\r\n            var region = this.getRegionAtLine(range.startLineNumber);\r\n            if (region && !region.isCollapsed) {\r\n                toToogle.push(region);\r\n            }\r\n        }\r\n        this.toggleCollapseState(toToogle);\r\n    };\r\n    FoldingModel.prototype.dispose = function () {\r\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\r\n    };\r\n    FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\r\n        var result = [];\r\n        if (this._regions) {\r\n            var index = this._regions.findRange(lineNumber);\r\n            var level = 1;\r\n            while (index >= 0) {\r\n                var current = this._regions.toRegion(index);\r\n                if (!filter || filter(current, level)) {\r\n                    result.push(current);\r\n                }\r\n                level++;\r\n                index = current.parentIndex;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\r\n        if (this._regions) {\r\n            var index = this._regions.findRange(lineNumber);\r\n            if (index >= 0) {\r\n                return this._regions.toRegion(index);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    FoldingModel.prototype.getRegionsInside = function (region, filter) {\r\n        var result = [];\r\n        var index = region ? region.regionIndex + 1 : 0;\r\n        var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\r\n        if (filter && filter.length === 2) {\r\n            var levelStack = [];\r\n            for (var i = index, len = this._regions.length; i < len; i++) {\r\n                var current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\r\n                        levelStack.pop();\r\n                    }\r\n                    levelStack.push(current);\r\n                    if (filter(current, levelStack.length)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = index, len = this._regions.length; i < len; i++) {\r\n                var current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    if (!filter || filter(current)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return FoldingModel;\r\n}());\r\nexport { FoldingModel };\r\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\r\n    var toToggle = [];\r\n    var _loop_1 = function (lineNumber) {\r\n        var region = foldingModel.getRegionAtLine(lineNumber);\r\n        if (region) {\r\n            var doCollapse_1 = !region.isCollapsed;\r\n            toToggle.push(region);\r\n            if (levels > 1) {\r\n                var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse_1 && level < levels; });\r\n                toToggle.push.apply(toToggle, regionsInside);\r\n            }\r\n        }\r\n    };\r\n    for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\r\n        var lineNumber = lineNumbers_1[_i];\r\n        _loop_1(lineNumber);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\r\n    if (levels === void 0) { levels = Number.MAX_VALUE; }\r\n    var toToggle = [];\r\n    if (lineNumbers && lineNumbers.length > 0) {\r\n        for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\r\n            var lineNumber = lineNumbers_2[_i];\r\n            var region = foldingModel.getRegionAtLine(lineNumber);\r\n            if (region) {\r\n                if (region.isCollapsed !== doCollapse) {\r\n                    toToggle.push(region);\r\n                }\r\n                if (levels > 1) {\r\n                    var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\r\n                    toToggle.push.apply(toToggle, regionsInside);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        var regionsInside = foldingModel.getRegionsInside(null, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\r\n        toToggle.push.apply(toToggle, regionsInside);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\r\n    var toToggle = [];\r\n    for (var _i = 0, lineNumbers_3 = lineNumbers; _i < lineNumbers_3.length; _i++) {\r\n        var lineNumber = lineNumbers_3[_i];\r\n        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) { return region.isCollapsed !== doCollapse && level <= levels; });\r\n        toToggle.push.apply(toToggle, regions);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\r\n    var toToggle = [];\r\n    for (var _i = 0, lineNumbers_4 = lineNumbers; _i < lineNumbers_4.length; _i++) {\r\n        var lineNumber = lineNumbers_4[_i];\r\n        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region) { return region.isCollapsed !== doCollapse; });\r\n        if (regions.length > 0) {\r\n            toToggle.push(regions[0]);\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\r\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\r\n    var filter = function (region, level) { return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) { return region.containsLine(line); }); };\r\n    var toToggle = foldingModel.getRegionsInside(null, filter);\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\r\n    var editorModel = foldingModel.textModel;\r\n    var regions = foldingModel.regions;\r\n    var toToggle = [];\r\n    for (var i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i)) {\r\n            var startLineNumber = regions.getStartLineNumber(i);\r\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\r\n                toToggle.push(regions.toRegion(i));\r\n            }\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\r\n    var regions = foldingModel.regions;\r\n    var toToggle = [];\r\n    for (var i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\r\n            toToggle.push(regions.toRegion(i));\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}