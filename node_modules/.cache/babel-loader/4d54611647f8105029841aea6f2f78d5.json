{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nvar ErrorHandler =\n/** @class */\nfunction () {\n  function ErrorHandler() {\n    this.listeners = [];\n\n    this.unexpectedErrorHandler = function (e) {\n      setTimeout(function () {\n        if (e.stack) {\n          throw new Error(e.message + '\\n\\n' + e.stack);\n        }\n\n        throw e;\n      }, 0);\n    };\n  }\n\n  ErrorHandler.prototype.emit = function (e) {\n    this.listeners.forEach(function (listener) {\n      listener(e);\n    });\n  };\n\n  ErrorHandler.prototype.onUnexpectedError = function (e) {\n    this.unexpectedErrorHandler(e);\n    this.emit(e);\n  }; // For external errors, we don't want the listeners to be called\n\n\n  ErrorHandler.prototype.onUnexpectedExternalError = function (e) {\n    this.unexpectedErrorHandler(e);\n  };\n\n  return ErrorHandler;\n}();\n\nexport { ErrorHandler };\nexport var errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n\n  return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedExternalError(e);\n  }\n\n  return undefined;\n}\nexport function transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    var name_1 = error.name,\n        message = error.message;\n    var stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name: name_1,\n      message: message,\n      stack: stack\n    };\n  } // return as is\n\n\n  return error;\n}\nvar canceledName = 'Canceled';\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\n\nexport function isPromiseCanceledError(error) {\n  return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\r\n * Returns an error that signals cancellation.\r\n */\n\nexport function canceled() {\n  var error = new Error(canceledName);\n  error.name = error.message;\n  return error;\n}\nexport function illegalArgument(name) {\n  if (name) {\n    return new Error(\"Illegal argument: \" + name);\n  } else {\n    return new Error('Illegal argument');\n  }\n}\nexport function illegalState(name) {\n  if (name) {\n    return new Error(\"Illegal state: \" + name);\n  } else {\n    return new Error('Illegal state');\n  }\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/errors.js"],"names":["ErrorHandler","listeners","unexpectedErrorHandler","e","setTimeout","stack","Error","message","prototype","emit","forEach","listener","onUnexpectedError","onUnexpectedExternalError","errorHandler","isPromiseCanceledError","undefined","transformErrorForSerialization","error","name_1","name","stacktrace","$isError","canceledName","canceled","illegalArgument","illegalState"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\r\nvar ErrorHandler = /** @class */ (function () {\r\n    function ErrorHandler() {\r\n        this.listeners = [];\r\n        this.unexpectedErrorHandler = function (e) {\r\n            setTimeout(function () {\r\n                if (e.stack) {\r\n                    throw new Error(e.message + '\\n\\n' + e.stack);\r\n                }\r\n                throw e;\r\n            }, 0);\r\n        };\r\n    }\r\n    ErrorHandler.prototype.emit = function (e) {\r\n        this.listeners.forEach(function (listener) {\r\n            listener(e);\r\n        });\r\n    };\r\n    ErrorHandler.prototype.onUnexpectedError = function (e) {\r\n        this.unexpectedErrorHandler(e);\r\n        this.emit(e);\r\n    };\r\n    // For external errors, we don't want the listeners to be called\r\n    ErrorHandler.prototype.onUnexpectedExternalError = function (e) {\r\n        this.unexpectedErrorHandler(e);\r\n    };\r\n    return ErrorHandler;\r\n}());\r\nexport { ErrorHandler };\r\nexport var errorHandler = new ErrorHandler();\r\nexport function onUnexpectedError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedError(e);\r\n    }\r\n    return undefined;\r\n}\r\nexport function onUnexpectedExternalError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedExternalError(e);\r\n    }\r\n    return undefined;\r\n}\r\nexport function transformErrorForSerialization(error) {\r\n    if (error instanceof Error) {\r\n        var name_1 = error.name, message = error.message;\r\n        var stack = error.stacktrace || error.stack;\r\n        return {\r\n            $isError: true,\r\n            name: name_1,\r\n            message: message,\r\n            stack: stack\r\n        };\r\n    }\r\n    // return as is\r\n    return error;\r\n}\r\nvar canceledName = 'Canceled';\r\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\r\nexport function isPromiseCanceledError(error) {\r\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\r\n}\r\n/**\r\n * Returns an error that signals cancellation.\r\n */\r\nexport function canceled() {\r\n    var error = new Error(canceledName);\r\n    error.name = error.message;\r\n    return error;\r\n}\r\nexport function illegalArgument(name) {\r\n    if (name) {\r\n        return new Error(\"Illegal argument: \" + name);\r\n    }\r\n    else {\r\n        return new Error('Illegal argument');\r\n    }\r\n}\r\nexport function illegalState(name) {\r\n    if (name) {\r\n        return new Error(\"Illegal state: \" + name);\r\n    }\r\n    else {\r\n        return new Error('Illegal state');\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}