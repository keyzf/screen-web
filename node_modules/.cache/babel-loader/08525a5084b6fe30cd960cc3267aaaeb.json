{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\n\nvar PieceTreeTextBufferFactory =\n/** @class */\nfunction () {\n  function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {\n    this._chunks = _chunks;\n    this._bom = _bom;\n    this._cr = _cr;\n    this._lf = _lf;\n    this._crlf = _crlf;\n    this._containsRTL = _containsRTL;\n    this._isBasicASCII = _isBasicASCII;\n    this._normalizeEOL = _normalizeEOL;\n  }\n\n  PieceTreeTextBufferFactory.prototype._getEOL = function (defaultEOL) {\n    var totalEOLCount = this._cr + this._lf + this._crlf;\n    var totalCRCount = this._cr + this._crlf;\n\n    if (totalEOLCount === 0) {\n      // This is an empty file or a file with precisely one line\n      return defaultEOL === 1\n      /* LF */\n      ? '\\n' : '\\r\\n';\n    }\n\n    if (totalCRCount > totalEOLCount / 2) {\n      // More than half of the file contains \\r\\n ending lines\n      return '\\r\\n';\n    } // At least one line more ends in \\n\n\n\n    return '\\n';\n  };\n\n  PieceTreeTextBufferFactory.prototype.create = function (defaultEOL) {\n    var eol = this._getEOL(defaultEOL);\n\n    var chunks = this._chunks;\n\n    if (this._normalizeEOL && (eol === '\\r\\n' && (this._cr > 0 || this._lf > 0) || eol === '\\n' && (this._cr > 0 || this._crlf > 0))) {\n      // Normalize pieces\n      for (var i = 0, len = chunks.length; i < len; i++) {\n        var str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n        var newLineStart = createLineStartsFast(str);\n        chunks[i] = new StringBuffer(str, newLineStart);\n      }\n    }\n\n    return new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);\n  };\n\n  return PieceTreeTextBufferFactory;\n}();\n\nexport { PieceTreeTextBufferFactory };\n\nvar PieceTreeTextBufferBuilder =\n/** @class */\nfunction () {\n  function PieceTreeTextBufferBuilder() {\n    this.chunks = [];\n    this.BOM = '';\n    this._hasPreviousChar = false;\n    this._previousChar = 0;\n    this._tmpLineStarts = [];\n    this.cr = 0;\n    this.lf = 0;\n    this.crlf = 0;\n    this.containsRTL = false;\n    this.isBasicASCII = true;\n  }\n\n  PieceTreeTextBufferBuilder.prototype.acceptChunk = function (chunk) {\n    if (chunk.length === 0) {\n      return;\n    }\n\n    if (this.chunks.length === 0) {\n      if (strings.startsWithUTF8BOM(chunk)) {\n        this.BOM = strings.UTF8_BOM_CHARACTER;\n        chunk = chunk.substr(1);\n      }\n    }\n\n    var lastChar = chunk.charCodeAt(chunk.length - 1);\n\n    if (lastChar === 13\n    /* CarriageReturn */\n    || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n      // last character is \\r or a high surrogate => keep it back\n      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\n      this._hasPreviousChar = true;\n      this._previousChar = lastChar;\n    } else {\n      this._acceptChunk1(chunk, false);\n\n      this._hasPreviousChar = false;\n      this._previousChar = lastChar;\n    }\n  };\n\n  PieceTreeTextBufferBuilder.prototype._acceptChunk1 = function (chunk, allowEmptyStrings) {\n    if (!allowEmptyStrings && chunk.length === 0) {\n      // Nothing to do\n      return;\n    }\n\n    if (this._hasPreviousChar) {\n      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n    } else {\n      this._acceptChunk2(chunk);\n    }\n  };\n\n  PieceTreeTextBufferBuilder.prototype._acceptChunk2 = function (chunk) {\n    var lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n    this.cr += lineStarts.cr;\n    this.lf += lineStarts.lf;\n    this.crlf += lineStarts.crlf;\n\n    if (this.isBasicASCII) {\n      this.isBasicASCII = lineStarts.isBasicASCII;\n    }\n\n    if (!this.isBasicASCII && !this.containsRTL) {\n      // No need to check if is basic ASCII\n      this.containsRTL = strings.containsRTL(chunk);\n    }\n  };\n\n  PieceTreeTextBufferBuilder.prototype.finish = function (normalizeEOL) {\n    if (normalizeEOL === void 0) {\n      normalizeEOL = true;\n    }\n\n    this._finish();\n\n    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);\n  };\n\n  PieceTreeTextBufferBuilder.prototype._finish = function () {\n    if (this.chunks.length === 0) {\n      this._acceptChunk1('', true);\n    }\n\n    if (this._hasPreviousChar) {\n      this._hasPreviousChar = false; // recreate last chunk\n\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      lastChunk.buffer += String.fromCharCode(this._previousChar);\n      var newLineStarts = createLineStartsFast(lastChunk.buffer);\n      lastChunk.lineStarts = newLineStarts;\n\n      if (this._previousChar === 13\n      /* CarriageReturn */\n      ) {\n          this.cr++;\n        }\n    }\n  };\n\n  return PieceTreeTextBufferBuilder;\n}();\n\nexport { PieceTreeTextBufferBuilder };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"names":["strings","StringBuffer","createLineStarts","createLineStartsFast","PieceTreeTextBuffer","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_isBasicASCII","_normalizeEOL","prototype","_getEOL","defaultEOL","totalEOLCount","totalCRCount","create","eol","chunks","i","len","length","str","buffer","replace","newLineStart","PieceTreeTextBufferBuilder","BOM","_hasPreviousChar","_previousChar","_tmpLineStarts","cr","lf","crlf","containsRTL","isBasicASCII","acceptChunk","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","substr","lastChar","charCodeAt","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","lineStarts","push","finish","normalizeEOL","_finish","lastChunk","newLineStarts"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\r\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\r\nvar PieceTreeTextBufferFactory = /** @class */ (function () {\r\n    function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _isBasicASCII, _normalizeEOL) {\r\n        this._chunks = _chunks;\r\n        this._bom = _bom;\r\n        this._cr = _cr;\r\n        this._lf = _lf;\r\n        this._crlf = _crlf;\r\n        this._containsRTL = _containsRTL;\r\n        this._isBasicASCII = _isBasicASCII;\r\n        this._normalizeEOL = _normalizeEOL;\r\n    }\r\n    PieceTreeTextBufferFactory.prototype._getEOL = function (defaultEOL) {\r\n        var totalEOLCount = this._cr + this._lf + this._crlf;\r\n        var totalCRCount = this._cr + this._crlf;\r\n        if (totalEOLCount === 0) {\r\n            // This is an empty file or a file with precisely one line\r\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\r\n        }\r\n        if (totalCRCount > totalEOLCount / 2) {\r\n            // More than half of the file contains \\r\\n ending lines\r\n            return '\\r\\n';\r\n        }\r\n        // At least one line more ends in \\n\r\n        return '\\n';\r\n    };\r\n    PieceTreeTextBufferFactory.prototype.create = function (defaultEOL) {\r\n        var eol = this._getEOL(defaultEOL);\r\n        var chunks = this._chunks;\r\n        if (this._normalizeEOL &&\r\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\r\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\r\n            // Normalize pieces\r\n            for (var i = 0, len = chunks.length; i < len; i++) {\r\n                var str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\r\n                var newLineStart = createLineStartsFast(str);\r\n                chunks[i] = new StringBuffer(str, newLineStart);\r\n            }\r\n        }\r\n        return new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._isBasicASCII, this._normalizeEOL);\r\n    };\r\n    return PieceTreeTextBufferFactory;\r\n}());\r\nexport { PieceTreeTextBufferFactory };\r\nvar PieceTreeTextBufferBuilder = /** @class */ (function () {\r\n    function PieceTreeTextBufferBuilder() {\r\n        this.chunks = [];\r\n        this.BOM = '';\r\n        this._hasPreviousChar = false;\r\n        this._previousChar = 0;\r\n        this._tmpLineStarts = [];\r\n        this.cr = 0;\r\n        this.lf = 0;\r\n        this.crlf = 0;\r\n        this.containsRTL = false;\r\n        this.isBasicASCII = true;\r\n    }\r\n    PieceTreeTextBufferBuilder.prototype.acceptChunk = function (chunk) {\r\n        if (chunk.length === 0) {\r\n            return;\r\n        }\r\n        if (this.chunks.length === 0) {\r\n            if (strings.startsWithUTF8BOM(chunk)) {\r\n                this.BOM = strings.UTF8_BOM_CHARACTER;\r\n                chunk = chunk.substr(1);\r\n            }\r\n        }\r\n        var lastChar = chunk.charCodeAt(chunk.length - 1);\r\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n            // last character is \\r or a high surrogate => keep it back\r\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\r\n            this._hasPreviousChar = true;\r\n            this._previousChar = lastChar;\r\n        }\r\n        else {\r\n            this._acceptChunk1(chunk, false);\r\n            this._hasPreviousChar = false;\r\n            this._previousChar = lastChar;\r\n        }\r\n    };\r\n    PieceTreeTextBufferBuilder.prototype._acceptChunk1 = function (chunk, allowEmptyStrings) {\r\n        if (!allowEmptyStrings && chunk.length === 0) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\r\n        }\r\n        else {\r\n            this._acceptChunk2(chunk);\r\n        }\r\n    };\r\n    PieceTreeTextBufferBuilder.prototype._acceptChunk2 = function (chunk) {\r\n        var lineStarts = createLineStarts(this._tmpLineStarts, chunk);\r\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\r\n        this.cr += lineStarts.cr;\r\n        this.lf += lineStarts.lf;\r\n        this.crlf += lineStarts.crlf;\r\n        if (this.isBasicASCII) {\r\n            this.isBasicASCII = lineStarts.isBasicASCII;\r\n        }\r\n        if (!this.isBasicASCII && !this.containsRTL) {\r\n            // No need to check if is basic ASCII\r\n            this.containsRTL = strings.containsRTL(chunk);\r\n        }\r\n    };\r\n    PieceTreeTextBufferBuilder.prototype.finish = function (normalizeEOL) {\r\n        if (normalizeEOL === void 0) { normalizeEOL = true; }\r\n        this._finish();\r\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.isBasicASCII, normalizeEOL);\r\n    };\r\n    PieceTreeTextBufferBuilder.prototype._finish = function () {\r\n        if (this.chunks.length === 0) {\r\n            this._acceptChunk1('', true);\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._hasPreviousChar = false;\r\n            // recreate last chunk\r\n            var lastChunk = this.chunks[this.chunks.length - 1];\r\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\r\n            var newLineStarts = createLineStartsFast(lastChunk.buffer);\r\n            lastChunk.lineStarts = newLineStarts;\r\n            if (this._previousChar === 13 /* CarriageReturn */) {\r\n                this.cr++;\r\n            }\r\n        }\r\n    };\r\n    return PieceTreeTextBufferBuilder;\r\n}());\r\nexport { PieceTreeTextBufferBuilder };\r\n"]},"metadata":{},"sourceType":"module"}