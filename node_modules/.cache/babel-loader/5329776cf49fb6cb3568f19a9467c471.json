{"ast":null,"code":"var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\nvar _fourPointsTransform = require(\"./fourPointsTransform\");\n\nvar buildTransformer = _fourPointsTransform.buildTransformer;\n/**\n * Utilities for mouse or touch events.\n */\n\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\nvar EVENT_SAVED_PROP = '___zrEVENTSAVED';\nvar _calcOut = [];\n/**\n * Get the `zrX` and `zrY`, which are relative to the top-left of\n * the input `el`.\n * CSS transform (2D & 3D) is supported.\n *\n * The strategy to fetch the coords:\n * + If `calculate` is not set as `true`, users of this method should\n * ensure that `el` is the same or the same size & location as `e.target`.\n * Otherwise the result coords are probably not expected. Because we\n * firstly try to get coords from e.offsetX/e.offsetY.\n * + If `calculate` is set as `true`, the input `el` can be any element\n * and we force to calculate the coords based on `el`.\n * + The input `el` should be positionable (not position:static).\n *\n * The force `calculate` can be used in case like:\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} e Mouse event or touch event.\n * @param {Object} out Get `out.zrX` and `out.zrY` as the result.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n */\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n\n  if (calculate || !env.canvasSupported) {\n    calculateZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          calculateZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction calculateZrXY(el, e, out) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\n  if (el.getBoundingClientRect && env.domSupported) {\n    var ex = e.clientX;\n    var ey = e.clientY;\n\n    if (el.nodeName.toUpperCase() === 'CANVAS') {\n      // Original approach, which do not support CSS transform.\n      // marker can not be locationed in a canvas container\n      // (getBoundingClientRect is always 0). We do not support\n      // that input a pre-created canvas to zr while using css\n      // transform in iOS.\n      var box = el.getBoundingClientRect();\n      out.zrX = ex - box.left;\n      out.zrY = ey - box.top;\n      return;\n    } else {\n      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n      var transformer = preparePointerTransformer(prepareCoordMarkers(el, saved), saved);\n\n      if (transformer) {\n        transformer(_calcOut, ex, ey);\n        out.zrX = _calcOut[0];\n        out.zrY = _calcOut[1];\n        return;\n      }\n    }\n  }\n\n  out.zrX = out.zrY = 0;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position:absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved) {\n  var transformer = saved.transformer;\n  var oldSrcCoords = saved.srcCoords;\n  var useOld = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    useOld &= oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return useOld ? transformer : (saved.srcCoords = srcCoords, saved.transformer = buildTransformer(srcCoords, destCoords));\n}\n/**\n * Find native event compat for legency IE.\n * Should be called at the begining of a native event listener.\n *\n * @param {Event} [e] Mouse event or touch event or pointer event.\n *        For lagency IE, we use `window.event` is used.\n * @return {Event} The native event.\n */\n\n\nfunction getNativeEvent(e) {\n  return e || window.event;\n}\n/**\n * Normalize the coordinates of the input event.\n *\n * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of\n * the input `el`.\n * Get `e.zrDelta` if using mouse wheel.\n * Get `e.which`, see the comment inside this function.\n *\n * Do not calculate repeatly if `zrX` and `zrY` already exist.\n *\n * Notice: see comments in `clientToLocal`. check the relationship\n * between the result coords and the parameters `el` and `calculate`.\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} [e] See `getNativeEvent`.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n * @return {UIEvent} The normalized native UIEvent.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = getNativeEvent(e);\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, it may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\n  // `mousedown (pointerdown)` is the same as Chrome does.\n\n\n  return e;\n}\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Function} handler\n * @param {Object|boolean} opt If boolean, means `opt.capture`\n * @param {boolean} [opt.capture=false]\n * @param {boolean} [opt.passive=false]\n */\n\n\nfunction addEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    // Reproduct the console warning:\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\n    // Consider marking event handler as 'passive' to make the page more responsive.\n    // Just set console log level: verbose in chrome dev tool.\n    // then the warning log will be printed when addEventListener called.\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // We have not yet found a neat way to using passive. Because in zrender the dom event\n    // listener delegate all of the upper events of element. Some of those events need\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\n    // Before passive can be adopted, these issues should be considered:\n    // (1) Whether and how a zrender user specifies an event listener passive. And by default,\n    // passive or not.\n    // (2) How to tread that some zrender event listener is passive, and some is not. If\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\n    // compatibility should be handled.\n    // var opts = (env.passiveSupported && name === 'mousewheel')\n    //     ? {passive: true}\n    //     // By default, the third param of el.addEventListener is `capture: false`.\n    //     : void 0;\n    // el.addEventListener(name, handler /* , opts */);\n    el.addEventListener(name, handler, opt);\n  } else {\n    // For simplicity, do not implement `setCapture` for IE9-.\n    el.attachEvent('on' + name, handler);\n  }\n}\n/**\n * Parameter are the same as `addEventListener`.\n *\n * Notice that if a listener is registered twice, one with capture and one without,\n * remove each one separately. Removal of a capturing listener does not affect a\n * non-capturing version of the same listener, and vice versa.\n */\n\n\nfunction removeEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler, opt);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not use this method in zrender. It can only be\n * used by upper applications if necessary.\n *\n * @param {Event} e A mouse or touch event.\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n/**\n * This method only works for mouseup and mousedown. The functionality is restricted\n * for fault tolerance, See the `e.which` compatibility above.\n *\n * @param {MouseEvent} e\n * @return {boolean}\n */\n\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\n  return e.which === 2 || e.which === 3;\n}\n/**\n * To be removed.\n * @deprecated\n */\n\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // For backward compatibility\n\n\nexports.clientToLocal = clientToLocal;\nexports.getNativeEvent = getNativeEvent;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\nexports.notLeftMouse = notLeftMouse;","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/zrender/lib/core/event.js"],"names":["Eventful","require","exports","Dispatcher","env","_fourPointsTransform","buildTransformer","isDomLevel2","window","addEventListener","MOUSE_EVENT_REG","EVENT_SAVED_PROP","_calcOut","clientToLocal","el","e","out","calculate","canvasSupported","calculateZrXY","browser","firefox","layerX","offsetX","zrX","zrY","layerY","offsetY","getBoundingClientRect","domSupported","ex","clientX","ey","clientY","nodeName","toUpperCase","box","left","top","saved","transformer","preparePointerTransformer","prepareCoordMarkers","markers","propLR","propTB","i","marker","document","createElement","stl","style","idxLR","idxTB","cssText","join","appendChild","push","oldSrcCoords","srcCoords","useOld","destCoords","rect","ii","x","y","offsetLeft","offsetTop","getNativeEvent","event","normalizeEvent","eventType","type","isTouch","indexOf","zrDelta","wheelDelta","detail","touch","targetTouches","changedTouches","button","which","undefined","test","name","handler","opt","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","isMiddleOrRightButtonOnMouseUpDown","notLeftMouse"],"mappings":"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","sourcesContent":["var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\nvar _fourPointsTransform = require(\"./fourPointsTransform\");\n\nvar buildTransformer = _fourPointsTransform.buildTransformer;\n\n/**\n * Utilities for mouse or touch events.\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\nvar EVENT_SAVED_PROP = '___zrEVENTSAVED';\nvar _calcOut = [];\n/**\n * Get the `zrX` and `zrY`, which are relative to the top-left of\n * the input `el`.\n * CSS transform (2D & 3D) is supported.\n *\n * The strategy to fetch the coords:\n * + If `calculate` is not set as `true`, users of this method should\n * ensure that `el` is the same or the same size & location as `e.target`.\n * Otherwise the result coords are probably not expected. Because we\n * firstly try to get coords from e.offsetX/e.offsetY.\n * + If `calculate` is set as `true`, the input `el` can be any element\n * and we force to calculate the coords based on `el`.\n * + The input `el` should be positionable (not position:static).\n *\n * The force `calculate` can be used in case like:\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} e Mouse event or touch event.\n * @param {Object} out Get `out.zrX` and `out.zrY` as the result.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n */\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n\n  if (calculate || !env.canvasSupported) {\n    calculateZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          calculateZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction calculateZrXY(el, e, out) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\n  if (el.getBoundingClientRect && env.domSupported) {\n    var ex = e.clientX;\n    var ey = e.clientY;\n\n    if (el.nodeName.toUpperCase() === 'CANVAS') {\n      // Original approach, which do not support CSS transform.\n      // marker can not be locationed in a canvas container\n      // (getBoundingClientRect is always 0). We do not support\n      // that input a pre-created canvas to zr while using css\n      // transform in iOS.\n      var box = el.getBoundingClientRect();\n      out.zrX = ex - box.left;\n      out.zrY = ey - box.top;\n      return;\n    } else {\n      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n      var transformer = preparePointerTransformer(prepareCoordMarkers(el, saved), saved);\n\n      if (transformer) {\n        transformer(_calcOut, ex, ey);\n        out.zrX = _calcOut[0];\n        out.zrY = _calcOut[1];\n        return;\n      }\n    }\n  }\n\n  out.zrX = out.zrY = 0;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position:absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved) {\n  var transformer = saved.transformer;\n  var oldSrcCoords = saved.srcCoords;\n  var useOld = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    useOld &= oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return useOld ? transformer : (saved.srcCoords = srcCoords, saved.transformer = buildTransformer(srcCoords, destCoords));\n}\n/**\n * Find native event compat for legency IE.\n * Should be called at the begining of a native event listener.\n *\n * @param {Event} [e] Mouse event or touch event or pointer event.\n *        For lagency IE, we use `window.event` is used.\n * @return {Event} The native event.\n */\n\n\nfunction getNativeEvent(e) {\n  return e || window.event;\n}\n/**\n * Normalize the coordinates of the input event.\n *\n * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of\n * the input `el`.\n * Get `e.zrDelta` if using mouse wheel.\n * Get `e.which`, see the comment inside this function.\n *\n * Do not calculate repeatly if `zrX` and `zrY` already exist.\n *\n * Notice: see comments in `clientToLocal`. check the relationship\n * between the result coords and the parameters `el` and `calculate`.\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} [e] See `getNativeEvent`.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n * @return {UIEvent} The normalized native UIEvent.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = getNativeEvent(e);\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, it may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\n  // `mousedown (pointerdown)` is the same as Chrome does.\n\n\n  return e;\n}\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Function} handler\n * @param {Object|boolean} opt If boolean, means `opt.capture`\n * @param {boolean} [opt.capture=false]\n * @param {boolean} [opt.passive=false]\n */\n\n\nfunction addEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    // Reproduct the console warning:\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\n    // Consider marking event handler as 'passive' to make the page more responsive.\n    // Just set console log level: verbose in chrome dev tool.\n    // then the warning log will be printed when addEventListener called.\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // We have not yet found a neat way to using passive. Because in zrender the dom event\n    // listener delegate all of the upper events of element. Some of those events need\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\n    // Before passive can be adopted, these issues should be considered:\n    // (1) Whether and how a zrender user specifies an event listener passive. And by default,\n    // passive or not.\n    // (2) How to tread that some zrender event listener is passive, and some is not. If\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\n    // compatibility should be handled.\n    // var opts = (env.passiveSupported && name === 'mousewheel')\n    //     ? {passive: true}\n    //     // By default, the third param of el.addEventListener is `capture: false`.\n    //     : void 0;\n    // el.addEventListener(name, handler /* , opts */);\n    el.addEventListener(name, handler, opt);\n  } else {\n    // For simplicity, do not implement `setCapture` for IE9-.\n    el.attachEvent('on' + name, handler);\n  }\n}\n/**\n * Parameter are the same as `addEventListener`.\n *\n * Notice that if a listener is registered twice, one with capture and one without,\n * remove each one separately. Removal of a capturing listener does not affect a\n * non-capturing version of the same listener, and vice versa.\n */\n\n\nfunction removeEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler, opt);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not use this method in zrender. It can only be\n * used by upper applications if necessary.\n *\n * @param {Event} e A mouse or touch event.\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n/**\n * This method only works for mouseup and mousedown. The functionality is restricted\n * for fault tolerance, See the `e.which` compatibility above.\n *\n * @param {MouseEvent} e\n * @return {boolean}\n */\n\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\n  return e.which === 2 || e.which === 3;\n}\n/**\n * To be removed.\n * @deprecated\n */\n\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // For backward compatibility\n\n\nexports.clientToLocal = clientToLocal;\nexports.getNativeEvent = getNativeEvent;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\nexports.notLeftMouse = notLeftMouse;"]},"metadata":{},"sourceType":"script"}