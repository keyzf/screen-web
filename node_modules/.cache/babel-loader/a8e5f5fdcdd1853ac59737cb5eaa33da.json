{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { Disposable, toDisposable, combinedDisposable, DisposableStore } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nexport var Event;\n\n(function (Event) {\n  Event.None = function () {\n    return Disposable.None;\n  };\n  /**\r\n   * Given an event, returns another event which only fires once.\r\n   */\n\n\n  function once(event) {\n    return function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      } // we need this, in case the event fires during the listener call\n\n\n      var didFire = false;\n      var result;\n      result = event(function (e) {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n\n      if (didFire) {\n        result.dispose();\n      }\n\n      return result;\n    };\n  }\n\n  Event.once = once;\n  /**\r\n   * Given an event and a `map` function, returns another event which maps each element\r\n   * through the mapping function.\r\n   */\n\n  function map(event, map) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n\n      return event(function (i) {\n        return listener.call(thisArgs, map(i));\n      }, null, disposables);\n    });\n  }\n\n  Event.map = map;\n  /**\r\n   * Given an event and an `each` function, returns another identical event and calls\r\n   * the `each` function per each element.\r\n   */\n\n  function forEach(event, each) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n\n      return event(function (i) {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    });\n  }\n\n  Event.forEach = forEach;\n\n  function filter(event, filter) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n\n      return event(function (e) {\n        return filter(e) && listener.call(thisArgs, e);\n      }, null, disposables);\n    });\n  }\n\n  Event.filter = filter;\n  /**\r\n   * Given an event, returns the same event but typed as `Event<void>`.\r\n   */\n\n  function signal(event) {\n    return event;\n  }\n\n  Event.signal = signal;\n  /**\r\n   * Given a collection of events, returns a single event which emits\r\n   * whenever any of the provided events emit.\r\n   */\n\n  function any() {\n    var events = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      events[_i] = arguments[_i];\n    }\n\n    return function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n\n      return combinedDisposable.apply(void 0, events.map(function (event) {\n        return event(function (e) {\n          return listener.call(thisArgs, e);\n        }, null, disposables);\n      }));\n    };\n  }\n\n  Event.any = any;\n  /**\r\n   * Given an event and a `merge` function, returns another event which maps each element\r\n   * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n   */\n\n  function reduce(event, merge, initial) {\n    var output = initial;\n    return map(event, function (e) {\n      output = merge(output, e);\n      return output;\n    });\n  }\n\n  Event.reduce = reduce;\n  /**\r\n   * Given a chain of event processing functions (filter, map, etc), each\r\n   * function will be invoked per event & per listener. Snapshotting an event\r\n   * chain allows each function to be invoked just once per event.\r\n   */\n\n  function snapshot(event) {\n    var listener;\n    var emitter = new Emitter({\n      onFirstListenerAdd: function () {\n        listener = event(emitter.fire, emitter);\n      },\n      onLastListenerRemove: function () {\n        listener.dispose();\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.snapshot = snapshot;\n\n  function debounce(event, merge, delay, leading, leakWarningThreshold) {\n    if (delay === void 0) {\n      delay = 100;\n    }\n\n    if (leading === void 0) {\n      leading = false;\n    }\n\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var emitter = new Emitter({\n      leakWarningThreshold: leakWarningThreshold,\n      onFirstListenerAdd: function () {\n        subscription = event(function (cur) {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n\n          clearTimeout(handle);\n          handle = setTimeout(function () {\n            var _output = output;\n            output = undefined;\n            handle = undefined;\n\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n      onLastListenerRemove: function () {\n        subscription.dispose();\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.debounce = debounce;\n  /**\r\n   * Given an event, it returns another event which fires only once and as soon as\r\n   * the input event emits. The event data is the number of millis it took for the\r\n   * event to fire.\r\n   */\n\n  function stopwatch(event) {\n    var start = new Date().getTime();\n    return map(once(event), function (_) {\n      return new Date().getTime() - start;\n    });\n  }\n\n  Event.stopwatch = stopwatch;\n  /**\r\n   * Given an event, it returns another event which fires only when the event\r\n   * element changes.\r\n   */\n\n  function latch(event) {\n    var firstCall = true;\n    var cache;\n    return filter(event, function (value) {\n      var shouldEmit = firstCall || value !== cache;\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n\n  Event.latch = latch;\n  /**\r\n   * Buffers the provided event until a first listener comes\r\n   * along, at which point fire all the events at once and\r\n   * pipe the event from then on.\r\n   *\r\n   * ```typescript\r\n   * const emitter = new Emitter<number>();\r\n   * const event = emitter.event;\r\n   * const bufferedEvent = buffer(event);\r\n   *\r\n   * emitter.fire(1);\r\n   * emitter.fire(2);\r\n   * emitter.fire(3);\r\n   * // nothing...\r\n   *\r\n   * const listener = bufferedEvent(num => console.log(num));\r\n   * // 1, 2, 3\r\n   *\r\n   * emitter.fire(4);\r\n   * // 4\r\n   * ```\r\n   */\n\n  function buffer(event, nextTick, _buffer) {\n    if (nextTick === void 0) {\n      nextTick = false;\n    }\n\n    if (_buffer === void 0) {\n      _buffer = [];\n    }\n\n    var buffer = _buffer.slice();\n\n    var listener = event(function (e) {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n\n    var flush = function () {\n      if (buffer) {\n        buffer.forEach(function (e) {\n          return emitter.fire(e);\n        });\n      }\n\n      buffer = null;\n    };\n\n    var emitter = new Emitter({\n      onFirstListenerAdd: function () {\n        if (!listener) {\n          listener = event(function (e) {\n            return emitter.fire(e);\n          });\n        }\n      },\n      onFirstListenerDidAdd: function () {\n        if (buffer) {\n          if (nextTick) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onLastListenerRemove: function () {\n        if (listener) {\n          listener.dispose();\n        }\n\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.buffer = buffer;\n\n  var ChainableEvent =\n  /** @class */\n  function () {\n    function ChainableEvent(event) {\n      this.event = event;\n    }\n\n    ChainableEvent.prototype.map = function (fn) {\n      return new ChainableEvent(map(this.event, fn));\n    };\n\n    ChainableEvent.prototype.forEach = function (fn) {\n      return new ChainableEvent(forEach(this.event, fn));\n    };\n\n    ChainableEvent.prototype.filter = function (fn) {\n      return new ChainableEvent(filter(this.event, fn));\n    };\n\n    ChainableEvent.prototype.reduce = function (merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial));\n    };\n\n    ChainableEvent.prototype.latch = function () {\n      return new ChainableEvent(latch(this.event));\n    };\n\n    ChainableEvent.prototype.debounce = function (merge, delay, leading, leakWarningThreshold) {\n      if (delay === void 0) {\n        delay = 100;\n      }\n\n      if (leading === void 0) {\n        leading = false;\n      }\n\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n    };\n\n    ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    };\n\n    ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    };\n\n    return ChainableEvent;\n  }();\n\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n\n  Event.chain = chain;\n\n  function fromNodeEventEmitter(emitter, eventName, map) {\n    if (map === void 0) {\n      map = function (id) {\n        return id;\n      };\n    }\n\n    var fn = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return result.fire(map.apply(void 0, args));\n    };\n\n    var onFirstListenerAdd = function () {\n      return emitter.on(eventName, fn);\n    };\n\n    var onLastListenerRemove = function () {\n      return emitter.removeListener(eventName, fn);\n    };\n\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n\n  function fromDOMEventEmitter(emitter, eventName, map) {\n    if (map === void 0) {\n      map = function (id) {\n        return id;\n      };\n    }\n\n    var fn = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return result.fire(map.apply(void 0, args));\n    };\n\n    var onFirstListenerAdd = function () {\n      return emitter.addEventListener(eventName, fn);\n    };\n\n    var onLastListenerRemove = function () {\n      return emitter.removeEventListener(eventName, fn);\n    };\n\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n\n  function fromPromise(promise) {\n    var emitter = new Emitter();\n    var shouldEmit = false;\n    promise.then(undefined, function () {\n      return null;\n    }).then(function () {\n      if (!shouldEmit) {\n        setTimeout(function () {\n          return emitter.fire(undefined);\n        }, 0);\n      } else {\n        emitter.fire(undefined);\n      }\n    });\n    shouldEmit = true;\n    return emitter.event;\n  }\n\n  Event.fromPromise = fromPromise;\n\n  function toPromise(event) {\n    return new Promise(function (c) {\n      return once(event)(c);\n    });\n  }\n\n  Event.toPromise = toPromise;\n})(Event || (Event = {}));\n\nvar _globalLeakWarningThreshold = -1;\n\nvar LeakageMonitor =\n/** @class */\nfunction () {\n  function LeakageMonitor(customThreshold, name) {\n    if (name === void 0) {\n      name = Math.random().toString(18).slice(2, 5);\n    }\n\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n\n  LeakageMonitor.prototype.dispose = function () {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  };\n\n  LeakageMonitor.prototype.check = function (listenerCount) {\n    var _this = this;\n\n    var threshold = _globalLeakWarningThreshold;\n\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n\n    var stack = new Error().stack.split('\\n').slice(3).join('\\n');\n    var count = this._stacks.get(stack) || 0;\n\n    this._stacks.set(stack, count + 1);\n\n    this._warnCountdown -= 1;\n\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5; // find most frequent listener and print warning\n\n      var topStack_1;\n      var topCount_1 = 0;\n\n      this._stacks.forEach(function (count, stack) {\n        if (!topStack_1 || topCount_1 < count) {\n          topStack_1 = stack;\n          topCount_1 = count;\n        }\n      });\n\n      console.warn(\"[\" + this.name + \"] potential listener LEAK detected, having \" + listenerCount + \" listeners already. MOST frequent listener (\" + topCount_1 + \"):\");\n      console.warn(topStack_1);\n    }\n\n    return function () {\n      var count = _this._stacks.get(stack) || 0;\n\n      _this._stacks.set(stack, count - 1);\n    };\n  };\n\n  return LeakageMonitor;\n}();\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\n\n\nvar Emitter =\n/** @class */\nfunction () {\n  function Emitter(options) {\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n  }\n\n  Object.defineProperty(Emitter.prototype, \"event\", {\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._event) {\n        this._event = function (listener, thisArgs, disposables) {\n          if (!_this._listeners) {\n            _this._listeners = new LinkedList();\n          }\n\n          var firstListener = _this._listeners.isEmpty();\n\n          if (firstListener && _this._options && _this._options.onFirstListenerAdd) {\n            _this._options.onFirstListenerAdd(_this);\n          }\n\n          var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n          if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {\n            _this._options.onFirstListenerDidAdd(_this);\n          }\n\n          if (_this._options && _this._options.onListenerDidAdd) {\n            _this._options.onListenerDidAdd(_this, listener, thisArgs);\n          } // check and record this emitter for potential leakage\n\n\n          var removeMonitor;\n\n          if (_this._leakageMon) {\n            removeMonitor = _this._leakageMon.check(_this._listeners.size);\n          }\n\n          var result;\n          result = {\n            dispose: function () {\n              if (removeMonitor) {\n                removeMonitor();\n              }\n\n              result.dispose = Emitter._noop;\n\n              if (!_this._disposed) {\n                remove();\n\n                if (_this._options && _this._options.onLastListenerRemove) {\n                  var hasListeners = _this._listeners && !_this._listeners.isEmpty();\n\n                  if (!hasListeners) {\n                    _this._options.onLastListenerRemove(_this);\n                  }\n                }\n              }\n            }\n          };\n\n          if (disposables instanceof DisposableStore) {\n            disposables.add(result);\n          } else if (Array.isArray(disposables)) {\n            disposables.push(result);\n          }\n\n          return result;\n        };\n      }\n\n      return this._event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * To be kept private to fire an event to\r\n   * subscribers\r\n   */\n\n  Emitter.prototype.fire = function (event) {\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new LinkedList();\n      }\n\n      for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n        this._deliveryQueue.push([e.value, event]);\n      }\n\n      while (this._deliveryQueue.size > 0) {\n        var _a = this._deliveryQueue.shift(),\n            listener = _a[0],\n            event_1 = _a[1];\n\n        try {\n          if (typeof listener === 'function') {\n            listener.call(undefined, event_1);\n          } else {\n            listener[0].call(listener[1], event_1);\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n    }\n  };\n\n  Emitter.prototype.dispose = function () {\n    if (this._listeners) {\n      this._listeners.clear();\n    }\n\n    if (this._deliveryQueue) {\n      this._deliveryQueue.clear();\n    }\n\n    if (this._leakageMon) {\n      this._leakageMon.dispose();\n    }\n\n    this._disposed = true;\n  };\n\n  Emitter._noop = function () {};\n\n  return Emitter;\n}();\n\nexport { Emitter };\n\nvar PauseableEmitter =\n/** @class */\nfunction (_super) {\n  __extends(PauseableEmitter, _super);\n\n  function PauseableEmitter(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this._isPaused = 0;\n    _this._eventQueue = new LinkedList();\n    _this._mergeFn = options && options.merge;\n    return _this;\n  }\n\n  PauseableEmitter.prototype.pause = function () {\n    this._isPaused++;\n  };\n\n  PauseableEmitter.prototype.resume = function () {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        var events = this._eventQueue.toArray();\n\n        this._eventQueue.clear();\n\n        _super.prototype.fire.call(this, this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          _super.prototype.fire.call(this, this._eventQueue.shift());\n        }\n      }\n    }\n  };\n\n  PauseableEmitter.prototype.fire = function (event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        _super.prototype.fire.call(this, event);\n      }\n    }\n  };\n\n  return PauseableEmitter;\n}(Emitter);\n\nexport { PauseableEmitter };\n\nvar EventMultiplexer =\n/** @class */\nfunction () {\n  function EventMultiplexer() {\n    var _this = this;\n\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onFirstListenerAdd: function () {\n        return _this.onFirstListenerAdd();\n      },\n      onLastListenerRemove: function () {\n        return _this.onLastListenerRemove();\n      }\n    });\n  }\n\n  Object.defineProperty(EventMultiplexer.prototype, \"event\", {\n    get: function () {\n      return this.emitter.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  EventMultiplexer.prototype.add = function (event) {\n    var _this = this;\n\n    var e = {\n      event: event,\n      listener: null\n    };\n    this.events.push(e);\n\n    if (this.hasListeners) {\n      this.hook(e);\n    }\n\n    var dispose = function () {\n      if (_this.hasListeners) {\n        _this.unhook(e);\n      }\n\n      var idx = _this.events.indexOf(e);\n\n      _this.events.splice(idx, 1);\n    };\n\n    return toDisposable(onceFn(dispose));\n  };\n\n  EventMultiplexer.prototype.onFirstListenerAdd = function () {\n    var _this = this;\n\n    this.hasListeners = true;\n    this.events.forEach(function (e) {\n      return _this.hook(e);\n    });\n  };\n\n  EventMultiplexer.prototype.onLastListenerRemove = function () {\n    var _this = this;\n\n    this.hasListeners = false;\n    this.events.forEach(function (e) {\n      return _this.unhook(e);\n    });\n  };\n\n  EventMultiplexer.prototype.hook = function (e) {\n    var _this = this;\n\n    e.listener = e.event(function (r) {\n      return _this.emitter.fire(r);\n    });\n  };\n\n  EventMultiplexer.prototype.unhook = function (e) {\n    if (e.listener) {\n      e.listener.dispose();\n    }\n\n    e.listener = null;\n  };\n\n  EventMultiplexer.prototype.dispose = function () {\n    this.emitter.dispose();\n  };\n\n  return EventMultiplexer;\n}();\n\nexport { EventMultiplexer };\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\n\nvar EventBufferer =\n/** @class */\nfunction () {\n  function EventBufferer() {\n    this.buffers = [];\n  }\n\n  EventBufferer.prototype.wrapEvent = function (event) {\n    var _this = this;\n\n    return function (listener, thisArgs, disposables) {\n      return event(function (i) {\n        var buffer = _this.buffers[_this.buffers.length - 1];\n\n        if (buffer) {\n          buffer.push(function () {\n            return listener.call(thisArgs, i);\n          });\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  };\n\n  EventBufferer.prototype.bufferEvents = function (fn) {\n    var buffer = [];\n    this.buffers.push(buffer);\n    var r = fn();\n    this.buffers.pop();\n    buffer.forEach(function (flush) {\n      return flush();\n    });\n    return r;\n  };\n\n  return EventBufferer;\n}();\n\nexport { EventBufferer };\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\n\nvar Relay =\n/** @class */\nfunction () {\n  function Relay() {\n    var _this = this;\n\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: function () {\n        _this.listening = true;\n        _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);\n      },\n      onLastListenerRemove: function () {\n        _this.listening = false;\n\n        _this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n\n  Object.defineProperty(Relay.prototype, \"input\", {\n    set: function (event) {\n      this.inputEvent = event;\n\n      if (this.listening) {\n        this.inputEventListener.dispose();\n        this.inputEventListener = event(this.emitter.fire, this.emitter);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Relay.prototype.dispose = function () {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  };\n\n  return Relay;\n}();\n\nexport { Relay };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/event.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","onUnexpectedError","once","onceFn","Disposable","toDisposable","combinedDisposable","DisposableStore","LinkedList","Event","None","event","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","_i","arguments","length","apply","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debounce","delay","leading","leakWarningThreshold","subscription","undefined","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","stopwatch","start","Date","getTime","_","latch","firstCall","cache","value","shouldEmit","buffer","nextTick","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","fn","on","chain","fromNodeEventEmitter","eventName","id","args","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","then","toPromise","Promise","c","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","name","Math","random","toString","_warnCountdown","_stacks","clear","check","listenerCount","_this","threshold","Map","stack","Error","split","join","count","get","set","topStack_1","topCount_1","console","warn","options","_disposed","_options","_leakageMon","defineProperty","_event","_listeners","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","size","_noop","hasListeners","add","isArray","enumerable","configurable","_deliveryQueue","iter","iterator","next","done","_a","shift","event_1","PauseableEmitter","_super","_isPaused","_eventQueue","_mergeFn","pause","resume","toArray","EventMultiplexer","hook","unhook","idx","indexOf","splice","r","EventBufferer","buffers","wrapEvent","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { onUnexpectedError } from './errors.js';\r\nimport { once as onceFn } from './functional.js';\r\nimport { Disposable, toDisposable, combinedDisposable, DisposableStore } from './lifecycle.js';\r\nimport { LinkedList } from './linkedList.js';\r\nexport var Event;\r\n(function (Event) {\r\n    Event.None = function () { return Disposable.None; };\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     */\r\n    function once(event) {\r\n        return function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            // we need this, in case the event fires during the listener call\r\n            var didFire = false;\r\n            var result;\r\n            result = event(function (e) {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * Given an event and a `map` function, returns another event which maps each element\r\n     * through the mapping function.\r\n     */\r\n    function map(event, map) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);\r\n        });\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * Given an event and an `each` function, returns another identical event and calls\r\n     * the `each` function per each element.\r\n     */\r\n    function forEach(event, each) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);\r\n        });\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);\r\n        });\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    /**\r\n     * Given a collection of events, returns a single event which emits\r\n     * whenever any of the provided events emit.\r\n     */\r\n    function any() {\r\n        var events = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            events[_i] = arguments[_i];\r\n        }\r\n        return function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return combinedDisposable.apply(void 0, events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));\r\n        };\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * Given an event and a `merge` function, returns another event which maps each element\r\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n     */\r\n    function reduce(event, merge, initial) {\r\n        var output = initial;\r\n        return map(event, function (e) {\r\n            output = merge(output, e);\r\n            return output;\r\n        });\r\n    }\r\n    Event.reduce = reduce;\r\n    /**\r\n     * Given a chain of event processing functions (filter, map, etc), each\r\n     * function will be invoked per event & per listener. Snapshotting an event\r\n     * chain allows each function to be invoked just once per event.\r\n     */\r\n    function snapshot(event) {\r\n        var listener;\r\n        var emitter = new Emitter({\r\n            onFirstListenerAdd: function () {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onLastListenerRemove: function () {\r\n                listener.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.snapshot = snapshot;\r\n    function debounce(event, merge, delay, leading, leakWarningThreshold) {\r\n        if (delay === void 0) { delay = 100; }\r\n        if (leading === void 0) { leading = false; }\r\n        var subscription;\r\n        var output = undefined;\r\n        var handle = undefined;\r\n        var numDebouncedCalls = 0;\r\n        var emitter = new Emitter({\r\n            leakWarningThreshold: leakWarningThreshold,\r\n            onFirstListenerAdd: function () {\r\n                subscription = event(function (cur) {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    clearTimeout(handle);\r\n                    handle = setTimeout(function () {\r\n                        var _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    }, delay);\r\n                });\r\n            },\r\n            onLastListenerRemove: function () {\r\n                subscription.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * Given an event, it returns another event which fires only once and as soon as\r\n     * the input event emits. The event data is the number of millis it took for the\r\n     * event to fire.\r\n     */\r\n    function stopwatch(event) {\r\n        var start = new Date().getTime();\r\n        return map(once(event), function (_) { return new Date().getTime() - start; });\r\n    }\r\n    Event.stopwatch = stopwatch;\r\n    /**\r\n     * Given an event, it returns another event which fires only when the event\r\n     * element changes.\r\n     */\r\n    function latch(event) {\r\n        var firstCall = true;\r\n        var cache;\r\n        return filter(event, function (value) {\r\n            var shouldEmit = firstCall || value !== cache;\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        });\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * Buffers the provided event until a first listener comes\r\n     * along, at which point fire all the events at once and\r\n     * pipe the event from then on.\r\n     *\r\n     * ```typescript\r\n     * const emitter = new Emitter<number>();\r\n     * const event = emitter.event;\r\n     * const bufferedEvent = buffer(event);\r\n     *\r\n     * emitter.fire(1);\r\n     * emitter.fire(2);\r\n     * emitter.fire(3);\r\n     * // nothing...\r\n     *\r\n     * const listener = bufferedEvent(num => console.log(num));\r\n     * // 1, 2, 3\r\n     *\r\n     * emitter.fire(4);\r\n     * // 4\r\n     * ```\r\n     */\r\n    function buffer(event, nextTick, _buffer) {\r\n        if (nextTick === void 0) { nextTick = false; }\r\n        if (_buffer === void 0) { _buffer = []; }\r\n        var buffer = _buffer.slice();\r\n        var listener = event(function (e) {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        var flush = function () {\r\n            if (buffer) {\r\n                buffer.forEach(function (e) { return emitter.fire(e); });\r\n            }\r\n            buffer = null;\r\n        };\r\n        var emitter = new Emitter({\r\n            onFirstListenerAdd: function () {\r\n                if (!listener) {\r\n                    listener = event(function (e) { return emitter.fire(e); });\r\n                }\r\n            },\r\n            onFirstListenerDidAdd: function () {\r\n                if (buffer) {\r\n                    if (nextTick) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onLastListenerRemove: function () {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    var ChainableEvent = /** @class */ (function () {\r\n        function ChainableEvent(event) {\r\n            this.event = event;\r\n        }\r\n        ChainableEvent.prototype.map = function (fn) {\r\n            return new ChainableEvent(map(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.forEach = function (fn) {\r\n            return new ChainableEvent(forEach(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.filter = function (fn) {\r\n            return new ChainableEvent(filter(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.reduce = function (merge, initial) {\r\n            return new ChainableEvent(reduce(this.event, merge, initial));\r\n        };\r\n        ChainableEvent.prototype.latch = function () {\r\n            return new ChainableEvent(latch(this.event));\r\n        };\r\n        ChainableEvent.prototype.debounce = function (merge, delay, leading, leakWarningThreshold) {\r\n            if (delay === void 0) { delay = 100; }\r\n            if (leading === void 0) { leading = false; }\r\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\r\n        };\r\n        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {\r\n            return this.event(listener, thisArgs, disposables);\r\n        };\r\n        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {\r\n            return once(this.event)(listener, thisArgs, disposables);\r\n        };\r\n        return ChainableEvent;\r\n    }());\r\n    function chain(event) {\r\n        return new ChainableEvent(event);\r\n    }\r\n    Event.chain = chain;\r\n    function fromNodeEventEmitter(emitter, eventName, map) {\r\n        if (map === void 0) { map = function (id) { return id; }; }\r\n        var fn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return result.fire(map.apply(void 0, args));\r\n        };\r\n        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };\r\n        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };\r\n        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    function fromDOMEventEmitter(emitter, eventName, map) {\r\n        if (map === void 0) { map = function (id) { return id; }; }\r\n        var fn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return result.fire(map.apply(void 0, args));\r\n        };\r\n        var onFirstListenerAdd = function () { return emitter.addEventListener(eventName, fn); };\r\n        var onLastListenerRemove = function () { return emitter.removeEventListener(eventName, fn); };\r\n        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    function fromPromise(promise) {\r\n        var emitter = new Emitter();\r\n        var shouldEmit = false;\r\n        promise\r\n            .then(undefined, function () { return null; })\r\n            .then(function () {\r\n            if (!shouldEmit) {\r\n                setTimeout(function () { return emitter.fire(undefined); }, 0);\r\n            }\r\n            else {\r\n                emitter.fire(undefined);\r\n            }\r\n        });\r\n        shouldEmit = true;\r\n        return emitter.event;\r\n    }\r\n    Event.fromPromise = fromPromise;\r\n    function toPromise(event) {\r\n        return new Promise(function (c) { return once(event)(c); });\r\n    }\r\n    Event.toPromise = toPromise;\r\n})(Event || (Event = {}));\r\nvar _globalLeakWarningThreshold = -1;\r\nvar LeakageMonitor = /** @class */ (function () {\r\n    function LeakageMonitor(customThreshold, name) {\r\n        if (name === void 0) { name = Math.random().toString(18).slice(2, 5); }\r\n        this.customThreshold = customThreshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    LeakageMonitor.prototype.dispose = function () {\r\n        if (this._stacks) {\r\n            this._stacks.clear();\r\n        }\r\n    };\r\n    LeakageMonitor.prototype.check = function (listenerCount) {\r\n        var _this = this;\r\n        var threshold = _globalLeakWarningThreshold;\r\n        if (typeof this.customThreshold === 'number') {\r\n            threshold = this.customThreshold;\r\n        }\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        var stack = new Error().stack.split('\\n').slice(3).join('\\n');\r\n        var count = (this._stacks.get(stack) || 0);\r\n        this._stacks.set(stack, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            // find most frequent listener and print warning\r\n            var topStack_1;\r\n            var topCount_1 = 0;\r\n            this._stacks.forEach(function (count, stack) {\r\n                if (!topStack_1 || topCount_1 < count) {\r\n                    topStack_1 = stack;\r\n                    topCount_1 = count;\r\n                }\r\n            });\r\n            console.warn(\"[\" + this.name + \"] potential listener LEAK detected, having \" + listenerCount + \" listeners already. MOST frequent listener (\" + topCount_1 + \"):\");\r\n            console.warn(topStack_1);\r\n        }\r\n        return function () {\r\n            var count = (_this._stacks.get(stack) || 0);\r\n            _this._stacks.set(stack, count - 1);\r\n        };\r\n    };\r\n    return LeakageMonitor;\r\n}());\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nvar Emitter = /** @class */ (function () {\r\n    function Emitter(options) {\r\n        this._disposed = false;\r\n        this._options = options;\r\n        this._leakageMon = _globalLeakWarningThreshold > 0\r\n            ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\r\n            : undefined;\r\n    }\r\n    Object.defineProperty(Emitter.prototype, \"event\", {\r\n        /**\r\n         * For the public to allow to subscribe\r\n         * to events from this Emitter\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            if (!this._event) {\r\n                this._event = function (listener, thisArgs, disposables) {\r\n                    if (!_this._listeners) {\r\n                        _this._listeners = new LinkedList();\r\n                    }\r\n                    var firstListener = _this._listeners.isEmpty();\r\n                    if (firstListener && _this._options && _this._options.onFirstListenerAdd) {\r\n                        _this._options.onFirstListenerAdd(_this);\r\n                    }\r\n                    var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\r\n                    if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {\r\n                        _this._options.onFirstListenerDidAdd(_this);\r\n                    }\r\n                    if (_this._options && _this._options.onListenerDidAdd) {\r\n                        _this._options.onListenerDidAdd(_this, listener, thisArgs);\r\n                    }\r\n                    // check and record this emitter for potential leakage\r\n                    var removeMonitor;\r\n                    if (_this._leakageMon) {\r\n                        removeMonitor = _this._leakageMon.check(_this._listeners.size);\r\n                    }\r\n                    var result;\r\n                    result = {\r\n                        dispose: function () {\r\n                            if (removeMonitor) {\r\n                                removeMonitor();\r\n                            }\r\n                            result.dispose = Emitter._noop;\r\n                            if (!_this._disposed) {\r\n                                remove();\r\n                                if (_this._options && _this._options.onLastListenerRemove) {\r\n                                    var hasListeners = (_this._listeners && !_this._listeners.isEmpty());\r\n                                    if (!hasListeners) {\r\n                                        _this._options.onLastListenerRemove(_this);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    };\r\n                    if (disposables instanceof DisposableStore) {\r\n                        disposables.add(result);\r\n                    }\r\n                    else if (Array.isArray(disposables)) {\r\n                        disposables.push(result);\r\n                    }\r\n                    return result;\r\n                };\r\n            }\r\n            return this._event;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    Emitter.prototype.fire = function (event) {\r\n        if (this._listeners) {\r\n            // put all [listener,event]-pairs into delivery queue\r\n            // then emit all event. an inner/nested event might be\r\n            // the driver of this\r\n            if (!this._deliveryQueue) {\r\n                this._deliveryQueue = new LinkedList();\r\n            }\r\n            for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\r\n                this._deliveryQueue.push([e.value, event]);\r\n            }\r\n            while (this._deliveryQueue.size > 0) {\r\n                var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];\r\n                try {\r\n                    if (typeof listener === 'function') {\r\n                        listener.call(undefined, event_1);\r\n                    }\r\n                    else {\r\n                        listener[0].call(listener[1], event_1);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    onUnexpectedError(e);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Emitter.prototype.dispose = function () {\r\n        if (this._listeners) {\r\n            this._listeners.clear();\r\n        }\r\n        if (this._deliveryQueue) {\r\n            this._deliveryQueue.clear();\r\n        }\r\n        if (this._leakageMon) {\r\n            this._leakageMon.dispose();\r\n        }\r\n        this._disposed = true;\r\n    };\r\n    Emitter._noop = function () { };\r\n    return Emitter;\r\n}());\r\nexport { Emitter };\r\nvar PauseableEmitter = /** @class */ (function (_super) {\r\n    __extends(PauseableEmitter, _super);\r\n    function PauseableEmitter(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this._isPaused = 0;\r\n        _this._eventQueue = new LinkedList();\r\n        _this._mergeFn = options && options.merge;\r\n        return _this;\r\n    }\r\n    PauseableEmitter.prototype.pause = function () {\r\n        this._isPaused++;\r\n    };\r\n    PauseableEmitter.prototype.resume = function () {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                var events = this._eventQueue.toArray();\r\n                this._eventQueue.clear();\r\n                _super.prototype.fire.call(this, this._mergeFn(events));\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    _super.prototype.fire.call(this, this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    };\r\n    PauseableEmitter.prototype.fire = function (event) {\r\n        if (this._listeners) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                _super.prototype.fire.call(this, event);\r\n            }\r\n        }\r\n    };\r\n    return PauseableEmitter;\r\n}(Emitter));\r\nexport { PauseableEmitter };\r\nvar EventMultiplexer = /** @class */ (function () {\r\n    function EventMultiplexer() {\r\n        var _this = this;\r\n        this.hasListeners = false;\r\n        this.events = [];\r\n        this.emitter = new Emitter({\r\n            onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },\r\n            onLastListenerRemove: function () { return _this.onLastListenerRemove(); }\r\n        });\r\n    }\r\n    Object.defineProperty(EventMultiplexer.prototype, \"event\", {\r\n        get: function () {\r\n            return this.emitter.event;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventMultiplexer.prototype.add = function (event) {\r\n        var _this = this;\r\n        var e = { event: event, listener: null };\r\n        this.events.push(e);\r\n        if (this.hasListeners) {\r\n            this.hook(e);\r\n        }\r\n        var dispose = function () {\r\n            if (_this.hasListeners) {\r\n                _this.unhook(e);\r\n            }\r\n            var idx = _this.events.indexOf(e);\r\n            _this.events.splice(idx, 1);\r\n        };\r\n        return toDisposable(onceFn(dispose));\r\n    };\r\n    EventMultiplexer.prototype.onFirstListenerAdd = function () {\r\n        var _this = this;\r\n        this.hasListeners = true;\r\n        this.events.forEach(function (e) { return _this.hook(e); });\r\n    };\r\n    EventMultiplexer.prototype.onLastListenerRemove = function () {\r\n        var _this = this;\r\n        this.hasListeners = false;\r\n        this.events.forEach(function (e) { return _this.unhook(e); });\r\n    };\r\n    EventMultiplexer.prototype.hook = function (e) {\r\n        var _this = this;\r\n        e.listener = e.event(function (r) { return _this.emitter.fire(r); });\r\n    };\r\n    EventMultiplexer.prototype.unhook = function (e) {\r\n        if (e.listener) {\r\n            e.listener.dispose();\r\n        }\r\n        e.listener = null;\r\n    };\r\n    EventMultiplexer.prototype.dispose = function () {\r\n        this.emitter.dispose();\r\n    };\r\n    return EventMultiplexer;\r\n}());\r\nexport { EventMultiplexer };\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nvar EventBufferer = /** @class */ (function () {\r\n    function EventBufferer() {\r\n        this.buffers = [];\r\n    }\r\n    EventBufferer.prototype.wrapEvent = function (event) {\r\n        var _this = this;\r\n        return function (listener, thisArgs, disposables) {\r\n            return event(function (i) {\r\n                var buffer = _this.buffers[_this.buffers.length - 1];\r\n                if (buffer) {\r\n                    buffer.push(function () { return listener.call(thisArgs, i); });\r\n                }\r\n                else {\r\n                    listener.call(thisArgs, i);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    };\r\n    EventBufferer.prototype.bufferEvents = function (fn) {\r\n        var buffer = [];\r\n        this.buffers.push(buffer);\r\n        var r = fn();\r\n        this.buffers.pop();\r\n        buffer.forEach(function (flush) { return flush(); });\r\n        return r;\r\n    };\r\n    return EventBufferer;\r\n}());\r\nexport { EventBufferer };\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nvar Relay = /** @class */ (function () {\r\n    function Relay() {\r\n        var _this = this;\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onFirstListenerDidAdd: function () {\r\n                _this.listening = true;\r\n                _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);\r\n            },\r\n            onLastListenerRemove: function () {\r\n                _this.listening = false;\r\n                _this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    Object.defineProperty(Relay.prototype, \"input\", {\r\n        set: function (event) {\r\n            this.inputEvent = event;\r\n            if (this.listening) {\r\n                this.inputEventListener.dispose();\r\n                this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Relay.prototype.dispose = function () {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    };\r\n    return Relay;\r\n}());\r\nexport { Relay };\r\n"]},"metadata":{},"sourceType":"module"}