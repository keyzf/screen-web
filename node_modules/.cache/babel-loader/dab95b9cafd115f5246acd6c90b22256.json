{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1\n  /* ColorMask */\n  ) >>> 0\n  /* ColorOffset */\n  ;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254\n  /* ColorMaskInverse */\n  | color << 0\n  /* ColorOffset */\n  ;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2\n  /* IsVisitedMask */\n  ) >>> 1\n  /* IsVisitedOffset */\n  === 1;\n}\n\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253\n  /* IsVisitedMaskInverse */\n  | (value ? 1 : 0) << 1\n  /* IsVisitedOffset */\n  ;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4\n  /* IsForValidationMask */\n  ) >>> 2\n  /* IsForValidationOffset */\n  === 1;\n}\n\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251\n  /* IsForValidationMaskInverse */\n  | (value ? 1 : 0) << 2\n  /* IsForValidationOffset */\n  ;\n}\n\nexport function getNodeIsInOverviewRuler(node) {\n  return (node.metadata & 8\n  /* IsInOverviewRulerMask */\n  ) >>> 3\n  /* IsInOverviewRulerOffset */\n  === 1;\n}\n\nfunction setNodeIsInOverviewRuler(node, value) {\n  node.metadata = node.metadata & 247\n  /* IsInOverviewRulerMaskInverse */\n  | (value ? 1 : 0) << 3\n  /* IsInOverviewRulerOffset */\n  ;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 48\n  /* StickinessMask */\n  ) >>> 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 207\n  /* StickinessMaskInverse */\n  | stickiness << 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 64\n  /* CollapseOnReplaceEditMask */\n  ) >>> 6\n  /* CollapseOnReplaceEditOffset */\n  === 1;\n}\n\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 191\n  /* CollapseOnReplaceEditMaskInverse */\n  | (value ? 1 : 0) << 6\n  /* CollapseOnReplaceEditOffset */\n  ;\n}\n\nvar IntervalNode =\n/** @class */\nfunction () {\n  function IntervalNode(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1\n    /* Red */\n    );\n    this.start = start;\n    this.end = end; // FORCE_OVERFLOWING_TEST: this.delta = start;\n\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n\n    _setNodeStickiness(this, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    setNodeIsInOverviewRuler(this, false);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n\n  IntervalNode.prototype.reset = function (versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  };\n\n  IntervalNode.prototype.setOptions = function (options) {\n    this.options = options;\n    var className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\"\n    /* EditorErrorDecoration */\n    || className === \"squiggly-warning\"\n    /* EditorWarningDecoration */\n    || className === \"squiggly-info\"\n    /* EditorInfoDecoration */\n    );\n\n    _setNodeStickiness(this, this.options.stickiness);\n\n    setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  };\n\n  IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  };\n\n  IntervalNode.prototype.detach = function () {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  };\n\n  return IntervalNode;\n}();\n\nexport { IntervalNode };\nexport var SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0\n/* Black */\n);\n\nvar IntervalTree =\n/** @class */\nfunction () {\n  function IntervalTree() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n\n  IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n\n  IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n\n\n  IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  };\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n\n\n  IntervalTree.prototype.collectNodesPostOrder = function () {\n    return collectNodesPostOrder(this);\n  };\n\n  IntervalTree.prototype.insert = function (node) {\n    rbTreeInsert(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype.delete = function (node) {\n    rbTreeDelete(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\n    var initialNode = node;\n    var delta = 0;\n\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n\n      node = node.parent;\n    }\n\n    var nodeStart = initialNode.start + delta;\n    var nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  };\n\n  IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    var nodesOfInterest = searchForEditing(this, offset, offset + length); // (2) remove all nodes that are intersecting this edit\n\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary(); // (3) edit all tree nodes except the nodes of interest\n\n\n    noOverlapReplace(this, offset, offset + length, textLength);\n\n    this._normalizeDeltaIfNecessary(); // (4) edit the nodes of interest and insert them back in the tree\n\n\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  };\n\n  return IntervalTree;\n}();\n\nexport { IntervalTree }; //#region Delta Normalization\n\nfunction normalizeDelta(T) {\n  var node = T.root;\n  var delta = 0;\n\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true); // going up from this node\n\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n\n    node = node.parent;\n  }\n\n  setNodeIsVisited(T.root, false);\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n\n  if (moveSemantics === 1\n  /* ForceMove */\n  ) {\n      return false;\n    }\n\n  if (moveSemantics === 2\n  /* ForceStay */\n  ) {\n      return true;\n    }\n\n  return markerStickToPreviousCharacter;\n}\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\n\n\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  var nodeStickiness = getNodeStickiness(node);\n  var startStickToPreviousCharacter = nodeStickiness === 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var endStickToPreviousCharacter = nodeStickiness === 1\n  /* NeverGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var deletingCnt = end - start;\n  var insertingCnt = textLength;\n  var commonLength = Math.min(deletingCnt, insertingCnt);\n  var nodeStart = node.start;\n  var startDone = false;\n  var nodeEnd = node.end;\n  var endDone = false;\n\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n\n  {\n    var moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : deletingCnt > 0 ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  if (commonLength > 0 && !forceMoveMarkers) {\n    var moveSemantics = deletingCnt > insertingCnt ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  {\n    var moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  } // Finish\n\n  var deltaColumn = insertingCnt - deletingCnt;\n\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\n\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var editDelta = textLength - (end - start);\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n\n      if (node.delta < -1073741824\n      /* MIN_SAFE_DELTA */\n      || node.delta > 1073741824\n      /* MAX_SAFE_DELTA */\n      ) {\n          T.requestNormalizeDelta = true;\n        } // cover case a) from above\n      // there is no need to search this node or its right subtree\n\n\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n} //#endregion\n//#region Searching\n\n\nfunction collectNodesFromOwner(T, ownerId) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction collectNodesPostOrder(T) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  var node = T.root;\n  var delta = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    var include = true;\n\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n\n    if (include) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      var include = true;\n\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n} //#endregion\n//#region Insertion\n\n\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0\n    /* Black */\n    );\n    T.root = newNode;\n    return T.root;\n  }\n\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent); // repair tree\n\n  var x = newNode;\n\n  while (x !== T.root && getNodeColor(x.parent) === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      var y = x.parent.parent.left;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n\n  setNodeColor(T.root, 0\n  /* Black */\n  );\n  return newNode;\n}\n\nfunction treeInsert(T, z) {\n  var delta = 0;\n  var x = T.root;\n  var zAbsoluteStart = z.start;\n  var zAbsoluteEnd = z.end;\n\n  while (true) {\n    var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1\n  /* Red */\n  );\n} //#endregion\n//#region Deletion\n\n\nfunction rbTreeDelete(T, z) {\n  var x;\n  var y; // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z; // x's delta is no longer influenced by z's delta\n\n    x.delta += z.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right; // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n\n    if (y.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || y.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n  }\n\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0\n    /* Black */\n    );\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n\n  var yWasRed = getNodeColor(y) === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n\n  z.detach();\n\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n\n    resetSentinel();\n    return;\n  }\n\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  } // RB-DELETE-FIXUP\n\n\n  var w;\n\n  while (x !== T.root && getNodeColor(x) === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          leftRotate(T, x.parent);\n          w = x.parent.right;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.right) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.left, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            rightRotate(T, w);\n            w = x.parent.right;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.right, 0\n        /* Black */\n        );\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          rightRotate(T, x.parent);\n          w = x.parent.left;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.left) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.right, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            leftRotate(T, w);\n            w = x.parent.left;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.left, 0\n        /* Black */\n        );\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n\n  setNodeColor(x, 0\n  /* Black */\n  );\n  resetSentinel();\n}\n\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\n\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n\n  SENTINEL.start = 0; // optional\n\n  SENTINEL.end = 0; // optional\n} //#endregion\n//#region Rotations\n\n\nfunction leftRotate(T, x) {\n  var y = x.right; // set y.\n\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent; // link x's parent to y.\n\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x; // put x on y's left.\n\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\n\nfunction rightRotate(T, y) {\n  var x = y.left;\n  y.delta -= x.delta;\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent;\n\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n} //#endregion\n//#region max end computation\n\n\nfunction computeMaxEnd(node) {\n  var maxEnd = node.end;\n\n  if (node.left !== SENTINEL) {\n    var leftMaxEnd = node.left.maxEnd;\n\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n\n  if (node.right !== SENTINEL) {\n    var rightMaxEnd = node.right.maxEnd + node.delta;\n\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n\n  return maxEnd;\n}\n\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    var maxEnd = computeMaxEnd(node);\n\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n} //#endregion\n//#region utils\n\n\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n\n  return aStart - bStart;\n} //#endregion","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInOverviewRuler","setNodeIsInOverviewRuler","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","prototype","reset","versionId","setOptions","className","overviewRuler","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport function getNodeColor(node) {\r\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\r\n}\r\nfunction setNodeColor(node, color) {\r\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\r\n}\r\nfunction getNodeIsVisited(node) {\r\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\r\n}\r\nfunction setNodeIsVisited(node, value) {\r\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\r\n}\r\nfunction getNodeIsForValidation(node) {\r\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\r\n}\r\nfunction setNodeIsForValidation(node, value) {\r\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\r\n}\r\nexport function getNodeIsInOverviewRuler(node) {\r\n    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;\r\n}\r\nfunction setNodeIsInOverviewRuler(node, value) {\r\n    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));\r\n}\r\nfunction getNodeStickiness(node) {\r\n    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);\r\n}\r\nfunction _setNodeStickiness(node, stickiness) {\r\n    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));\r\n}\r\nfunction getCollapseOnReplaceEdit(node) {\r\n    return ((node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */) === 1;\r\n}\r\nfunction setCollapseOnReplaceEdit(node, value) {\r\n    node.metadata = ((node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */));\r\n}\r\nvar IntervalNode = /** @class */ (function () {\r\n    function IntervalNode(id, start, end) {\r\n        this.metadata = 0;\r\n        this.parent = this;\r\n        this.left = this;\r\n        this.right = this;\r\n        setNodeColor(this, 1 /* Red */);\r\n        this.start = start;\r\n        this.end = end;\r\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\r\n        this.delta = 0;\r\n        this.maxEnd = end;\r\n        this.id = id;\r\n        this.ownerId = 0;\r\n        this.options = null;\r\n        setNodeIsForValidation(this, false);\r\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        setNodeIsInOverviewRuler(this, false);\r\n        setCollapseOnReplaceEdit(this, false);\r\n        this.cachedVersionId = 0;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = null;\r\n        setNodeIsVisited(this, false);\r\n    }\r\n    IntervalNode.prototype.reset = function (versionId, start, end, range) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.maxEnd = end;\r\n        this.cachedVersionId = versionId;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = range;\r\n    };\r\n    IntervalNode.prototype.setOptions = function (options) {\r\n        this.options = options;\r\n        var className = this.options.className;\r\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\r\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\r\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\r\n        _setNodeStickiness(this, this.options.stickiness);\r\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\r\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\r\n    };\r\n    IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\r\n        if (this.cachedVersionId !== cachedVersionId) {\r\n            this.range = null;\r\n        }\r\n        this.cachedVersionId = cachedVersionId;\r\n        this.cachedAbsoluteStart = absoluteStart;\r\n        this.cachedAbsoluteEnd = absoluteEnd;\r\n    };\r\n    IntervalNode.prototype.detach = function () {\r\n        this.parent = null;\r\n        this.left = null;\r\n        this.right = null;\r\n    };\r\n    return IntervalNode;\r\n}());\r\nexport { IntervalNode };\r\nexport var SENTINEL = new IntervalNode(null, 0, 0);\r\nSENTINEL.parent = SENTINEL;\r\nSENTINEL.left = SENTINEL;\r\nSENTINEL.right = SENTINEL;\r\nsetNodeColor(SENTINEL, 0 /* Black */);\r\nvar IntervalTree = /** @class */ (function () {\r\n    function IntervalTree() {\r\n        this.root = SENTINEL;\r\n        this.requestNormalizeDelta = false;\r\n    }\r\n    IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    };\r\n    IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    };\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\r\n        return collectNodesFromOwner(this, ownerId);\r\n    };\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    IntervalTree.prototype.collectNodesPostOrder = function () {\r\n        return collectNodesPostOrder(this);\r\n    };\r\n    IntervalTree.prototype.insert = function (node) {\r\n        rbTreeInsert(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype.delete = function (node) {\r\n        rbTreeDelete(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\r\n        var initialNode = node;\r\n        var delta = 0;\r\n        while (node !== this.root) {\r\n            if (node === node.parent.right) {\r\n                delta += node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        var nodeStart = initialNode.start + delta;\r\n        var nodeEnd = initialNode.end + delta;\r\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n    };\r\n    IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\r\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\r\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\r\n        var nodesOfInterest = searchForEditing(this, offset, offset + length);\r\n        // (2) remove all nodes that are intersecting this edit\r\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            var node = nodesOfInterest[i];\r\n            rbTreeDelete(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n        // (3) edit all tree nodes except the nodes of interest\r\n        noOverlapReplace(this, offset, offset + length, textLength);\r\n        this._normalizeDeltaIfNecessary();\r\n        // (4) edit the nodes of interest and insert them back in the tree\r\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            var node = nodesOfInterest[i];\r\n            node.start = node.cachedAbsoluteStart;\r\n            node.end = node.cachedAbsoluteEnd;\r\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\r\n            node.maxEnd = node.end;\r\n            rbTreeInsert(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\r\n        if (!this.requestNormalizeDelta) {\r\n            return;\r\n        }\r\n        this.requestNormalizeDelta = false;\r\n        normalizeDelta(this);\r\n    };\r\n    return IntervalTree;\r\n}());\r\nexport { IntervalTree };\r\n//#region Delta Normalization\r\nfunction normalizeDelta(T) {\r\n    var node = T.root;\r\n    var delta = 0;\r\n    while (node !== SENTINEL) {\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        node.start = delta + node.start;\r\n        node.end = delta + node.end;\r\n        node.delta = 0;\r\n        recomputeMaxEnd(node);\r\n        setNodeIsVisited(node, true);\r\n        // going up from this node\r\n        setNodeIsVisited(node.left, false);\r\n        setNodeIsVisited(node.right, false);\r\n        if (node === node.parent.right) {\r\n            delta -= node.parent.delta;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\r\n    if (markerOffset < checkOffset) {\r\n        return true;\r\n    }\r\n    if (markerOffset > checkOffset) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 1 /* ForceMove */) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 2 /* ForceStay */) {\r\n        return true;\r\n    }\r\n    return markerStickToPreviousCharacter;\r\n}\r\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\r\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\r\n    var nodeStickiness = getNodeStickiness(node);\r\n    var startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    var endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    var deletingCnt = (end - start);\r\n    var insertingCnt = textLength;\r\n    var commonLength = Math.min(deletingCnt, insertingCnt);\r\n    var nodeStart = node.start;\r\n    var startDone = false;\r\n    var nodeEnd = node.end;\r\n    var endDone = false;\r\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\r\n        // This edit encompasses the entire decoration range\r\n        // and the decoration has asked to become collapsed\r\n        node.start = start;\r\n        startDone = true;\r\n        node.end = start;\r\n        endDone = true;\r\n    }\r\n    {\r\n        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    if (commonLength > 0 && !forceMoveMarkers) {\r\n        var moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    {\r\n        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.start = start + insertingCnt;\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.end = start + insertingCnt;\r\n            endDone = true;\r\n        }\r\n    }\r\n    // Finish\r\n    var deltaColumn = (insertingCnt - deletingCnt);\r\n    if (!startDone) {\r\n        node.start = Math.max(0, nodeStart + deltaColumn);\r\n    }\r\n    if (!endDone) {\r\n        node.end = Math.max(0, nodeEnd + deltaColumn);\r\n    }\r\n    if (node.start > node.end) {\r\n        node.end = node.start;\r\n    }\r\n}\r\nfunction searchForEditing(T, start, end) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= start) {\r\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction noOverlapReplace(T, start, end, textLength) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var editDelta = (textLength - (end - start));\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            recomputeMaxEnd(node);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            node.start += editDelta;\r\n            node.end += editDelta;\r\n            node.delta += editDelta;\r\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n                T.requestNormalizeDelta = true;\r\n            }\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\n//#endregion\r\n//#region Searching\r\nfunction collectNodesFromOwner(T, ownerId) {\r\n    var node = T.root;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        if (node.ownerId === ownerId) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction collectNodesPostOrder(T) {\r\n    var node = T.root;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        result[resultLen++] = node;\r\n        setNodeIsVisited(node, true);\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        nodeEnd = delta + node.end;\r\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n        var include = true;\r\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n            include = false;\r\n        }\r\n        if (filterOutValidation && getNodeIsForValidation(node)) {\r\n            include = false;\r\n        }\r\n        if (include) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < intervalStart) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > intervalEnd) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= intervalStart) {\r\n            // There is overlap\r\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n            var include = true;\r\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n                include = false;\r\n            }\r\n            if (filterOutValidation && getNodeIsForValidation(node)) {\r\n                include = false;\r\n            }\r\n            if (include) {\r\n                result[resultLen++] = node;\r\n            }\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\n//#endregion\r\n//#region Insertion\r\nfunction rbTreeInsert(T, newNode) {\r\n    if (T.root === SENTINEL) {\r\n        newNode.parent = SENTINEL;\r\n        newNode.left = SENTINEL;\r\n        newNode.right = SENTINEL;\r\n        setNodeColor(newNode, 0 /* Black */);\r\n        T.root = newNode;\r\n        return T.root;\r\n    }\r\n    treeInsert(T, newNode);\r\n    recomputeMaxEndWalkToRoot(newNode.parent);\r\n    // repair tree\r\n    var x = newNode;\r\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\r\n        if (x.parent === x.parent.parent.left) {\r\n            var y = x.parent.parent.right;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.right) {\r\n                    x = x.parent;\r\n                    leftRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n        else {\r\n            var y = x.parent.parent.left;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.left) {\r\n                    x = x.parent;\r\n                    rightRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(T.root, 0 /* Black */);\r\n    return newNode;\r\n}\r\nfunction treeInsert(T, z) {\r\n    var delta = 0;\r\n    var x = T.root;\r\n    var zAbsoluteStart = z.start;\r\n    var zAbsoluteEnd = z.end;\r\n    while (true) {\r\n        var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\r\n        if (cmp < 0) {\r\n            // this node should be inserted to the left\r\n            // => it is not affected by the node's delta\r\n            if (x.left === SENTINEL) {\r\n                z.start -= delta;\r\n                z.end -= delta;\r\n                z.maxEnd -= delta;\r\n                x.left = z;\r\n                break;\r\n            }\r\n            else {\r\n                x = x.left;\r\n            }\r\n        }\r\n        else {\r\n            // this node should be inserted to the right\r\n            // => it is not affected by the node's delta\r\n            if (x.right === SENTINEL) {\r\n                z.start -= (delta + x.delta);\r\n                z.end -= (delta + x.delta);\r\n                z.maxEnd -= (delta + x.delta);\r\n                x.right = z;\r\n                break;\r\n            }\r\n            else {\r\n                delta += x.delta;\r\n                x = x.right;\r\n            }\r\n        }\r\n    }\r\n    z.parent = x;\r\n    z.left = SENTINEL;\r\n    z.right = SENTINEL;\r\n    setNodeColor(z, 1 /* Red */);\r\n}\r\n//#endregion\r\n//#region Deletion\r\nfunction rbTreeDelete(T, z) {\r\n    var x;\r\n    var y;\r\n    // RB-DELETE except we don't swap z and y in case c)\r\n    // i.e. we always delete what's pointed at by z.\r\n    if (z.left === SENTINEL) {\r\n        x = z.right;\r\n        y = z;\r\n        // x's delta is no longer influenced by z's delta\r\n        x.delta += z.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        x.start += z.delta;\r\n        x.end += z.delta;\r\n    }\r\n    else if (z.right === SENTINEL) {\r\n        x = z.left;\r\n        y = z;\r\n    }\r\n    else {\r\n        y = leftest(z.right);\r\n        x = y.right;\r\n        // y's delta is no longer influenced by z's delta,\r\n        // but we don't want to walk the entire right-hand-side subtree of x.\r\n        // we therefore maintain z's delta in y, and adjust only x\r\n        x.start += y.delta;\r\n        x.end += y.delta;\r\n        x.delta += y.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        y.start += z.delta;\r\n        y.end += z.delta;\r\n        y.delta = z.delta;\r\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n    }\r\n    if (y === T.root) {\r\n        T.root = x;\r\n        setNodeColor(x, 0 /* Black */);\r\n        z.detach();\r\n        resetSentinel();\r\n        recomputeMaxEnd(x);\r\n        T.root.parent = SENTINEL;\r\n        return;\r\n    }\r\n    var yWasRed = (getNodeColor(y) === 1 /* Red */);\r\n    if (y === y.parent.left) {\r\n        y.parent.left = x;\r\n    }\r\n    else {\r\n        y.parent.right = x;\r\n    }\r\n    if (y === z) {\r\n        x.parent = y.parent;\r\n    }\r\n    else {\r\n        if (y.parent === z) {\r\n            x.parent = y;\r\n        }\r\n        else {\r\n            x.parent = y.parent;\r\n        }\r\n        y.left = z.left;\r\n        y.right = z.right;\r\n        y.parent = z.parent;\r\n        setNodeColor(y, getNodeColor(z));\r\n        if (z === T.root) {\r\n            T.root = y;\r\n        }\r\n        else {\r\n            if (z === z.parent.left) {\r\n                z.parent.left = y;\r\n            }\r\n            else {\r\n                z.parent.right = y;\r\n            }\r\n        }\r\n        if (y.left !== SENTINEL) {\r\n            y.left.parent = y;\r\n        }\r\n        if (y.right !== SENTINEL) {\r\n            y.right.parent = y;\r\n        }\r\n    }\r\n    z.detach();\r\n    if (yWasRed) {\r\n        recomputeMaxEndWalkToRoot(x.parent);\r\n        if (y !== z) {\r\n            recomputeMaxEndWalkToRoot(y);\r\n            recomputeMaxEndWalkToRoot(y.parent);\r\n        }\r\n        resetSentinel();\r\n        return;\r\n    }\r\n    recomputeMaxEndWalkToRoot(x);\r\n    recomputeMaxEndWalkToRoot(x.parent);\r\n    if (y !== z) {\r\n        recomputeMaxEndWalkToRoot(y);\r\n        recomputeMaxEndWalkToRoot(y.parent);\r\n    }\r\n    // RB-DELETE-FIXUP\r\n    var w;\r\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\r\n        if (x === x.parent.left) {\r\n            w = x.parent.right;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent);\r\n                w = x.parent.right;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.right) === 0 /* Black */) {\r\n                    setNodeColor(w.left, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    rightRotate(T, w);\r\n                    w = x.parent.right;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.right, 0 /* Black */);\r\n                leftRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n        else {\r\n            w = x.parent.left;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent);\r\n                w = x.parent.left;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.left) === 0 /* Black */) {\r\n                    setNodeColor(w.right, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    leftRotate(T, w);\r\n                    w = x.parent.left;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.left, 0 /* Black */);\r\n                rightRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(x, 0 /* Black */);\r\n    resetSentinel();\r\n}\r\nfunction leftest(node) {\r\n    while (node.left !== SENTINEL) {\r\n        node = node.left;\r\n    }\r\n    return node;\r\n}\r\nfunction resetSentinel() {\r\n    SENTINEL.parent = SENTINEL;\r\n    SENTINEL.delta = 0; // optional\r\n    SENTINEL.start = 0; // optional\r\n    SENTINEL.end = 0; // optional\r\n}\r\n//#endregion\r\n//#region Rotations\r\nfunction leftRotate(T, x) {\r\n    var y = x.right; // set y.\r\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start += x.delta;\r\n    y.end += x.delta;\r\n    x.right = y.left; // turn y's left subtree into x's right subtree.\r\n    if (y.left !== SENTINEL) {\r\n        y.left.parent = x;\r\n    }\r\n    y.parent = x.parent; // link x's parent to y.\r\n    if (x.parent === SENTINEL) {\r\n        T.root = y;\r\n    }\r\n    else if (x === x.parent.left) {\r\n        x.parent.left = y;\r\n    }\r\n    else {\r\n        x.parent.right = y;\r\n    }\r\n    y.left = x; // put x on y's left.\r\n    x.parent = y;\r\n    recomputeMaxEnd(x);\r\n    recomputeMaxEnd(y);\r\n}\r\nfunction rightRotate(T, y) {\r\n    var x = y.left;\r\n    y.delta -= x.delta;\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start -= x.delta;\r\n    y.end -= x.delta;\r\n    y.left = x.right;\r\n    if (x.right !== SENTINEL) {\r\n        x.right.parent = y;\r\n    }\r\n    x.parent = y.parent;\r\n    if (y.parent === SENTINEL) {\r\n        T.root = x;\r\n    }\r\n    else if (y === y.parent.right) {\r\n        y.parent.right = x;\r\n    }\r\n    else {\r\n        y.parent.left = x;\r\n    }\r\n    x.right = y;\r\n    y.parent = x;\r\n    recomputeMaxEnd(y);\r\n    recomputeMaxEnd(x);\r\n}\r\n//#endregion\r\n//#region max end computation\r\nfunction computeMaxEnd(node) {\r\n    var maxEnd = node.end;\r\n    if (node.left !== SENTINEL) {\r\n        var leftMaxEnd = node.left.maxEnd;\r\n        if (leftMaxEnd > maxEnd) {\r\n            maxEnd = leftMaxEnd;\r\n        }\r\n    }\r\n    if (node.right !== SENTINEL) {\r\n        var rightMaxEnd = node.right.maxEnd + node.delta;\r\n        if (rightMaxEnd > maxEnd) {\r\n            maxEnd = rightMaxEnd;\r\n        }\r\n    }\r\n    return maxEnd;\r\n}\r\nexport function recomputeMaxEnd(node) {\r\n    node.maxEnd = computeMaxEnd(node);\r\n}\r\nfunction recomputeMaxEndWalkToRoot(node) {\r\n    while (node !== SENTINEL) {\r\n        var maxEnd = computeMaxEnd(node);\r\n        if (node.maxEnd === maxEnd) {\r\n            // no need to go further\r\n            return;\r\n        }\r\n        node.maxEnd = maxEnd;\r\n        node = node.parent;\r\n    }\r\n}\r\n//#endregion\r\n//#region utils\r\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\r\n    if (aStart === bStart) {\r\n        return aEnd - bEnd;\r\n    }\r\n    return aStart - bStart;\r\n}\r\n//#endregion\r\n"]},"metadata":{},"sourceType":"module"}