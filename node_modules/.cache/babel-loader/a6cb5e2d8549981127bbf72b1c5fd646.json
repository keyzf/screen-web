{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { TreeError } from './tree.js';\nimport { tail2 } from '../../../common/arrays.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterator } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1\n      /* Visible */\n      ;\n\n    case false:\n      return 0\n      /* Hidden */\n      ;\n\n    default:\n      return visibility;\n  }\n}\n\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\n\nvar IndexTreeModel =\n/** @class */\nfunction () {\n  function IndexTreeModel(user, list, rootElement, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visible: true,\n      filterData: undefined\n    };\n  }\n\n  IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\n    var _a;\n\n    var _this = this;\n\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    var _b = this.getParentNodeWithListIndex(location),\n        parentNode = _b.parentNode,\n        listIndex = _b.listIndex,\n        revealed = _b.revealed,\n        visible = _b.visible;\n\n    var treeListElementsToInsert = [];\n    var nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), function (el) {\n      return _this.createTreeNode(el, parentNode, parentNode.visible ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      , revealed, treeListElementsToInsert, onDidCreateNode);\n    });\n    var lastIndex = location[location.length - 1]; // figure out what's the visible child start index right before the\n    // splice point\n\n    var visibleChildStartIndex = 0;\n\n    for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n      var child = parentNode.children[i];\n\n      if (child.visible) {\n        visibleChildStartIndex = child.visibleChildIndex;\n        break;\n      }\n    }\n\n    var nodesToInsert = [];\n    var insertedVisibleChildrenCount = 0;\n    var renderNodeCount = 0;\n    Iterator.forEach(nodesToInsertIterator, function (child) {\n      nodesToInsert.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n      }\n    });\n\n    var deletedNodes = (_a = parentNode.children).splice.apply(_a, __spreadArrays([lastIndex, deleteCount], nodesToInsert)); // figure out what is the count of deleted visible children\n\n\n    var deletedVisibleChildrenCount = 0;\n\n    for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\n      var child = deletedNodes_1[_i];\n\n      if (child.visible) {\n        deletedVisibleChildrenCount++;\n      }\n    } // and adjust for all visible children after the splice point\n\n\n    if (deletedVisibleChildrenCount !== 0) {\n      for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n        var child = parentNode.children[i];\n\n        if (child.visible) {\n          child.visibleChildIndex -= deletedVisibleChildrenCount;\n        }\n      }\n    } // update parent's visible children count\n\n\n    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n    if (revealed && visible) {\n      var visibleDeleteCount = deletedNodes.reduce(function (r, node) {\n        return r + (node.visible ? node.renderNodeCount : 0);\n      }, 0);\n\n      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\n      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n    }\n\n    if (deletedNodes.length > 0 && onDidDeleteNode) {\n      var visit_1 = function (node) {\n        onDidDeleteNode(node);\n        node.children.forEach(visit_1);\n      };\n\n      deletedNodes.forEach(visit_1);\n    }\n\n    this._onDidSplice.fire({\n      insertedNodes: nodesToInsert,\n      deletedNodes: deletedNodes\n    });\n  };\n\n  IndexTreeModel.prototype.rerender = function (location) {\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    var _a = this.getTreeNodeWithListIndex(location),\n        node = _a.node,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed;\n\n    if (revealed) {\n      this.list.splice(listIndex, 1, [node]);\n    }\n  };\n\n  IndexTreeModel.prototype.has = function (location) {\n    return this.hasTreeNode(location);\n  };\n\n  IndexTreeModel.prototype.getListIndex = function (location) {\n    var _a = this.getTreeNodeWithListIndex(location),\n        listIndex = _a.listIndex,\n        visible = _a.visible,\n        revealed = _a.revealed;\n\n    return visible && revealed ? listIndex : -1;\n  };\n\n  IndexTreeModel.prototype.getListRenderCount = function (location) {\n    return this.getTreeNode(location).renderNodeCount;\n  };\n\n  IndexTreeModel.prototype.isCollapsible = function (location) {\n    return this.getTreeNode(location).collapsible;\n  };\n\n  IndexTreeModel.prototype.setCollapsible = function (location, collapsible) {\n    var _this = this;\n\n    var node = this.getTreeNode(location);\n\n    if (typeof collapsible === 'undefined') {\n      collapsible = !node.collapsible;\n    }\n\n    var update = {\n      collapsible: collapsible\n    };\n    return this.eventBufferer.bufferEvents(function () {\n      return _this._setCollapseState(location, update);\n    });\n  };\n\n  IndexTreeModel.prototype.isCollapsed = function (location) {\n    return this.getTreeNode(location).collapsed;\n  };\n\n  IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\n    var _this = this;\n\n    var node = this.getTreeNode(location);\n\n    if (typeof collapsed === 'undefined') {\n      collapsed = !node.collapsed;\n    }\n\n    var update = {\n      collapsed: collapsed,\n      recursive: recursive || false\n    };\n    return this.eventBufferer.bufferEvents(function () {\n      return _this._setCollapseState(location, update);\n    });\n  };\n\n  IndexTreeModel.prototype._setCollapseState = function (location, update) {\n    var _a = this.getTreeNodeWithListIndex(location),\n        node = _a.node,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed;\n\n    var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n\n    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n      var onlyVisibleChildIndex = -1;\n\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n\n        if (child.visible) {\n          if (onlyVisibleChildIndex > -1) {\n            onlyVisibleChildIndex = -1;\n            break;\n          } else {\n            onlyVisibleChildIndex = i;\n          }\n        }\n      }\n\n      if (onlyVisibleChildIndex > -1) {\n        this._setCollapseState(__spreadArrays(location, [onlyVisibleChildIndex]), update);\n      }\n    }\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._setListNodeCollapseState = function (node, listIndex, revealed, update) {\n    var result = this._setNodeCollapseState(node, update, false);\n\n    if (!revealed || !node.visible || !result) {\n      return result;\n    }\n\n    var previousRenderNodeCount = node.renderNodeCount;\n    var toInsert = this.updateNodeAfterCollapseChange(node);\n    var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n    return result;\n  };\n\n  IndexTreeModel.prototype._setNodeCollapseState = function (node, update, deep) {\n    var result;\n\n    if (node === this.root) {\n      result = false;\n    } else {\n      if (isCollapsibleStateUpdate(update)) {\n        result = node.collapsible !== update.collapsible;\n        node.collapsible = update.collapsible;\n      } else if (!node.collapsible) {\n        result = false;\n      } else {\n        result = node.collapsed !== update.collapsed;\n        node.collapsed = update.collapsed;\n      }\n\n      if (result) {\n        this._onDidChangeCollapseState.fire({\n          node: node,\n          deep: deep\n        });\n      }\n    }\n\n    if (!isCollapsibleStateUpdate(update) && update.recursive) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        result = this._setNodeCollapseState(child, update, true) || result;\n      }\n    }\n\n    return result;\n  };\n\n  IndexTreeModel.prototype.expandTo = function (location) {\n    var _this = this;\n\n    this.eventBufferer.bufferEvents(function () {\n      var node = _this.getTreeNode(location);\n\n      while (node.parent) {\n        node = node.parent;\n        location = location.slice(0, location.length - 1);\n\n        if (node.collapsed) {\n          _this._setCollapseState(location, {\n            collapsed: false,\n            recursive: false\n          });\n        }\n      }\n    });\n  };\n\n  IndexTreeModel.prototype.refilter = function () {\n    var previousRenderNodeCount = this.root.renderNodeCount;\n    var toInsert = this.updateNodeAfterFilterChange(this.root);\n    this.list.splice(0, previousRenderNodeCount, toInsert);\n  };\n\n  IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n    var _this = this;\n\n    var node = {\n      parent: parent,\n      element: treeElement.element,\n      children: [],\n      depth: parent.depth + 1,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n      renderNodeCount: 1,\n      visible: true,\n      filterData: undefined\n    };\n\n    var visibility = this._filterNode(node, parentVisibility);\n\n    if (revealed) {\n      treeListElements.push(node);\n    }\n\n    var childElements = Iterator.from(treeElement.children);\n    var childRevealed = revealed && visibility !== 0\n    /* Hidden */\n    && !node.collapsed;\n    var childNodes = Iterator.map(childElements, function (el) {\n      return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n    });\n    var visibleChildrenCount = 0;\n    var renderNodeCount = 1;\n    Iterator.forEach(childNodes, function (child) {\n      node.children.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildrenCount++;\n      }\n    });\n    node.collapsible = node.collapsible || node.children.length > 0;\n    node.visibleChildrenCount = visibleChildrenCount;\n    node.visible = visibility === 2\n    /* Recurse */\n    ? visibleChildrenCount > 0 : visibility === 1\n    /* Visible */\n    ;\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        treeListElements.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount = renderNodeCount;\n    }\n\n    if (onDidCreateNode) {\n      onDidCreateNode(node);\n    }\n\n    return node;\n  };\n\n  IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n\n    this._updateNodeAfterCollapseChange(node, result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\n    if (node.visible === false) {\n      return 0;\n    }\n\n    result.push(node);\n    node.renderNodeCount = 1;\n\n    if (!node.collapsed) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n      }\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.renderNodeCount;\n  };\n\n  IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n\n    this._updateNodeAfterFilterChange(node, node.visible ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    , result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\n    if (revealed === void 0) {\n      revealed = true;\n    }\n\n    var visibility;\n\n    if (node !== this.root) {\n      visibility = this._filterNode(node, parentVisibility);\n\n      if (visibility === 0\n      /* Hidden */\n      ) {\n          node.visible = false;\n          node.renderNodeCount = 0;\n          return false;\n        }\n\n      if (revealed) {\n        result.push(node);\n      }\n    }\n\n    var resultStartLength = result.length;\n    node.renderNodeCount = node === this.root ? 0 : 1;\n    var hasVisibleDescendants = false;\n\n    if (!node.collapsed || visibility !== 0\n    /* Hidden */\n    ) {\n        var visibleChildIndex = 0;\n\n        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n          var child = _a[_i];\n          hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n          if (child.visible) {\n            child.visibleChildIndex = visibleChildIndex++;\n          }\n        }\n\n        node.visibleChildrenCount = visibleChildIndex;\n      } else {\n      node.visibleChildrenCount = 0;\n    }\n\n    if (node !== this.root) {\n      node.visible = visibility === 2\n      /* Recurse */\n      ? hasVisibleDescendants : visibility === 1\n      /* Visible */\n      ;\n    }\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        result.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount += result.length - resultStartLength;\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.visible;\n  };\n\n  IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\n    if (diff === 0) {\n      return;\n    }\n\n    while (node) {\n      node.renderNodeCount += diff;\n\n      this._onDidChangeRenderNodeCount.fire(node);\n\n      node = node.parent;\n    }\n  };\n\n  IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\n    var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1\n    /* Visible */\n    ;\n\n    if (typeof result === 'boolean') {\n      node.filterData = undefined;\n      return result ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      ;\n    } else if (isFilterResult(result)) {\n      node.filterData = result.data;\n      return getVisibleState(result.visibility);\n    } else {\n      node.filterData = undefined;\n      return getVisibleState(result);\n    }\n  }; // cheap\n\n\n  IndexTreeModel.prototype.hasTreeNode = function (location, node) {\n    if (node === void 0) {\n      node = this.root;\n    }\n\n    if (!location || location.length === 0) {\n      return true;\n    }\n\n    var index = location[0],\n        rest = location.slice(1);\n\n    if (index < 0 || index > node.children.length) {\n      return false;\n    }\n\n    return this.hasTreeNode(rest, node.children[index]);\n  }; // cheap\n\n\n  IndexTreeModel.prototype.getTreeNode = function (location, node) {\n    if (node === void 0) {\n      node = this.root;\n    }\n\n    if (!location || location.length === 0) {\n      return node;\n    }\n\n    var index = location[0],\n        rest = location.slice(1);\n\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    return this.getTreeNode(rest, node.children[index]);\n  }; // expensive\n\n\n  IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\n    if (location.length === 0) {\n      return {\n        node: this.root,\n        listIndex: -1,\n        revealed: true,\n        visible: false\n      };\n    }\n\n    var _a = this.getParentNodeWithListIndex(location),\n        parentNode = _a.parentNode,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed,\n        visible = _a.visible;\n\n    var index = location[location.length - 1];\n\n    if (index < 0 || index > parentNode.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    var node = parentNode.children[index];\n    return {\n      node: node,\n      listIndex: listIndex,\n      revealed: revealed,\n      visible: visible && node.visible\n    };\n  };\n\n  IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\n    if (node === void 0) {\n      node = this.root;\n    }\n\n    if (listIndex === void 0) {\n      listIndex = 0;\n    }\n\n    if (revealed === void 0) {\n      revealed = true;\n    }\n\n    if (visible === void 0) {\n      visible = true;\n    }\n\n    var index = location[0],\n        rest = location.slice(1);\n\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    } // TODO@joao perf!\n\n\n    for (var i = 0; i < index; i++) {\n      listIndex += node.children[i].renderNodeCount;\n    }\n\n    revealed = revealed && !node.collapsed;\n    visible = visible && node.visible;\n\n    if (rest.length === 0) {\n      return {\n        parentNode: node,\n        listIndex: listIndex,\n        revealed: revealed,\n        visible: visible\n      };\n    }\n\n    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n  };\n\n  IndexTreeModel.prototype.getNode = function (location) {\n    if (location === void 0) {\n      location = [];\n    }\n\n    return this.getTreeNode(location);\n  }; // TODO@joao perf!\n\n\n  IndexTreeModel.prototype.getNodeLocation = function (node) {\n    var location = [];\n    var indexTreeNode = node; // typing woes\n\n    while (indexTreeNode.parent) {\n      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n      indexTreeNode = indexTreeNode.parent;\n    }\n\n    return location.reverse();\n  };\n\n  IndexTreeModel.prototype.getParentNodeLocation = function (location) {\n    if (location.length === 0) {\n      return undefined;\n    } else if (location.length === 1) {\n      return [];\n    } else {\n      return tail2(location)[0];\n    }\n  };\n\n  return IndexTreeModel;\n}();\n\nexport { IndexTreeModel };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","TreeError","tail2","Emitter","EventBufferer","Iterator","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","user","list","rootElement","options","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","collapseByDefault","filter","autoExpandSingleChildren","root","parent","undefined","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","prototype","splice","location","deleteCount","toInsert","onDidCreateNode","onDidDeleteNode","_a","_this","_b","getParentNodeWithListIndex","parentNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","map","from","el","createTreeNode","lastIndex","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","forEach","push","deletedNodes","apply","deletedVisibleChildrenCount","_i","deletedNodes_1","visibleDeleteCount","reduce","node","_updateAncestorsRenderNodeCount","visit_1","fire","insertedNodes","rerender","getTreeNodeWithListIndex","has","hasTreeNode","getListIndex","getListRenderCount","getTreeNode","isCollapsible","setCollapsible","bufferEvents","_setCollapseState","isCollapsed","setCollapsed","recursive","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","slice","deep","expandTo","refilter","updateNodeAfterFilterChange","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","childNodes","pop","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","diff","data","index","rest","getNode","getNodeLocation","indexTreeNode","indexOf","reverse","getParentNodeLocation"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nimport { TreeError } from './tree.js';\r\nimport { tail2 } from '../../../common/arrays.js';\r\nimport { Emitter, EventBufferer } from '../../../common/event.js';\r\nimport { Iterator } from '../../../common/iterator.js';\r\nexport function isFilterResult(obj) {\r\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\r\n}\r\nexport function getVisibleState(visibility) {\r\n    switch (visibility) {\r\n        case true: return 1 /* Visible */;\r\n        case false: return 0 /* Hidden */;\r\n        default: return visibility;\r\n    }\r\n}\r\nfunction isCollapsibleStateUpdate(update) {\r\n    return typeof update.collapsible === 'boolean';\r\n}\r\nvar IndexTreeModel = /** @class */ (function () {\r\n    function IndexTreeModel(user, list, rootElement, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.user = user;\r\n        this.list = list;\r\n        this.rootRef = [];\r\n        this.eventBufferer = new EventBufferer();\r\n        this._onDidChangeCollapseState = new Emitter();\r\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\r\n        this._onDidChangeRenderNodeCount = new Emitter();\r\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\r\n        this._onDidSplice = new Emitter();\r\n        this.onDidSplice = this._onDidSplice.event;\r\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\r\n        this.filter = options.filter;\r\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\r\n        this.root = {\r\n            parent: undefined,\r\n            element: rootElement,\r\n            children: [],\r\n            depth: 0,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: false,\r\n            collapsed: false,\r\n            renderNodeCount: 0,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n    }\r\n    IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\r\n        var _a;\r\n        var _this = this;\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var _b = this.getParentNodeWithListIndex(location), parentNode = _b.parentNode, listIndex = _b.listIndex, revealed = _b.revealed, visible = _b.visible;\r\n        var treeListElementsToInsert = [];\r\n        var nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), function (el) { return _this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode); });\r\n        var lastIndex = location[location.length - 1];\r\n        // figure out what's the visible child start index right before the\r\n        // splice point\r\n        var visibleChildStartIndex = 0;\r\n        for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\r\n            var child = parentNode.children[i];\r\n            if (child.visible) {\r\n                visibleChildStartIndex = child.visibleChildIndex;\r\n                break;\r\n            }\r\n        }\r\n        var nodesToInsert = [];\r\n        var insertedVisibleChildrenCount = 0;\r\n        var renderNodeCount = 0;\r\n        Iterator.forEach(nodesToInsertIterator, function (child) {\r\n            nodesToInsert.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\r\n            }\r\n        });\r\n        var deletedNodes = (_a = parentNode.children).splice.apply(_a, __spreadArrays([lastIndex, deleteCount], nodesToInsert));\r\n        // figure out what is the count of deleted visible children\r\n        var deletedVisibleChildrenCount = 0;\r\n        for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\r\n            var child = deletedNodes_1[_i];\r\n            if (child.visible) {\r\n                deletedVisibleChildrenCount++;\r\n            }\r\n        }\r\n        // and adjust for all visible children after the splice point\r\n        if (deletedVisibleChildrenCount !== 0) {\r\n            for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\r\n                var child = parentNode.children[i];\r\n                if (child.visible) {\r\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\r\n                }\r\n            }\r\n        }\r\n        // update parent's visible children count\r\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\r\n        if (revealed && visible) {\r\n            var visibleDeleteCount = deletedNodes.reduce(function (r, node) { return r + (node.visible ? node.renderNodeCount : 0); }, 0);\r\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\r\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\r\n        }\r\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\r\n            var visit_1 = function (node) {\r\n                onDidDeleteNode(node);\r\n                node.children.forEach(visit_1);\r\n            };\r\n            deletedNodes.forEach(visit_1);\r\n        }\r\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes: deletedNodes });\r\n    };\r\n    IndexTreeModel.prototype.rerender = function (location) {\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\r\n        if (revealed) {\r\n            this.list.splice(listIndex, 1, [node]);\r\n        }\r\n    };\r\n    IndexTreeModel.prototype.has = function (location) {\r\n        return this.hasTreeNode(location);\r\n    };\r\n    IndexTreeModel.prototype.getListIndex = function (location) {\r\n        var _a = this.getTreeNodeWithListIndex(location), listIndex = _a.listIndex, visible = _a.visible, revealed = _a.revealed;\r\n        return visible && revealed ? listIndex : -1;\r\n    };\r\n    IndexTreeModel.prototype.getListRenderCount = function (location) {\r\n        return this.getTreeNode(location).renderNodeCount;\r\n    };\r\n    IndexTreeModel.prototype.isCollapsible = function (location) {\r\n        return this.getTreeNode(location).collapsible;\r\n    };\r\n    IndexTreeModel.prototype.setCollapsible = function (location, collapsible) {\r\n        var _this = this;\r\n        var node = this.getTreeNode(location);\r\n        if (typeof collapsible === 'undefined') {\r\n            collapsible = !node.collapsible;\r\n        }\r\n        var update = { collapsible: collapsible };\r\n        return this.eventBufferer.bufferEvents(function () { return _this._setCollapseState(location, update); });\r\n    };\r\n    IndexTreeModel.prototype.isCollapsed = function (location) {\r\n        return this.getTreeNode(location).collapsed;\r\n    };\r\n    IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\r\n        var _this = this;\r\n        var node = this.getTreeNode(location);\r\n        if (typeof collapsed === 'undefined') {\r\n            collapsed = !node.collapsed;\r\n        }\r\n        var update = { collapsed: collapsed, recursive: recursive || false };\r\n        return this.eventBufferer.bufferEvents(function () { return _this._setCollapseState(location, update); });\r\n    };\r\n    IndexTreeModel.prototype._setCollapseState = function (location, update) {\r\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\r\n        var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\r\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\r\n            var onlyVisibleChildIndex = -1;\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                var child = node.children[i];\r\n                if (child.visible) {\r\n                    if (onlyVisibleChildIndex > -1) {\r\n                        onlyVisibleChildIndex = -1;\r\n                        break;\r\n                    }\r\n                    else {\r\n                        onlyVisibleChildIndex = i;\r\n                    }\r\n                }\r\n            }\r\n            if (onlyVisibleChildIndex > -1) {\r\n                this._setCollapseState(__spreadArrays(location, [onlyVisibleChildIndex]), update);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._setListNodeCollapseState = function (node, listIndex, revealed, update) {\r\n        var result = this._setNodeCollapseState(node, update, false);\r\n        if (!revealed || !node.visible || !result) {\r\n            return result;\r\n        }\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var toInsert = this.updateNodeAfterCollapseChange(node);\r\n        var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\r\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._setNodeCollapseState = function (node, update, deep) {\r\n        var result;\r\n        if (node === this.root) {\r\n            result = false;\r\n        }\r\n        else {\r\n            if (isCollapsibleStateUpdate(update)) {\r\n                result = node.collapsible !== update.collapsible;\r\n                node.collapsible = update.collapsible;\r\n            }\r\n            else if (!node.collapsible) {\r\n                result = false;\r\n            }\r\n            else {\r\n                result = node.collapsed !== update.collapsed;\r\n                node.collapsed = update.collapsed;\r\n            }\r\n            if (result) {\r\n                this._onDidChangeCollapseState.fire({ node: node, deep: deep });\r\n            }\r\n        }\r\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                result = this._setNodeCollapseState(child, update, true) || result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype.expandTo = function (location) {\r\n        var _this = this;\r\n        this.eventBufferer.bufferEvents(function () {\r\n            var node = _this.getTreeNode(location);\r\n            while (node.parent) {\r\n                node = node.parent;\r\n                location = location.slice(0, location.length - 1);\r\n                if (node.collapsed) {\r\n                    _this._setCollapseState(location, { collapsed: false, recursive: false });\r\n                }\r\n            }\r\n        });\r\n    };\r\n    IndexTreeModel.prototype.refilter = function () {\r\n        var previousRenderNodeCount = this.root.renderNodeCount;\r\n        var toInsert = this.updateNodeAfterFilterChange(this.root);\r\n        this.list.splice(0, previousRenderNodeCount, toInsert);\r\n    };\r\n    IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\r\n        var _this = this;\r\n        var node = {\r\n            parent: parent,\r\n            element: treeElement.element,\r\n            children: [],\r\n            depth: parent.depth + 1,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\r\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\r\n            renderNodeCount: 1,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n        var visibility = this._filterNode(node, parentVisibility);\r\n        if (revealed) {\r\n            treeListElements.push(node);\r\n        }\r\n        var childElements = Iterator.from(treeElement.children);\r\n        var childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\r\n        var childNodes = Iterator.map(childElements, function (el) { return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode); });\r\n        var visibleChildrenCount = 0;\r\n        var renderNodeCount = 1;\r\n        Iterator.forEach(childNodes, function (child) {\r\n            node.children.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildrenCount++;\r\n            }\r\n        });\r\n        node.collapsible = node.collapsible || node.children.length > 0;\r\n        node.visibleChildrenCount = visibleChildrenCount;\r\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                treeListElements.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount = renderNodeCount;\r\n        }\r\n        if (onDidCreateNode) {\r\n            onDidCreateNode(node);\r\n        }\r\n        return node;\r\n    };\r\n    IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var result = [];\r\n        this._updateNodeAfterCollapseChange(node, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\r\n        if (node.visible === false) {\r\n            return 0;\r\n        }\r\n        result.push(node);\r\n        node.renderNodeCount = 1;\r\n        if (!node.collapsed) {\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\r\n            }\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.renderNodeCount;\r\n    };\r\n    IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var result = [];\r\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\r\n        if (revealed === void 0) { revealed = true; }\r\n        var visibility;\r\n        if (node !== this.root) {\r\n            visibility = this._filterNode(node, parentVisibility);\r\n            if (visibility === 0 /* Hidden */) {\r\n                node.visible = false;\r\n                node.renderNodeCount = 0;\r\n                return false;\r\n            }\r\n            if (revealed) {\r\n                result.push(node);\r\n            }\r\n        }\r\n        var resultStartLength = result.length;\r\n        node.renderNodeCount = node === this.root ? 0 : 1;\r\n        var hasVisibleDescendants = false;\r\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\r\n            var visibleChildIndex = 0;\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\r\n                if (child.visible) {\r\n                    child.visibleChildIndex = visibleChildIndex++;\r\n                }\r\n            }\r\n            node.visibleChildrenCount = visibleChildIndex;\r\n        }\r\n        else {\r\n            node.visibleChildrenCount = 0;\r\n        }\r\n        if (node !== this.root) {\r\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\r\n        }\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                result.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount += result.length - resultStartLength;\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.visible;\r\n    };\r\n    IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\r\n        if (diff === 0) {\r\n            return;\r\n        }\r\n        while (node) {\r\n            node.renderNodeCount += diff;\r\n            this._onDidChangeRenderNodeCount.fire(node);\r\n            node = node.parent;\r\n        }\r\n    };\r\n    IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\r\n        var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\r\n        if (typeof result === 'boolean') {\r\n            node.filterData = undefined;\r\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\r\n        }\r\n        else if (isFilterResult(result)) {\r\n            node.filterData = result.data;\r\n            return getVisibleState(result.visibility);\r\n        }\r\n        else {\r\n            node.filterData = undefined;\r\n            return getVisibleState(result);\r\n        }\r\n    };\r\n    // cheap\r\n    IndexTreeModel.prototype.hasTreeNode = function (location, node) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (!location || location.length === 0) {\r\n            return true;\r\n        }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            return false;\r\n        }\r\n        return this.hasTreeNode(rest, node.children[index]);\r\n    };\r\n    // cheap\r\n    IndexTreeModel.prototype.getTreeNode = function (location, node) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (!location || location.length === 0) {\r\n            return node;\r\n        }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        return this.getTreeNode(rest, node.children[index]);\r\n    };\r\n    // expensive\r\n    IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\r\n        if (location.length === 0) {\r\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\r\n        }\r\n        var _a = this.getParentNodeWithListIndex(location), parentNode = _a.parentNode, listIndex = _a.listIndex, revealed = _a.revealed, visible = _a.visible;\r\n        var index = location[location.length - 1];\r\n        if (index < 0 || index > parentNode.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var node = parentNode.children[index];\r\n        return { node: node, listIndex: listIndex, revealed: revealed, visible: visible && node.visible };\r\n    };\r\n    IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (listIndex === void 0) { listIndex = 0; }\r\n        if (revealed === void 0) { revealed = true; }\r\n        if (visible === void 0) { visible = true; }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        // TODO@joao perf!\r\n        for (var i = 0; i < index; i++) {\r\n            listIndex += node.children[i].renderNodeCount;\r\n        }\r\n        revealed = revealed && !node.collapsed;\r\n        visible = visible && node.visible;\r\n        if (rest.length === 0) {\r\n            return { parentNode: node, listIndex: listIndex, revealed: revealed, visible: visible };\r\n        }\r\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\r\n    };\r\n    IndexTreeModel.prototype.getNode = function (location) {\r\n        if (location === void 0) { location = []; }\r\n        return this.getTreeNode(location);\r\n    };\r\n    // TODO@joao perf!\r\n    IndexTreeModel.prototype.getNodeLocation = function (node) {\r\n        var location = [];\r\n        var indexTreeNode = node; // typing woes\r\n        while (indexTreeNode.parent) {\r\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\r\n            indexTreeNode = indexTreeNode.parent;\r\n        }\r\n        return location.reverse();\r\n    };\r\n    IndexTreeModel.prototype.getParentNodeLocation = function (location) {\r\n        if (location.length === 0) {\r\n            return undefined;\r\n        }\r\n        else if (location.length === 1) {\r\n            return [];\r\n        }\r\n        else {\r\n            return tail2(location)[0];\r\n        }\r\n    };\r\n    return IndexTreeModel;\r\n}());\r\nexport { IndexTreeModel };\r\n"]},"metadata":{},"sourceType":"module"}