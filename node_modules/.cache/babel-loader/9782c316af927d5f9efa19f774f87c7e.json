{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n  var eolCount = 0;\n  var firstLineLength = 0;\n  var lastLineStart = 0;\n\n  for (var i = 0, len = text.length; i < len; i++) {\n    var chr = text.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n\n        if (i + 1 < len && text.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            i++; // skip \\n\n          } else {// \\r... case\n          }\n\n        lastLineStart = i + 1;\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n        lastLineStart = i + 1;\n      }\n  }\n\n  if (eolCount === 0) {\n    firstLineLength = text.length;\n  }\n\n  return [eolCount, firstLineLength, text.length - lastLineStart];\n}\n\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0\n  /* LANGUAGEID_OFFSET */\n  | 0\n  /* Other */\n  << 8\n  /* TOKEN_TYPE_OFFSET */\n  | 0\n  /* None */\n  << 11\n  /* FONT_STYLE_OFFSET */\n  | 1\n  /* DefaultForeground */\n  << 14\n  /* FOREGROUND_OFFSET */\n  | 2\n  /* DefaultBackground */\n  << 23\n  /* BACKGROUND_OFFSET */\n  ) >>> 0;\n}\n\nvar EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\n\nvar MultilineTokensBuilder =\n/** @class */\nfunction () {\n  function MultilineTokensBuilder() {\n    this.tokens = [];\n  }\n\n  MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\n    if (this.tokens.length > 0) {\n      var last = this.tokens[this.tokens.length - 1];\n      var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n\n      if (lastLineNumber + 1 === lineNumber) {\n        // append\n        last.tokens.push(lineTokens);\n        return;\n      }\n    }\n\n    this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n  };\n\n  return MultilineTokensBuilder;\n}();\n\nexport { MultilineTokensBuilder };\n\nvar SparseEncodedTokens =\n/** @class */\nfunction () {\n  function SparseEncodedTokens(tokens) {\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n\n  SparseEncodedTokens.prototype.getMaxDeltaLine = function () {\n    var tokenCount = this.getTokenCount();\n\n    if (tokenCount === 0) {\n      return -1;\n    }\n\n    return this.getDeltaLine(tokenCount - 1);\n  };\n\n  SparseEncodedTokens.prototype.getTokenCount = function () {\n    return this._tokenCount;\n  };\n\n  SparseEncodedTokens.prototype.getDeltaLine = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex];\n  };\n\n  SparseEncodedTokens.prototype.getStartCharacter = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  };\n\n  SparseEncodedTokens.prototype.getEndCharacter = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  };\n\n  SparseEncodedTokens.prototype.getMetadata = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 3];\n  };\n\n  SparseEncodedTokens.prototype.clear = function () {\n    this._tokenCount = 0;\n  };\n\n  SparseEncodedTokens.prototype.acceptDeleteRange = function (horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n    // This is a bit complex, here are the cases I used to think about this:\n    //\n    // 1. The token starts before the deletion range\n    // 1a. The token is completely before the deletion range\n    //               -----------\n    //                          xxxxxxxxxxx\n    // 1b. The token starts before, the deletion range ends after the token\n    //               -----------\n    //                      xxxxxxxxxxx\n    // 1c. The token starts before, the deletion range ends precisely with the token\n    //               ---------------\n    //                      xxxxxxxx\n    // 1d. The token starts before, the deletion range is inside the token\n    //               ---------------\n    //                    xxxxx\n    //\n    // 2. The token starts at the same position with the deletion range\n    // 2a. The token starts at the same position, and ends inside the deletion range\n    //               -------\n    //               xxxxxxxxxxx\n    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n    //               ----------\n    //               xxxxxxxxxx\n    // 2c. The token starts at the same position, and ends after the deletion range\n    //               -------------\n    //               xxxxxxx\n    //\n    // 3. The token starts inside the deletion range\n    // 3a. The token is inside the deletion range\n    //                -------\n    //             xxxxxxxxxxxxx\n    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n    //                ----------\n    //             xxxxxxxxxxxxx\n    // 3c. The token starts inside the deletion range, and ends after the deletion range\n    //                ------------\n    //             xxxxxxxxxxx\n    //\n    // 4. The token starts after the deletion range\n    //                  -----------\n    //          xxxxxxxx\n    //\n    var tokens = this._tokens;\n    var tokenCount = this._tokenCount;\n    var deletedLineCount = endDeltaLine - startDeltaLine;\n    var newTokenCount = 0;\n    var hasDeletedTokens = false;\n\n    for (var i = 0; i < tokenCount; i++) {\n      var srcOffset = 4 * i;\n      var tokenDeltaLine = tokens[srcOffset];\n      var tokenStartCharacter = tokens[srcOffset + 1];\n      var tokenEndCharacter = tokens[srcOffset + 2];\n      var tokenMetadata = tokens[srcOffset + 3];\n\n      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n        // 1a. The token is completely before the deletion range\n        // => nothing to do\n        newTokenCount++;\n        continue;\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n        // 1b, 1c, 1d\n        // => the token survives, but it needs to shrink\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 1d. The token starts before, the deletion range is inside the token\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 1b. The token starts before, the deletion range ends after the token\n          // 1c. The token starts before, the deletion range ends precisely with the token\n          // => the token shrinks its ending to the deletion start\n          tokenEndCharacter = startCharacter;\n        }\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n        // 2a, 2b, 2c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 2c. The token starts at the same position, and ends after the deletion range\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 2a. The token starts at the same position, and ends inside the deletion range\n          // 2b. The token starts at the same position, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n        // 3a, 3b, 3c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 3c. The token starts inside the deletion range, and ends after the deletion range\n          // => the token moves left and shrinks\n          if (tokenDeltaLine === startDeltaLine) {\n            // the deletion started on the same line as the token\n            // => the token moves left and shrinks\n            tokenStartCharacter = startCharacter;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          } else {\n            // the deletion started on a line above the token\n            // => the token moves to the beginning of the line\n            tokenStartCharacter = 0;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          }\n        } else {\n          // 3a. The token is inside the deletion range\n          // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine > endDeltaLine) {\n        // 4. (partial) The token starts after the deletion range, on a line below...\n        if (deletedLineCount === 0 && !hasDeletedTokens) {\n          // early stop, there is no need to walk all the tokens and do nothing...\n          newTokenCount = tokenCount;\n          break;\n        }\n\n        tokenDeltaLine -= deletedLineCount;\n      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n        // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n          tokenStartCharacter += horizontalShiftForFirstLineTokens;\n          tokenEndCharacter += horizontalShiftForFirstLineTokens;\n        }\n\n        tokenDeltaLine -= deletedLineCount;\n        tokenStartCharacter -= endCharacter - startCharacter;\n        tokenEndCharacter -= endCharacter - startCharacter;\n      } else {\n        throw new Error(\"Not possible!\");\n      }\n\n      var destOffset = 4 * newTokenCount;\n      tokens[destOffset] = tokenDeltaLine;\n      tokens[destOffset + 1] = tokenStartCharacter;\n      tokens[destOffset + 2] = tokenEndCharacter;\n      tokens[destOffset + 3] = tokenMetadata;\n      newTokenCount++;\n    }\n\n    this._tokenCount = newTokenCount;\n  };\n\n  SparseEncodedTokens.prototype.acceptInsertText = function (deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    // Here are the cases I used to think about this:\n    //\n    // 1. The token is completely before the insertion point\n    //            -----------   |\n    // 2. The token ends precisely at the insertion point\n    //            -----------|\n    // 3. The token contains the insertion point\n    //            -----|------\n    // 4. The token starts precisely at the insertion point\n    //            |-----------\n    // 5. The token is completely after the insertion point\n    //            |   -----------\n    //\n    var isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48\n    /* Digit0 */\n    && firstCharCode <= 57\n    /* Digit9 */\n    || firstCharCode >= 65\n    /* A */\n    && firstCharCode <= 90\n    /* Z */\n    || firstCharCode >= 97\n    /* a */\n    && firstCharCode <= 122\n    /* z */\n    );\n    var tokens = this._tokens;\n    var tokenCount = this._tokenCount;\n\n    for (var i = 0; i < tokenCount; i++) {\n      var offset = 4 * i;\n      var tokenDeltaLine = tokens[offset];\n      var tokenStartCharacter = tokens[offset + 1];\n      var tokenEndCharacter = tokens[offset + 2];\n\n      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n        // 1. The token is completely before the insertion point\n        // => nothing to do\n        continue;\n      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n        // 2. The token ends precisely at the insertion point\n        // => expand the end character only if inserting precisely one character that is a word character\n        if (isInsertingPreciselyOneWordCharacter) {\n          tokenEndCharacter += 1;\n        } else {\n          continue;\n        }\n      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n        // 3. The token contains the insertion point\n        if (eolCount === 0) {\n          // => just expand the end character\n          tokenEndCharacter += firstLineLength;\n        } else {\n          // => cut off the token\n          tokenEndCharacter = character;\n        }\n      } else {\n        // 4. or 5.\n        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n          // 4. The token starts precisely at the insertion point\n          // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n          // => otherwise behave as in case 5.\n          if (isInsertingPreciselyOneWordCharacter) {\n            continue;\n          }\n        } // => the token must move and keep its size constant\n\n\n        if (tokenDeltaLine === deltaLine) {\n          tokenDeltaLine += eolCount; // this token is on the line where the insertion is taking place\n\n          if (eolCount === 0) {\n            tokenStartCharacter += firstLineLength;\n            tokenEndCharacter += firstLineLength;\n          } else {\n            var tokenLength = tokenEndCharacter - tokenStartCharacter;\n            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n            tokenEndCharacter = tokenStartCharacter + tokenLength;\n          }\n        } else {\n          tokenDeltaLine += eolCount;\n        }\n      }\n\n      tokens[offset] = tokenDeltaLine;\n      tokens[offset + 1] = tokenStartCharacter;\n      tokens[offset + 2] = tokenEndCharacter;\n    }\n  };\n\n  return SparseEncodedTokens;\n}();\n\nexport { SparseEncodedTokens };\n\nvar LineTokens2 =\n/** @class */\nfunction () {\n  function LineTokens2(actual, startTokenIndex, endTokenIndex) {\n    this._actual = actual;\n    this._startTokenIndex = startTokenIndex;\n    this._endTokenIndex = endTokenIndex;\n  }\n\n  LineTokens2.prototype.getCount = function () {\n    return this._endTokenIndex - this._startTokenIndex + 1;\n  };\n\n  LineTokens2.prototype.getStartCharacter = function (tokenIndex) {\n    return this._actual.getStartCharacter(this._startTokenIndex + tokenIndex);\n  };\n\n  LineTokens2.prototype.getEndCharacter = function (tokenIndex) {\n    return this._actual.getEndCharacter(this._startTokenIndex + tokenIndex);\n  };\n\n  LineTokens2.prototype.getMetadata = function (tokenIndex) {\n    return this._actual.getMetadata(this._startTokenIndex + tokenIndex);\n  };\n\n  return LineTokens2;\n}();\n\nexport { LineTokens2 };\n\nvar MultilineTokens2 =\n/** @class */\nfunction () {\n  function MultilineTokens2(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  }\n\n  MultilineTokens2.prototype._updateEndLineNumber = function () {\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  };\n\n  MultilineTokens2.prototype.getLineTokens = function (lineNumber) {\n    if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n      var findResult = MultilineTokens2._findTokensWithLine(this.tokens, lineNumber - this.startLineNumber);\n\n      if (findResult) {\n        var startTokenIndex = findResult[0],\n            endTokenIndex = findResult[1];\n        return new LineTokens2(this.tokens, startTokenIndex, endTokenIndex);\n      }\n    }\n\n    return null;\n  };\n\n  MultilineTokens2._findTokensWithLine = function (tokens, deltaLine) {\n    var low = 0;\n    var high = tokens.getTokenCount() - 1;\n\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      var midDeltaLine = tokens.getDeltaLine(mid);\n\n      if (midDeltaLine < deltaLine) {\n        low = mid + 1;\n      } else if (midDeltaLine > deltaLine) {\n        high = mid - 1;\n      } else {\n        var min = mid;\n\n        while (min > low && tokens.getDeltaLine(min - 1) === deltaLine) {\n          min--;\n        }\n\n        var max = mid;\n\n        while (max < high && tokens.getDeltaLine(max + 1) === deltaLine) {\n          max++;\n        }\n\n        return [min, max];\n      }\n    }\n\n    if (tokens.getDeltaLine(low) === deltaLine) {\n      return [low, low];\n    }\n\n    return null;\n  };\n\n  MultilineTokens2.prototype.applyEdit = function (range, text) {\n    var _a = countEOL(text),\n        eolCount = _a[0],\n        firstLineLength = _a[1],\n        lastLineLength = _a[2];\n\n    this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0\n    /* Null */\n    );\n  };\n\n  MultilineTokens2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\n    this._updateEndLineNumber();\n  };\n\n  MultilineTokens2.prototype._acceptDeleteRange = function (range) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      // Nothing to delete\n      return;\n    }\n\n    var firstLineIndex = range.startLineNumber - this.startLineNumber;\n    var lastLineIndex = range.endLineNumber - this.startLineNumber;\n\n    if (lastLineIndex < 0) {\n      // this deletion occurs entirely before this block, so we only need to adjust line numbers\n      var deletedLinesCount = lastLineIndex - firstLineIndex;\n      this.startLineNumber -= deletedLinesCount;\n      return;\n    }\n\n    var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n    if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion occurs entirely after this block, so there is nothing to do\n      return;\n    }\n\n    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion completely encompasses this block\n      this.startLineNumber = 0;\n      this.tokens.clear();\n      return;\n    }\n\n    if (firstLineIndex < 0) {\n      var deletedBefore = -firstLineIndex;\n      this.startLineNumber -= deletedBefore;\n      this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n    } else {\n      this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n    }\n  };\n\n  MultilineTokens2.prototype._acceptInsertText = function (position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    var lineIndex = position.lineNumber - this.startLineNumber;\n\n    if (lineIndex < 0) {\n      // this insertion occurs before this block, so we only need to adjust line numbers\n      this.startLineNumber += eolCount;\n      return;\n    }\n\n    var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n    if (lineIndex >= tokenMaxDeltaLine + 1) {\n      // this insertion occurs after this block, so there is nothing to do\n      return;\n    }\n\n    this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n  };\n\n  return MultilineTokens2;\n}();\n\nexport { MultilineTokens2 };\n\nvar MultilineTokens =\n/** @class */\nfunction () {\n  function MultilineTokens(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n  }\n\n  return MultilineTokens;\n}();\n\nexport { MultilineTokens };\n\nfunction toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}\n\nvar TokensStore2 =\n/** @class */\nfunction () {\n  function TokensStore2() {\n    this._pieces = [];\n  }\n\n  TokensStore2.prototype.flush = function () {\n    this._pieces = [];\n  };\n\n  TokensStore2.prototype.set = function (pieces) {\n    this._pieces = pieces || [];\n  };\n\n  TokensStore2.prototype.addSemanticTokens = function (lineNumber, aTokens) {\n    var pieces = this._pieces;\n\n    if (pieces.length === 0) {\n      return aTokens;\n    }\n\n    var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n\n    var bTokens = this._pieces[pieceIndex].getLineTokens(lineNumber);\n\n    if (!bTokens) {\n      return aTokens;\n    }\n\n    var aLen = aTokens.getCount();\n    var bLen = bTokens.getCount();\n    var aIndex = 0;\n    var result = [],\n        resultLen = 0;\n\n    for (var bIndex = 0; bIndex < bLen; bIndex++) {\n      var bStartCharacter = bTokens.getStartCharacter(bIndex);\n      var bEndCharacter = bTokens.getEndCharacter(bIndex);\n      var bMetadata = bTokens.getMetadata(bIndex);\n      var bMask = ((bMetadata & 1\n      /* SEMANTIC_USE_ITALIC */\n      ? 2048\n      /* ITALIC_MASK */\n      : 0) | (bMetadata & 2\n      /* SEMANTIC_USE_BOLD */\n      ? 4096\n      /* BOLD_MASK */\n      : 0) | (bMetadata & 4\n      /* SEMANTIC_USE_UNDERLINE */\n      ? 8192\n      /* UNDERLINE_MASK */\n      : 0) | (bMetadata & 8\n      /* SEMANTIC_USE_FOREGROUND */\n      ? 8372224\n      /* FOREGROUND_MASK */\n      : 0) | (bMetadata & 16\n      /* SEMANTIC_USE_BACKGROUND */\n      ? 4286578688\n      /* BACKGROUND_MASK */\n      : 0)) >>> 0;\n      var aMask = ~bMask >>> 0; // push any token from `a` that is before `b`\n\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex);\n        aIndex++;\n      } // push the token from `a` if it intersects the token from `b`\n\n\n      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n        result[resultLen++] = bStartCharacter;\n        result[resultLen++] = aTokens.getMetadata(aIndex);\n      } // skip any tokens from `a` that are contained inside `b`\n\n\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask;\n        aIndex++;\n      }\n\n      if (aIndex < aLen && aTokens.getEndOffset(aIndex) === bEndCharacter) {\n        // `a` ends exactly at the same spot as `b`!\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask;\n        aIndex++;\n      } else {\n        var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1); // push the token from `b`\n\n        result[resultLen++] = bEndCharacter;\n        result[resultLen++] = aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask;\n      }\n    } // push the remaining tokens from `a`\n\n\n    while (aIndex < aLen) {\n      result[resultLen++] = aTokens.getEndOffset(aIndex);\n      result[resultLen++] = aTokens.getMetadata(aIndex);\n      aIndex++;\n    }\n\n    return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n  };\n\n  TokensStore2._findFirstPieceWithLine = function (pieces, lineNumber) {\n    var low = 0;\n    var high = pieces.length - 1;\n\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n\n      if (pieces[mid].endLineNumber < lineNumber) {\n        low = mid + 1;\n      } else if (pieces[mid].startLineNumber > lineNumber) {\n        high = mid - 1;\n      } else {\n        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n          mid--;\n        }\n\n        return mid;\n      }\n    }\n\n    return low;\n  }; //#region Editing\n\n\n  TokensStore2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    for (var _i = 0, _a = this._pieces; _i < _a.length; _i++) {\n      var piece = _a[_i];\n      piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n  };\n\n  return TokensStore2;\n}();\n\nexport { TokensStore2 };\n\nvar TokensStore =\n/** @class */\nfunction () {\n  function TokensStore() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n\n  TokensStore.prototype.flush = function () {\n    this._lineTokens = [];\n    this._len = 0;\n  };\n\n  TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\n    var rawLineTokens = null;\n\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText);\n    }\n\n    var lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n    return new LineTokens(lineTokens, lineText);\n  };\n\n  TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\n    var tokens = _tokens ? toUint32Array(_tokens) : null;\n\n    if (lineTextLength === 0) {\n      var hasDifferentLanguageId = false;\n\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n\n    if (!tokens || tokens.length === 0) {\n      var tokens_1 = new Uint32Array(2);\n      tokens_1[0] = lineTextLength;\n      tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens_1.buffer;\n    } // Ensure the last token covers the end of the text\n\n\n    tokens[tokens.length - 2] = lineTextLength;\n\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n\n    return tokens;\n  };\n\n  TokensStore.prototype._ensureLine = function (lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  };\n\n  TokensStore.prototype._deleteLines = function (start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n\n    this._lineTokens.splice(start, deleteCount);\n\n    this._len -= deleteCount;\n  };\n\n  TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n\n    var lineTokens = [];\n\n    for (var i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  };\n\n  TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\n    var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n\n    this._ensureLine(lineIndex);\n\n    this._lineTokens[lineIndex] = tokens;\n  }; //#region Editing\n\n\n  TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  };\n\n  TokensStore.prototype._acceptDeleteRange = function (range) {\n    var firstLineIndex = range.startLineNumber - 1;\n\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n\n      this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n\n    this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    var lastLineIndex = range.endLineNumber - 1;\n    var lastLineTokens = null;\n\n    if (lastLineIndex < this._len) {\n      lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    } // Take remaining text on last line and append it to remaining text on first line\n\n\n    this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens); // Delete middle lines\n\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  };\n\n  TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    var lineIndex = position.lineNumber - 1;\n\n    if (lineIndex >= this._len) {\n      return;\n    }\n\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n\n    this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n    this._insertLines(position.lineNumber, eolCount);\n  };\n\n  TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    return TokensStore._delete(lineTokens, 0, toChIndex);\n  };\n\n  TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var lineTextLength = tokens[tokens.length - 2];\n    return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n  };\n\n  TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1; // special case: deleting everything\n\n    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n      return EMPTY_LINE_TOKENS;\n    }\n\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n    var fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n    var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n    if (toChIndex < fromTokenEndOffset) {\n      // the delete range is inside a single token\n      var delta_1 = toChIndex - fromChIndex;\n\n      for (var i = fromTokenIndex; i < tokensCount; i++) {\n        tokens[i << 1] -= delta_1;\n      }\n\n      return lineTokens;\n    }\n\n    var dest;\n    var lastEnd;\n\n    if (fromTokenStartOffset !== fromChIndex) {\n      tokens[fromTokenIndex << 1] = fromChIndex;\n      dest = fromTokenIndex + 1 << 1;\n      lastEnd = fromChIndex;\n    } else {\n      dest = fromTokenIndex << 1;\n      lastEnd = fromTokenStartOffset;\n    }\n\n    var delta = toChIndex - fromChIndex;\n\n    for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n      var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\n      if (tokenEndOffset > lastEnd) {\n        tokens[dest++] = tokenEndOffset;\n        tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n        lastEnd = tokenEndOffset;\n      }\n    }\n\n    if (dest === tokens.length) {\n      // nothing to trim\n      return lineTokens;\n    }\n\n    var tmp = new Uint32Array(dest);\n    tmp.set(tokens.subarray(0, dest), 0);\n    return tmp.buffer;\n  };\n\n  TokensStore._append = function (lineTokens, _otherTokens) {\n    if (_otherTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    if (lineTokens === EMPTY_LINE_TOKENS) {\n      return _otherTokens;\n    }\n\n    if (lineTokens === null) {\n      return lineTokens;\n    }\n\n    if (_otherTokens === null) {\n      // cannot determine combined line length...\n      return null;\n    }\n\n    var myTokens = toUint32Array(lineTokens);\n    var otherTokens = toUint32Array(_otherTokens);\n    var otherTokensCount = otherTokens.length >>> 1;\n    var result = new Uint32Array(myTokens.length + otherTokens.length);\n    result.set(myTokens, 0);\n    var dest = myTokens.length;\n    var delta = myTokens[myTokens.length - 2];\n\n    for (var i = 0; i < otherTokensCount; i++) {\n      result[dest++] = otherTokens[i << 1] + delta;\n      result[dest++] = otherTokens[(i << 1) + 1];\n    }\n\n    return result.buffer;\n  };\n\n  TokensStore._insert = function (lineTokens, chIndex, textLength) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      // nothing to do\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1;\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\n    if (fromTokenIndex > 0) {\n      var fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n\n      if (fromTokenStartOffset === chIndex) {\n        fromTokenIndex--;\n      }\n    }\n\n    for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n      tokens[tokenIndex << 1] += textLength;\n    }\n\n    return lineTokens;\n  };\n\n  return TokensStore;\n}();\n\nexport { TokensStore };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js"],"names":["arrays","LineTokens","Position","TokenMetadata","countEOL","text","eolCount","firstLineLength","lastLineStart","i","len","length","chr","charCodeAt","getDefaultMetadata","topLevelLanguageId","EMPTY_LINE_TOKENS","Uint32Array","buffer","MultilineTokensBuilder","tokens","prototype","add","lineNumber","lineTokens","last","lastLineNumber","startLineNumber","push","MultilineTokens","SparseEncodedTokens","_tokens","_tokenCount","getMaxDeltaLine","tokenCount","getTokenCount","getDeltaLine","tokenIndex","getStartCharacter","getEndCharacter","getMetadata","clear","acceptDeleteRange","horizontalShiftForFirstLineTokens","startDeltaLine","startCharacter","endDeltaLine","endCharacter","deletedLineCount","newTokenCount","hasDeletedTokens","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","Error","destOffset","acceptInsertText","deltaLine","character","lastLineLength","firstCharCode","isInsertingPreciselyOneWordCharacter","offset","tokenLength","LineTokens2","actual","startTokenIndex","endTokenIndex","_actual","_startTokenIndex","_endTokenIndex","getCount","MultilineTokens2","endLineNumber","_updateEndLineNumber","getLineTokens","findResult","_findTokensWithLine","low","high","mid","Math","floor","midDeltaLine","min","max","applyEdit","range","_a","acceptEdit","_acceptDeleteRange","_acceptInsertText","startColumn","endColumn","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","position","lineIndex","column","toUint32Array","arr","TokensStore2","_pieces","flush","set","pieces","addSemanticTokens","aTokens","pieceIndex","_findFirstPieceWithLine","bTokens","aLen","bLen","aIndex","result","resultLen","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","getLineContent","_i","piece","TokensStore","_lineTokens","_len","getTokens","lineText","rawLineTokens","_massageTokens","lineTextLength","hasDifferentLanguageId","getLanguageId","tokens_1","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","arrayInsert","setTokens","_delete","_deleteEnding","lastLineTokens","_deleteBeginning","_append","_insert","toChIndex","fromChIndex","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta_1","dest","lastEnd","delta","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenMetadata } from '../modes.js';\r\nexport function countEOL(text) {\r\n    var eolCount = 0;\r\n    var firstLineLength = 0;\r\n    var lastLineStart = 0;\r\n    for (var i = 0, len = text.length; i < len; i++) {\r\n        var chr = text.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n            }\r\n            lastLineStart = i + 1;\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            lastLineStart = i + 1;\r\n        }\r\n    }\r\n    if (eolCount === 0) {\r\n        firstLineLength = text.length;\r\n    }\r\n    return [eolCount, firstLineLength, text.length - lastLineStart];\r\n}\r\nfunction getDefaultMetadata(topLevelLanguageId) {\r\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\r\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\r\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\r\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\r\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n}\r\nvar EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\r\nvar MultilineTokensBuilder = /** @class */ (function () {\r\n    function MultilineTokensBuilder() {\r\n        this.tokens = [];\r\n    }\r\n    MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\r\n        if (this.tokens.length > 0) {\r\n            var last = this.tokens[this.tokens.length - 1];\r\n            var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\r\n            if (lastLineNumber + 1 === lineNumber) {\r\n                // append\r\n                last.tokens.push(lineTokens);\r\n                return;\r\n            }\r\n        }\r\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\r\n    };\r\n    return MultilineTokensBuilder;\r\n}());\r\nexport { MultilineTokensBuilder };\r\nvar SparseEncodedTokens = /** @class */ (function () {\r\n    function SparseEncodedTokens(tokens) {\r\n        this._tokens = tokens;\r\n        this._tokenCount = tokens.length / 4;\r\n    }\r\n    SparseEncodedTokens.prototype.getMaxDeltaLine = function () {\r\n        var tokenCount = this.getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return -1;\r\n        }\r\n        return this.getDeltaLine(tokenCount - 1);\r\n    };\r\n    SparseEncodedTokens.prototype.getTokenCount = function () {\r\n        return this._tokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.getDeltaLine = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex];\r\n    };\r\n    SparseEncodedTokens.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    };\r\n    SparseEncodedTokens.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    };\r\n    SparseEncodedTokens.prototype.getMetadata = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 3];\r\n    };\r\n    SparseEncodedTokens.prototype.clear = function () {\r\n        this._tokenCount = 0;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptDeleteRange = function (horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\r\n        // This is a bit complex, here are the cases I used to think about this:\r\n        //\r\n        // 1. The token starts before the deletion range\r\n        // 1a. The token is completely before the deletion range\r\n        //               -----------\r\n        //                          xxxxxxxxxxx\r\n        // 1b. The token starts before, the deletion range ends after the token\r\n        //               -----------\r\n        //                      xxxxxxxxxxx\r\n        // 1c. The token starts before, the deletion range ends precisely with the token\r\n        //               ---------------\r\n        //                      xxxxxxxx\r\n        // 1d. The token starts before, the deletion range is inside the token\r\n        //               ---------------\r\n        //                    xxxxx\r\n        //\r\n        // 2. The token starts at the same position with the deletion range\r\n        // 2a. The token starts at the same position, and ends inside the deletion range\r\n        //               -------\r\n        //               xxxxxxxxxxx\r\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n        //               ----------\r\n        //               xxxxxxxxxx\r\n        // 2c. The token starts at the same position, and ends after the deletion range\r\n        //               -------------\r\n        //               xxxxxxx\r\n        //\r\n        // 3. The token starts inside the deletion range\r\n        // 3a. The token is inside the deletion range\r\n        //                -------\r\n        //             xxxxxxxxxxxxx\r\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n        //                ----------\r\n        //             xxxxxxxxxxxxx\r\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n        //                ------------\r\n        //             xxxxxxxxxxx\r\n        //\r\n        // 4. The token starts after the deletion range\r\n        //                  -----------\r\n        //          xxxxxxxx\r\n        //\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        var deletedLineCount = (endDeltaLine - startDeltaLine);\r\n        var newTokenCount = 0;\r\n        var hasDeletedTokens = false;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var srcOffset = 4 * i;\r\n            var tokenDeltaLine = tokens[srcOffset];\r\n            var tokenStartCharacter = tokens[srcOffset + 1];\r\n            var tokenEndCharacter = tokens[srcOffset + 2];\r\n            var tokenMetadata = tokens[srcOffset + 3];\r\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\r\n                // 1a. The token is completely before the deletion range\r\n                // => nothing to do\r\n                newTokenCount++;\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\r\n                // 1b, 1c, 1d\r\n                // => the token survives, but it needs to shrink\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 1d. The token starts before, the deletion range is inside the token\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 1b. The token starts before, the deletion range ends after the token\r\n                    // 1c. The token starts before, the deletion range ends precisely with the token\r\n                    // => the token shrinks its ending to the deletion start\r\n                    tokenEndCharacter = startCharacter;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\r\n                // 2a, 2b, 2c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 2c. The token starts at the same position, and ends after the deletion range\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 2a. The token starts at the same position, and ends inside the deletion range\r\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\r\n                // 3a, 3b, 3c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n                    // => the token moves left and shrinks\r\n                    if (tokenDeltaLine === startDeltaLine) {\r\n                        // the deletion started on the same line as the token\r\n                        // => the token moves left and shrinks\r\n                        tokenStartCharacter = startCharacter;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                    else {\r\n                        // the deletion started on a line above the token\r\n                        // => the token moves to the beginning of the line\r\n                        tokenStartCharacter = 0;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                }\r\n                else {\r\n                    // 3a. The token is inside the deletion range\r\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine > endDeltaLine) {\r\n                // 4. (partial) The token starts after the deletion range, on a line below...\r\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\r\n                    // early stop, there is no need to walk all the tokens and do nothing...\r\n                    newTokenCount = tokenCount;\r\n                    break;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n            }\r\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\r\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\r\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\r\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\r\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n                tokenStartCharacter -= (endCharacter - startCharacter);\r\n                tokenEndCharacter -= (endCharacter - startCharacter);\r\n            }\r\n            else {\r\n                throw new Error(\"Not possible!\");\r\n            }\r\n            var destOffset = 4 * newTokenCount;\r\n            tokens[destOffset] = tokenDeltaLine;\r\n            tokens[destOffset + 1] = tokenStartCharacter;\r\n            tokens[destOffset + 2] = tokenEndCharacter;\r\n            tokens[destOffset + 3] = tokenMetadata;\r\n            newTokenCount++;\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptInsertText = function (deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        // Here are the cases I used to think about this:\r\n        //\r\n        // 1. The token is completely before the insertion point\r\n        //            -----------   |\r\n        // 2. The token ends precisely at the insertion point\r\n        //            -----------|\r\n        // 3. The token contains the insertion point\r\n        //            -----|------\r\n        // 4. The token starts precisely at the insertion point\r\n        //            |-----------\r\n        // 5. The token is completely after the insertion point\r\n        //            |   -----------\r\n        //\r\n        var isInsertingPreciselyOneWordCharacter = (eolCount === 0\r\n            && firstLineLength === 1\r\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\r\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\r\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var offset = 4 * i;\r\n            var tokenDeltaLine = tokens[offset];\r\n            var tokenStartCharacter = tokens[offset + 1];\r\n            var tokenEndCharacter = tokens[offset + 2];\r\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\r\n                // 1. The token is completely before the insertion point\r\n                // => nothing to do\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\r\n                // 2. The token ends precisely at the insertion point\r\n                // => expand the end character only if inserting precisely one character that is a word character\r\n                if (isInsertingPreciselyOneWordCharacter) {\r\n                    tokenEndCharacter += 1;\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\r\n                // 3. The token contains the insertion point\r\n                if (eolCount === 0) {\r\n                    // => just expand the end character\r\n                    tokenEndCharacter += firstLineLength;\r\n                }\r\n                else {\r\n                    // => cut off the token\r\n                    tokenEndCharacter = character;\r\n                }\r\n            }\r\n            else {\r\n                // 4. or 5.\r\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\r\n                    // 4. The token starts precisely at the insertion point\r\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\r\n                    // => otherwise behave as in case 5.\r\n                    if (isInsertingPreciselyOneWordCharacter) {\r\n                        continue;\r\n                    }\r\n                }\r\n                // => the token must move and keep its size constant\r\n                if (tokenDeltaLine === deltaLine) {\r\n                    tokenDeltaLine += eolCount;\r\n                    // this token is on the line where the insertion is taking place\r\n                    if (eolCount === 0) {\r\n                        tokenStartCharacter += firstLineLength;\r\n                        tokenEndCharacter += firstLineLength;\r\n                    }\r\n                    else {\r\n                        var tokenLength = tokenEndCharacter - tokenStartCharacter;\r\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\r\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\r\n                    }\r\n                }\r\n                else {\r\n                    tokenDeltaLine += eolCount;\r\n                }\r\n            }\r\n            tokens[offset] = tokenDeltaLine;\r\n            tokens[offset + 1] = tokenStartCharacter;\r\n            tokens[offset + 2] = tokenEndCharacter;\r\n        }\r\n    };\r\n    return SparseEncodedTokens;\r\n}());\r\nexport { SparseEncodedTokens };\r\nvar LineTokens2 = /** @class */ (function () {\r\n    function LineTokens2(actual, startTokenIndex, endTokenIndex) {\r\n        this._actual = actual;\r\n        this._startTokenIndex = startTokenIndex;\r\n        this._endTokenIndex = endTokenIndex;\r\n    }\r\n    LineTokens2.prototype.getCount = function () {\r\n        return this._endTokenIndex - this._startTokenIndex + 1;\r\n    };\r\n    LineTokens2.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._actual.getStartCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._actual.getEndCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getMetadata = function (tokenIndex) {\r\n        return this._actual.getMetadata(this._startTokenIndex + tokenIndex);\r\n    };\r\n    return LineTokens2;\r\n}());\r\nexport { LineTokens2 };\r\nvar MultilineTokens2 = /** @class */ (function () {\r\n    function MultilineTokens2(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    MultilineTokens2.prototype._updateEndLineNumber = function () {\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    };\r\n    MultilineTokens2.prototype.getLineTokens = function (lineNumber) {\r\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\r\n            var findResult = MultilineTokens2._findTokensWithLine(this.tokens, lineNumber - this.startLineNumber);\r\n            if (findResult) {\r\n                var startTokenIndex = findResult[0], endTokenIndex = findResult[1];\r\n                return new LineTokens2(this.tokens, startTokenIndex, endTokenIndex);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2._findTokensWithLine = function (tokens, deltaLine) {\r\n        var low = 0;\r\n        var high = tokens.getTokenCount() - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            var midDeltaLine = tokens.getDeltaLine(mid);\r\n            if (midDeltaLine < deltaLine) {\r\n                low = mid + 1;\r\n            }\r\n            else if (midDeltaLine > deltaLine) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                var min = mid;\r\n                while (min > low && tokens.getDeltaLine(min - 1) === deltaLine) {\r\n                    min--;\r\n                }\r\n                var max = mid;\r\n                while (max < high && tokens.getDeltaLine(max + 1) === deltaLine) {\r\n                    max++;\r\n                }\r\n                return [min, max];\r\n            }\r\n        }\r\n        if (tokens.getDeltaLine(low) === deltaLine) {\r\n            return [low, low];\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2.prototype.applyEdit = function (range, text) {\r\n        var _a = countEOL(text), eolCount = _a[0], firstLineLength = _a[1], lastLineLength = _a[2];\r\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\r\n    };\r\n    MultilineTokens2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        this._updateEndLineNumber();\r\n    };\r\n    MultilineTokens2.prototype._acceptDeleteRange = function (range) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            // Nothing to delete\r\n            return;\r\n        }\r\n        var firstLineIndex = range.startLineNumber - this.startLineNumber;\r\n        var lastLineIndex = range.endLineNumber - this.startLineNumber;\r\n        if (lastLineIndex < 0) {\r\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\r\n            var deletedLinesCount = lastLineIndex - firstLineIndex;\r\n            this.startLineNumber -= deletedLinesCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion occurs entirely after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion completely encompasses this block\r\n            this.startLineNumber = 0;\r\n            this.tokens.clear();\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0) {\r\n            var deletedBefore = -firstLineIndex;\r\n            this.startLineNumber -= deletedBefore;\r\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\r\n        }\r\n        else {\r\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\r\n        }\r\n    };\r\n    MultilineTokens2.prototype._acceptInsertText = function (position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - this.startLineNumber;\r\n        if (lineIndex < 0) {\r\n            // this insertion occurs before this block, so we only need to adjust line numbers\r\n            this.startLineNumber += eolCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this insertion occurs after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n    };\r\n    return MultilineTokens2;\r\n}());\r\nexport { MultilineTokens2 };\r\nvar MultilineTokens = /** @class */ (function () {\r\n    function MultilineTokens(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n    }\r\n    return MultilineTokens;\r\n}());\r\nexport { MultilineTokens };\r\nfunction toUint32Array(arr) {\r\n    if (arr instanceof Uint32Array) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return new Uint32Array(arr);\r\n    }\r\n}\r\nvar TokensStore2 = /** @class */ (function () {\r\n    function TokensStore2() {\r\n        this._pieces = [];\r\n    }\r\n    TokensStore2.prototype.flush = function () {\r\n        this._pieces = [];\r\n    };\r\n    TokensStore2.prototype.set = function (pieces) {\r\n        this._pieces = pieces || [];\r\n    };\r\n    TokensStore2.prototype.addSemanticTokens = function (lineNumber, aTokens) {\r\n        var pieces = this._pieces;\r\n        if (pieces.length === 0) {\r\n            return aTokens;\r\n        }\r\n        var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\r\n        var bTokens = this._pieces[pieceIndex].getLineTokens(lineNumber);\r\n        if (!bTokens) {\r\n            return aTokens;\r\n        }\r\n        var aLen = aTokens.getCount();\r\n        var bLen = bTokens.getCount();\r\n        var aIndex = 0;\r\n        var result = [], resultLen = 0;\r\n        for (var bIndex = 0; bIndex < bLen; bIndex++) {\r\n            var bStartCharacter = bTokens.getStartCharacter(bIndex);\r\n            var bEndCharacter = bTokens.getEndCharacter(bIndex);\r\n            var bMetadata = bTokens.getMetadata(bIndex);\r\n            var bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\r\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\r\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\r\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\r\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\r\n            var aMask = (~bMask) >>> 0;\r\n            // push any token from `a` that is before `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n                aIndex++;\r\n            }\r\n            // push the token from `a` if it intersects the token from `b`\r\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\r\n                result[resultLen++] = bStartCharacter;\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            }\r\n            // skip any tokens from `a` that are contained inside `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            if (aIndex < aLen && aTokens.getEndOffset(aIndex) === bEndCharacter) {\r\n                // `a` ends exactly at the same spot as `b`!\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            else {\r\n                var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\r\n                // push the token from `b`\r\n                result[resultLen++] = bEndCharacter;\r\n                result[resultLen++] = (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask);\r\n            }\r\n        }\r\n        // push the remaining tokens from `a`\r\n        while (aIndex < aLen) {\r\n            result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n            result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            aIndex++;\r\n        }\r\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\r\n    };\r\n    TokensStore2._findFirstPieceWithLine = function (pieces, lineNumber) {\r\n        var low = 0;\r\n        var high = pieces.length - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            if (pieces[mid].endLineNumber < lineNumber) {\r\n                low = mid + 1;\r\n            }\r\n            else if (pieces[mid].startLineNumber > lineNumber) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\r\n                    mid--;\r\n                }\r\n                return mid;\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n    //#region Editing\r\n    TokensStore2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        for (var _i = 0, _a = this._pieces; _i < _a.length; _i++) {\r\n            var piece = _a[_i];\r\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        }\r\n    };\r\n    return TokensStore2;\r\n}());\r\nexport { TokensStore2 };\r\nvar TokensStore = /** @class */ (function () {\r\n    function TokensStore() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    TokensStore.prototype.flush = function () {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    };\r\n    TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\r\n        var rawLineTokens = null;\r\n        if (lineIndex < this._len) {\r\n            rawLineTokens = this._lineTokens[lineIndex];\r\n        }\r\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\r\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\r\n        }\r\n        var lineTokens = new Uint32Array(2);\r\n        lineTokens[0] = lineText.length;\r\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n        return new LineTokens(lineTokens, lineText);\r\n    };\r\n    TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\r\n        var tokens = _tokens ? toUint32Array(_tokens) : null;\r\n        if (lineTextLength === 0) {\r\n            var hasDifferentLanguageId = false;\r\n            if (tokens && tokens.length > 1) {\r\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\r\n            }\r\n            if (!hasDifferentLanguageId) {\r\n                return EMPTY_LINE_TOKENS;\r\n            }\r\n        }\r\n        if (!tokens || tokens.length === 0) {\r\n            var tokens_1 = new Uint32Array(2);\r\n            tokens_1[0] = lineTextLength;\r\n            tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\r\n            return tokens_1.buffer;\r\n        }\r\n        // Ensure the last token covers the end of the text\r\n        tokens[tokens.length - 2] = lineTextLength;\r\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\r\n            // Store directly the ArrayBuffer pointer to save an object\r\n            return tokens.buffer;\r\n        }\r\n        return tokens;\r\n    };\r\n    TokensStore.prototype._ensureLine = function (lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._lineTokens[this._len] = null;\r\n            this._len++;\r\n        }\r\n    };\r\n    TokensStore.prototype._deleteLines = function (start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._lineTokens.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    };\r\n    TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        var lineTokens = [];\r\n        for (var i = 0; i < insertCount; i++) {\r\n            lineTokens[i] = null;\r\n        }\r\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\r\n        this._len += insertCount;\r\n    };\r\n    TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\r\n        var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\r\n        this._ensureLine(lineIndex);\r\n        this._lineTokens[lineIndex] = tokens;\r\n    };\r\n    //#region Editing\r\n    TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\r\n    };\r\n    TokensStore.prototype._acceptDeleteRange = function (range) {\r\n        var firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\r\n            return;\r\n        }\r\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\r\n        var lastLineIndex = range.endLineNumber - 1;\r\n        var lastLineTokens = null;\r\n        if (lastLineIndex < this._len) {\r\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\r\n        // Delete middle lines\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    };\r\n    TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (eolCount === 0) {\r\n            // Inserting text on one line\r\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n            return;\r\n        }\r\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\r\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    };\r\n    TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        return TokensStore._delete(lineTokens, 0, toChIndex);\r\n    };\r\n    TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var lineTextLength = tokens[tokens.length - 2];\r\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\r\n    };\r\n    TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        // special case: deleting everything\r\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\r\n            return EMPTY_LINE_TOKENS;\r\n        }\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\r\n        var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\r\n        var fromTokenEndOffset = tokens[fromTokenIndex << 1];\r\n        if (toChIndex < fromTokenEndOffset) {\r\n            // the delete range is inside a single token\r\n            var delta_1 = (toChIndex - fromChIndex);\r\n            for (var i = fromTokenIndex; i < tokensCount; i++) {\r\n                tokens[i << 1] -= delta_1;\r\n            }\r\n            return lineTokens;\r\n        }\r\n        var dest;\r\n        var lastEnd;\r\n        if (fromTokenStartOffset !== fromChIndex) {\r\n            tokens[fromTokenIndex << 1] = fromChIndex;\r\n            dest = ((fromTokenIndex + 1) << 1);\r\n            lastEnd = fromChIndex;\r\n        }\r\n        else {\r\n            dest = (fromTokenIndex << 1);\r\n            lastEnd = fromTokenStartOffset;\r\n        }\r\n        var delta = (toChIndex - fromChIndex);\r\n        for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\r\n            var tokenEndOffset = tokens[tokenIndex << 1] - delta;\r\n            if (tokenEndOffset > lastEnd) {\r\n                tokens[dest++] = tokenEndOffset;\r\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\r\n                lastEnd = tokenEndOffset;\r\n            }\r\n        }\r\n        if (dest === tokens.length) {\r\n            // nothing to trim\r\n            return lineTokens;\r\n        }\r\n        var tmp = new Uint32Array(dest);\r\n        tmp.set(tokens.subarray(0, dest), 0);\r\n        return tmp.buffer;\r\n    };\r\n    TokensStore._append = function (lineTokens, _otherTokens) {\r\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        if (lineTokens === EMPTY_LINE_TOKENS) {\r\n            return _otherTokens;\r\n        }\r\n        if (lineTokens === null) {\r\n            return lineTokens;\r\n        }\r\n        if (_otherTokens === null) {\r\n            // cannot determine combined line length...\r\n            return null;\r\n        }\r\n        var myTokens = toUint32Array(lineTokens);\r\n        var otherTokens = toUint32Array(_otherTokens);\r\n        var otherTokensCount = (otherTokens.length >>> 1);\r\n        var result = new Uint32Array(myTokens.length + otherTokens.length);\r\n        result.set(myTokens, 0);\r\n        var dest = myTokens.length;\r\n        var delta = myTokens[myTokens.length - 2];\r\n        for (var i = 0; i < otherTokensCount; i++) {\r\n            result[dest++] = otherTokens[(i << 1)] + delta;\r\n            result[dest++] = otherTokens[(i << 1) + 1];\r\n        }\r\n        return result.buffer;\r\n    };\r\n    TokensStore._insert = function (lineTokens, chIndex, textLength) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            // nothing to do\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\r\n        if (fromTokenIndex > 0) {\r\n            var fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\r\n            if (fromTokenStartOffset === chIndex) {\r\n                fromTokenIndex--;\r\n            }\r\n        }\r\n        for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\r\n            tokens[tokenIndex << 1] += textLength;\r\n        }\r\n        return lineTokens;\r\n    };\r\n    return TokensStore;\r\n}());\r\nexport { TokensStore };\r\n"]},"metadata":{},"sourceType":"module"}