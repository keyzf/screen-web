{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar Lazy =\n/** @class */\nfunction () {\n  function Lazy(executor) {\n    this.executor = executor;\n    this._didRun = false;\n  }\n  /**\r\n   * Get the wrapped value.\r\n   *\r\n   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\r\n   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\r\n   */\n\n\n  Lazy.prototype.getValue = function () {\n    if (!this._didRun) {\n      try {\n        this._value = this.executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    }\n\n    if (this._error) {\n      throw this._error;\n    }\n\n    return this._value;\n  };\n\n  Object.defineProperty(Lazy.prototype, \"rawValue\", {\n    /**\r\n     * Get the wrapped value without forcing evaluation.\r\n     */\n    get: function () {\n      return this._value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Lazy;\n}();\n\nexport { Lazy };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/lazy.js"],"names":["Lazy","executor","_didRun","prototype","getValue","_value","err","_error","Object","defineProperty","get","enumerable","configurable"],"mappings":"AAAA;;;;AAIA,IAAIA,IAAI;AAAG;AAAe,YAAY;AAClC,WAASA,IAAT,CAAcC,QAAd,EAAwB;AACpB,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKC,OAAL,GAAe,KAAf;AACH;AACD;;;;;;;;AAMAF,EAAAA,IAAI,CAACG,SAAL,CAAeC,QAAf,GAA0B,YAAY;AAClC,QAAI,CAAC,KAAKF,OAAV,EAAmB;AACf,UAAI;AACA,aAAKG,MAAL,GAAc,KAAKJ,QAAL,EAAd;AACH,OAFD,CAGA,OAAOK,GAAP,EAAY;AACR,aAAKC,MAAL,GAAcD,GAAd;AACH,OALD,SAMQ;AACJ,aAAKJ,OAAL,GAAe,IAAf;AACH;AACJ;;AACD,QAAI,KAAKK,MAAT,EAAiB;AACb,YAAM,KAAKA,MAAX;AACH;;AACD,WAAO,KAAKF,MAAZ;AACH,GAhBD;;AAiBAG,EAAAA,MAAM,CAACC,cAAP,CAAsBT,IAAI,CAACG,SAA3B,EAAsC,UAAtC,EAAkD;AAC9C;;;AAGAO,IAAAA,GAAG,EAAE,YAAY;AAAE,aAAO,KAAKL,MAAZ;AAAqB,KAJM;AAK9CM,IAAAA,UAAU,EAAE,IALkC;AAM9CC,IAAAA,YAAY,EAAE;AANgC,GAAlD;AAQA,SAAOZ,IAAP;AACH,CArCyB,EAA1B;;AAsCA,SAASA,IAAT","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar Lazy = /** @class */ (function () {\r\n    function Lazy(executor) {\r\n        this.executor = executor;\r\n        this._didRun = false;\r\n    }\r\n    /**\r\n     * Get the wrapped value.\r\n     *\r\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\r\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\r\n     */\r\n    Lazy.prototype.getValue = function () {\r\n        if (!this._didRun) {\r\n            try {\r\n                this._value = this.executor();\r\n            }\r\n            catch (err) {\r\n                this._error = err;\r\n            }\r\n            finally {\r\n                this._didRun = true;\r\n            }\r\n        }\r\n        if (this._error) {\r\n            throw this._error;\r\n        }\r\n        return this._value;\r\n    };\r\n    Object.defineProperty(Lazy.prototype, \"rawValue\", {\r\n        /**\r\n         * Get the wrapped value without forcing evaluation.\r\n         */\r\n        get: function () { return this._value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Lazy;\r\n}());\r\nexport { Lazy };\r\n"]},"metadata":{},"sourceType":"module"}