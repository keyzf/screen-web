{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../controller/cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nvar repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n\n  var cache = repeatCache[str];\n\n  for (var i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n\n  return cache[count];\n}\n\nvar ShiftCommand =\n/** @class */\nfunction () {\n  function ShiftCommand(range, opts) {\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n\n  ShiftCommand.unshiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      var indent = cachedStringRepeat(' ', indentSize);\n      var desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n      var indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      var indent = '\\t';\n      var desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n      var indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  };\n\n  ShiftCommand.shiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      var indent = cachedStringRepeat(' ', indentSize);\n      var desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n      var indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      var indent = '\\t';\n      var desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n      var indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  };\n\n  ShiftCommand.prototype._addEditOperation = function (builder, range, text) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      builder.addTrackedEditOperation(range, text);\n    } else {\n      builder.addEditOperation(range, text);\n    }\n  };\n\n  ShiftCommand.prototype.getEditOperations = function (model, builder) {\n    var startLine = this._selection.startLineNumber;\n    var endLine = this._selection.endLineNumber;\n\n    if (this._selection.endColumn === 1 && startLine !== endLine) {\n      endLine = endLine - 1;\n    }\n\n    var _a = this._opts,\n        tabSize = _a.tabSize,\n        indentSize = _a.indentSize,\n        insertSpaces = _a.insertSpaces;\n    var shouldIndentEmptyLines = startLine === endLine; // if indenting or outdenting on a whitespace only line\n\n    if (this._selection.isEmpty()) {\n      if (/^\\s*$/.test(model.getLineContent(startLine))) {\n        this._useLastEditRangeForCursorEndPosition = true;\n      }\n    }\n\n    if (this._opts.useTabStops) {\n      // keep track of previous line's \"miss-alignment\"\n      var previousLineExtraSpaces = 0,\n          extraSpaces = 0;\n\n      for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n        extraSpaces = 0;\n        var lineText = model.getLineContent(lineNumber);\n        var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (lineNumber > 1) {\n          var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\n          if (contentStartVisibleColumn % indentSize !== 0) {\n            // The current line is \"miss-aligned\", so let's see if this is expected...\n            // This can only happen when it has trailing commas in the indent\n            if (model.isCheapToTokenize(lineNumber - 1)) {\n              var enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n\n              if (enterAction) {\n                extraSpaces = previousLineExtraSpaces;\n\n                if (enterAction.appendText) {\n                  for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                    if (enterAction.appendText.charCodeAt(j) === 32\n                    /* Space */\n                    ) {\n                        extraSpaces++;\n                      } else {\n                      break;\n                    }\n                  }\n                }\n\n                if (enterAction.removeText) {\n                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                } // Act as if `prefixSpaces` is not part of the indentation\n\n\n                for (var j = 0; j < extraSpaces; j++) {\n                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32\n                  /* Space */\n                  ) {\n                      break;\n                    }\n\n                  indentationEndIndex--;\n                }\n              }\n            }\n          }\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        var desiredIndent = void 0;\n\n        if (this._opts.isUnshift) {\n          desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        } else {\n          desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        }\n\n        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\n        if (lineNumber === startLine && !this._selection.isEmpty()) {\n          // Force the startColumn to stay put because we're inserting after it\n          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n        }\n      }\n    } else {\n      var oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n\n      for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n        var lineText = model.getLineContent(lineNumber);\n        var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (this._opts.isUnshift) {\n          indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n\n          for (var i = 0; i < indentationEndIndex; i++) {\n            var chr = lineText.charCodeAt(i);\n\n            if (chr === 9\n            /* Tab */\n            ) {\n                indentationEndIndex = i + 1;\n                break;\n              }\n          }\n\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n        } else {\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n          }\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(this._selection);\n  };\n\n  ShiftCommand.prototype.computeCursorState = function (model, helper) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      var lastOp = helper.getInverseEditOperations()[0];\n      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n    }\n\n    var result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._selectionStartColumnStaysPut) {\n      // The selection start should not move\n      var initialStartColumn = this._selection.startColumn;\n      var resultStartColumn = result.startColumn;\n\n      if (resultStartColumn <= initialStartColumn) {\n        return result;\n      }\n\n      if (result.getDirection() === 0\n      /* LTR */\n      ) {\n          return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n        }\n\n      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n    }\n\n    return result;\n  };\n\n  return ShiftCommand;\n}();\n\nexport { ShiftCommand };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"names":["strings","CursorColumns","Range","Selection","LanguageConfigurationRegistry","repeatCache","Object","create","cachedStringRepeat","str","count","cache","i","length","ShiftCommand","range","opts","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","unshiftIndent","line","column","tabSize","indentSize","insertSpaces","contentStartVisibleColumn","visibleColumnFromColumn","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","shiftIndent","nextIndentTabStop","nextRenderTabStop","prototype","_addEditOperation","builder","text","addTrackedEditOperation","addEditOperation","getEditOperations","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","_a","shouldIndentEmptyLines","isEmpty","test","getLineContent","useTabStops","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","isCheapToTokenize","enterAction","getEnterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","startColumn","oneIndent","min","chr","trackSelection","computeCursorState","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CursorColumns } from '../controller/cursorCommon.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nvar repeatCache = Object.create(null);\r\nexport function cachedStringRepeat(str, count) {\r\n    if (!repeatCache[str]) {\r\n        repeatCache[str] = ['', str];\r\n    }\r\n    var cache = repeatCache[str];\r\n    for (var i = cache.length; i <= count; i++) {\r\n        cache[i] = cache[i - 1] + str;\r\n    }\r\n    return cache[count];\r\n}\r\nvar ShiftCommand = /** @class */ (function () {\r\n    function ShiftCommand(range, opts) {\r\n        this._opts = opts;\r\n        this._selection = range;\r\n        this._selectionId = null;\r\n        this._useLastEditRangeForCursorEndPosition = false;\r\n        this._selectionStartColumnStaysPut = false;\r\n    }\r\n    ShiftCommand.unshiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            var indent = cachedStringRepeat(' ', indentSize);\r\n            var desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            var indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            var indent = '\\t';\r\n            var desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            var indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    };\r\n    ShiftCommand.shiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            var indent = cachedStringRepeat(' ', indentSize);\r\n            var desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            var indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            var indent = '\\t';\r\n            var desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            var indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    };\r\n    ShiftCommand.prototype._addEditOperation = function (builder, range, text) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            builder.addTrackedEditOperation(range, text);\r\n        }\r\n        else {\r\n            builder.addEditOperation(range, text);\r\n        }\r\n    };\r\n    ShiftCommand.prototype.getEditOperations = function (model, builder) {\r\n        var startLine = this._selection.startLineNumber;\r\n        var endLine = this._selection.endLineNumber;\r\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\r\n            endLine = endLine - 1;\r\n        }\r\n        var _a = this._opts, tabSize = _a.tabSize, indentSize = _a.indentSize, insertSpaces = _a.insertSpaces;\r\n        var shouldIndentEmptyLines = (startLine === endLine);\r\n        // if indenting or outdenting on a whitespace only line\r\n        if (this._selection.isEmpty()) {\r\n            if (/^\\s*$/.test(model.getLineContent(startLine))) {\r\n                this._useLastEditRangeForCursorEndPosition = true;\r\n            }\r\n        }\r\n        if (this._opts.useTabStops) {\r\n            // keep track of previous line's \"miss-alignment\"\r\n            var previousLineExtraSpaces = 0, extraSpaces = 0;\r\n            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\r\n                extraSpaces = 0;\r\n                var lineText = model.getLineContent(lineNumber);\r\n                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (lineNumber > 1) {\r\n                    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\r\n                    if (contentStartVisibleColumn % indentSize !== 0) {\r\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\r\n                        // This can only happen when it has trailing commas in the indent\r\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\r\n                            var enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\r\n                            if (enterAction) {\r\n                                extraSpaces = previousLineExtraSpaces;\r\n                                if (enterAction.appendText) {\r\n                                    for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\r\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\r\n                                            extraSpaces++;\r\n                                        }\r\n                                        else {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (enterAction.removeText) {\r\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\r\n                                }\r\n                                // Act as if `prefixSpaces` is not part of the indentation\r\n                                for (var j = 0; j < extraSpaces; j++) {\r\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\r\n                                        break;\r\n                                    }\r\n                                    indentationEndIndex--;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                var desiredIndent = void 0;\r\n                if (this._opts.isUnshift) {\r\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                else {\r\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\r\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                    // Force the startColumn to stay put because we're inserting after it\r\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\r\n            for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\r\n                var lineText = model.getLineContent(lineNumber);\r\n                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (this._opts.isUnshift) {\r\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\r\n                    for (var i = 0; i < indentationEndIndex; i++) {\r\n                        var chr = lineText.charCodeAt(i);\r\n                        if (chr === 9 /* Tab */) {\r\n                            indentationEndIndex = i + 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\r\n                }\r\n                else {\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\r\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                        // Force the startColumn to stay put because we're inserting after it\r\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(this._selection);\r\n    };\r\n    ShiftCommand.prototype.computeCursorState = function (model, helper) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            var lastOp = helper.getInverseEditOperations()[0];\r\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\r\n        }\r\n        var result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._selectionStartColumnStaysPut) {\r\n            // The selection start should not move\r\n            var initialStartColumn = this._selection.startColumn;\r\n            var resultStartColumn = result.startColumn;\r\n            if (resultStartColumn <= initialStartColumn) {\r\n                return result;\r\n            }\r\n            if (result.getDirection() === 0 /* LTR */) {\r\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\r\n            }\r\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\r\n        }\r\n        return result;\r\n    };\r\n    return ShiftCommand;\r\n}());\r\nexport { ShiftCommand };\r\n"]},"metadata":{},"sourceType":"module"}