{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n\n/**\r\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\r\n */\nvar MINIMUM_SLIDER_SIZE = 20;\n\nvar ScrollbarState =\n/** @class */\nfunction () {\n  function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n    this._scrollbarSize = Math.round(scrollbarSize);\n    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    this._arrowSize = Math.round(arrowSize);\n    this._visibleSize = visibleSize;\n    this._scrollSize = scrollSize;\n    this._scrollPosition = scrollPosition;\n    this._computedAvailableSize = 0;\n    this._computedIsNeeded = false;\n    this._computedSliderSize = 0;\n    this._computedSliderRatio = 0;\n    this._computedSliderPosition = 0;\n\n    this._refreshComputedValues();\n  }\n\n  ScrollbarState.prototype.clone = function () {\n    return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n  };\n\n  ScrollbarState.prototype.setVisibleSize = function (visibleSize) {\n    var iVisibleSize = Math.round(visibleSize);\n\n    if (this._visibleSize !== iVisibleSize) {\n      this._visibleSize = iVisibleSize;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ScrollbarState.prototype.setScrollSize = function (scrollSize) {\n    var iScrollSize = Math.round(scrollSize);\n\n    if (this._scrollSize !== iScrollSize) {\n      this._scrollSize = iScrollSize;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {\n    var iScrollPosition = Math.round(scrollPosition);\n\n    if (this._scrollPosition !== iScrollPosition) {\n      this._scrollPosition = iScrollPosition;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ScrollbarState._computeValues = function (oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n    var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n    var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n    var computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;\n\n    if (!computedIsNeeded) {\n      // There is no need for a slider\n      return {\n        computedAvailableSize: Math.round(computedAvailableSize),\n        computedIsNeeded: computedIsNeeded,\n        computedSliderSize: Math.round(computedRepresentableSize),\n        computedSliderRatio: 0,\n        computedSliderPosition: 0\n      };\n    } // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\n\n    var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize))); // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n    // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\n    var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n    var computedSliderPosition = scrollPosition * computedSliderRatio;\n    return {\n      computedAvailableSize: Math.round(computedAvailableSize),\n      computedIsNeeded: computedIsNeeded,\n      computedSliderSize: Math.round(computedSliderSize),\n      computedSliderRatio: computedSliderRatio,\n      computedSliderPosition: Math.round(computedSliderPosition)\n    };\n  };\n\n  ScrollbarState.prototype._refreshComputedValues = function () {\n    var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\n    this._computedAvailableSize = r.computedAvailableSize;\n    this._computedIsNeeded = r.computedIsNeeded;\n    this._computedSliderSize = r.computedSliderSize;\n    this._computedSliderRatio = r.computedSliderRatio;\n    this._computedSliderPosition = r.computedSliderPosition;\n  };\n\n  ScrollbarState.prototype.getArrowSize = function () {\n    return this._arrowSize;\n  };\n\n  ScrollbarState.prototype.getScrollPosition = function () {\n    return this._scrollPosition;\n  };\n\n  ScrollbarState.prototype.getRectangleLargeSize = function () {\n    return this._computedAvailableSize;\n  };\n\n  ScrollbarState.prototype.getRectangleSmallSize = function () {\n    return this._scrollbarSize;\n  };\n\n  ScrollbarState.prototype.isNeeded = function () {\n    return this._computedIsNeeded;\n  };\n\n  ScrollbarState.prototype.getSliderSize = function () {\n    return this._computedSliderSize;\n  };\n\n  ScrollbarState.prototype.getSliderPosition = function () {\n    return this._computedSliderPosition;\n  };\n  /**\r\n   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\r\n   * `offset` is based on the same coordinate system as the `sliderPosition`.\r\n   */\n\n\n  ScrollbarState.prototype.getDesiredScrollPositionFromOffset = function (offset) {\n    if (!this._computedIsNeeded) {\n      // no need for a slider\n      return 0;\n    }\n\n    var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n    return Math.round(desiredSliderPosition / this._computedSliderRatio);\n  };\n  /**\r\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n   */\n\n\n  ScrollbarState.prototype.getDesiredScrollPositionFromDelta = function (delta) {\n    if (!this._computedIsNeeded) {\n      // no need for a slider\n      return 0;\n    }\n\n    var desiredSliderPosition = this._computedSliderPosition + delta;\n    return Math.round(desiredSliderPosition / this._computedSliderRatio);\n  };\n\n  return ScrollbarState;\n}();\n\nexport { ScrollbarState };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js"],"names":["MINIMUM_SLIDER_SIZE","ScrollbarState","arrowSize","scrollbarSize","oppositeScrollbarSize","visibleSize","scrollSize","scrollPosition","_scrollbarSize","Math","round","_oppositeScrollbarSize","_arrowSize","_visibleSize","_scrollSize","_scrollPosition","_computedAvailableSize","_computedIsNeeded","_computedSliderSize","_computedSliderRatio","_computedSliderPosition","_refreshComputedValues","prototype","clone","setVisibleSize","iVisibleSize","setScrollSize","iScrollSize","setScrollPosition","iScrollPosition","_computeValues","computedAvailableSize","max","computedRepresentableSize","computedIsNeeded","computedSliderSize","computedSliderRatio","computedSliderPosition","floor","r","getArrowSize","getScrollPosition","getRectangleLargeSize","getRectangleSmallSize","isNeeded","getSliderSize","getSliderPosition","getDesiredScrollPositionFromOffset","offset","desiredSliderPosition","getDesiredScrollPositionFromDelta","delta"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\r\n */\r\nvar MINIMUM_SLIDER_SIZE = 20;\r\nvar ScrollbarState = /** @class */ (function () {\r\n    function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\r\n        this._scrollbarSize = Math.round(scrollbarSize);\r\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\r\n        this._arrowSize = Math.round(arrowSize);\r\n        this._visibleSize = visibleSize;\r\n        this._scrollSize = scrollSize;\r\n        this._scrollPosition = scrollPosition;\r\n        this._computedAvailableSize = 0;\r\n        this._computedIsNeeded = false;\r\n        this._computedSliderSize = 0;\r\n        this._computedSliderRatio = 0;\r\n        this._computedSliderPosition = 0;\r\n        this._refreshComputedValues();\r\n    }\r\n    ScrollbarState.prototype.clone = function () {\r\n        return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\r\n    };\r\n    ScrollbarState.prototype.setVisibleSize = function (visibleSize) {\r\n        var iVisibleSize = Math.round(visibleSize);\r\n        if (this._visibleSize !== iVisibleSize) {\r\n            this._visibleSize = iVisibleSize;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ScrollbarState.prototype.setScrollSize = function (scrollSize) {\r\n        var iScrollSize = Math.round(scrollSize);\r\n        if (this._scrollSize !== iScrollSize) {\r\n            this._scrollSize = iScrollSize;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {\r\n        var iScrollPosition = Math.round(scrollPosition);\r\n        if (this._scrollPosition !== iScrollPosition) {\r\n            this._scrollPosition = iScrollPosition;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ScrollbarState._computeValues = function (oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\r\n        var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\r\n        var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\r\n        var computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\r\n        if (!computedIsNeeded) {\r\n            // There is no need for a slider\r\n            return {\r\n                computedAvailableSize: Math.round(computedAvailableSize),\r\n                computedIsNeeded: computedIsNeeded,\r\n                computedSliderSize: Math.round(computedRepresentableSize),\r\n                computedSliderRatio: 0,\r\n                computedSliderPosition: 0,\r\n            };\r\n        }\r\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\r\n        var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\r\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\r\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\r\n        var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\r\n        var computedSliderPosition = (scrollPosition * computedSliderRatio);\r\n        return {\r\n            computedAvailableSize: Math.round(computedAvailableSize),\r\n            computedIsNeeded: computedIsNeeded,\r\n            computedSliderSize: Math.round(computedSliderSize),\r\n            computedSliderRatio: computedSliderRatio,\r\n            computedSliderPosition: Math.round(computedSliderPosition),\r\n        };\r\n    };\r\n    ScrollbarState.prototype._refreshComputedValues = function () {\r\n        var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\r\n        this._computedAvailableSize = r.computedAvailableSize;\r\n        this._computedIsNeeded = r.computedIsNeeded;\r\n        this._computedSliderSize = r.computedSliderSize;\r\n        this._computedSliderRatio = r.computedSliderRatio;\r\n        this._computedSliderPosition = r.computedSliderPosition;\r\n    };\r\n    ScrollbarState.prototype.getArrowSize = function () {\r\n        return this._arrowSize;\r\n    };\r\n    ScrollbarState.prototype.getScrollPosition = function () {\r\n        return this._scrollPosition;\r\n    };\r\n    ScrollbarState.prototype.getRectangleLargeSize = function () {\r\n        return this._computedAvailableSize;\r\n    };\r\n    ScrollbarState.prototype.getRectangleSmallSize = function () {\r\n        return this._scrollbarSize;\r\n    };\r\n    ScrollbarState.prototype.isNeeded = function () {\r\n        return this._computedIsNeeded;\r\n    };\r\n    ScrollbarState.prototype.getSliderSize = function () {\r\n        return this._computedSliderSize;\r\n    };\r\n    ScrollbarState.prototype.getSliderPosition = function () {\r\n        return this._computedSliderPosition;\r\n    };\r\n    /**\r\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\r\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\r\n     */\r\n    ScrollbarState.prototype.getDesiredScrollPositionFromOffset = function (offset) {\r\n        if (!this._computedIsNeeded) {\r\n            // no need for a slider\r\n            return 0;\r\n        }\r\n        var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\r\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\r\n    };\r\n    /**\r\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n     */\r\n    ScrollbarState.prototype.getDesiredScrollPositionFromDelta = function (delta) {\r\n        if (!this._computedIsNeeded) {\r\n            // no need for a slider\r\n            return 0;\r\n        }\r\n        var desiredSliderPosition = this._computedSliderPosition + delta;\r\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\r\n    };\r\n    return ScrollbarState;\r\n}());\r\nexport { ScrollbarState };\r\n"]},"metadata":{},"sourceType":"module"}