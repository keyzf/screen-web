{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js'; // Combined filters\n\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\n\nexport function or() {\n  var filter = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    filter[_i] = arguments[_i];\n  }\n\n  return function (word, wordToMatchAgainst) {\n    for (var i = 0, len = filter.length; i < len; i++) {\n      var match = filter[i](word, wordToMatchAgainst);\n\n      if (match) {\n        return match;\n      }\n    }\n\n    return null;\n  };\n}\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n\n  var matches;\n\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n\n  if (!matches) {\n    return null;\n  }\n\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n} // Contiguous Substring\n\n\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\n  if (index === -1) {\n    return null;\n  }\n\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n} // Substring\n\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      var result = null;\n\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n\n      return null;\n    }\n\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n} // CamelCase\n\n\nfunction isLower(code) {\n  return 97\n  /* a */\n  <= code && code <= 122\n  /* z */\n  ;\n}\n\nexport function isUpper(code) {\n  return 65\n  /* A */\n  <= code && code <= 90\n  /* Z */\n  ;\n}\n\nfunction isNumber(code) {\n  return 48\n  /* Digit0 */\n  <= code && code <= 57\n  /* Digit9 */\n  ;\n}\n\nfunction isWhitespace(code) {\n  return code === 32\n  /* Space */\n  || code === 9\n  /* Tab */\n  || code === 10\n  /* LineFeed */\n  || code === 13\n  /* CarriageReturn */\n  ;\n}\n\nvar wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'.split('').forEach(function (s) {\n  return wordSeparators.add(s.charCodeAt(0));\n});\n\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n\n  return tail;\n}\n\nfunction nextAnchor(camelCaseWord, start) {\n  for (var i = start; i < camelCaseWord.length; i++) {\n    var c = camelCaseWord.charCodeAt(i);\n\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    var result = null;\n    var nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\n\n\nfunction analyzeCamelCaseWord(word) {\n  var upper = 0,\n      lower = 0,\n      alpha = 0,\n      numeric = 0,\n      code = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n\n  var upperPercent = upper / word.length;\n  var lowerPercent = lower / word.length;\n  var alphaPercent = alpha / word.length;\n  var numericPercent = numeric / word.length;\n  return {\n    upperPercent: upperPercent,\n    lowerPercent: lowerPercent,\n    alphaPercent: alphaPercent,\n    numericPercent: numericPercent\n  };\n}\n\nfunction isUpperCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent,\n      alphaPercent = analysis.alphaPercent,\n      numericPercent = analysis.numericPercent;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\n\n\nfunction isCamelCasePattern(word) {\n  var upper = 0,\n      lower = 0,\n      code = 0,\n      whitespace = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\n\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n\n  camelCaseWord = camelCaseWord.trim();\n\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n\n  var analysis = analyzeCamelCaseWord(camelCaseWord);\n\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n\n  return result;\n} // Fuzzy\n\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\n  if (enableSeparateSubstringMatching === void 0) {\n    enableSeparateSubstringMatching = false;\n  }\n\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  } // Form RegExp for wildcard matches\n\n\n  var regexp = fuzzyRegExpCache.get(word);\n\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  } // RegExp Filter\n\n\n  var match = regexp.exec(wordToMatchAgainst);\n\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  } // Default Filter\n\n\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n  var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n\n  if (result) {\n    return result;\n  }\n\n  var matches = 0;\n  var score = 0;\n  var idx = _wordPos;\n\n  for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n    var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n\n    if (wordPos >= 0) {\n      score += 1;\n      matches += Math.pow(2, wordPos);\n      idx = wordPos + 1;\n    } else if (matches !== 0) {\n      // once we have started matching things\n      // we need to match the remaining pattern\n      // characters\n      break;\n    }\n  }\n\n  return [score, matches, _wordPos];\n} //#region --- fuzzyScore ---\n\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n\n  var matches = score[1].toString(2);\n  var wordStart = score[2];\n  var res = [];\n\n  for (var pos = wordStart; pos < _maxLen; pos++) {\n    if (matches[matches.length - (pos + 1)] === '1') {\n      var last = res[res.length - 1];\n\n      if (last && last.end === pos) {\n        last.end = pos + 1;\n      } else {\n        res.push({\n          start: pos,\n          end: pos + 1\n        });\n      }\n    }\n  }\n\n  return res;\n}\nvar _maxLen = 128;\n\nfunction initTable() {\n  var table = [];\n  var row = [0];\n\n  for (var i = 1; i <= _maxLen; i++) {\n    row.push(-i);\n  }\n\n  for (var i = 0; i <= _maxLen; i++) {\n    var thisRow = row.slice(0);\n    thisRow[0] = -i;\n    table.push(thisRow);\n  }\n\n  return table;\n}\n\nvar _table = initTable();\n\nvar _scores = initTable();\n\nvar _arrows = initTable();\n\nvar _debug = false;\n\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, pad) {\n    if (pad === void 0) {\n      pad = ' ';\n    }\n\n    while (s.length < n) {\n      s = pad + s;\n    }\n\n    return s;\n  }\n\n  var ret = \" |   |\" + word.split('').map(function (c) {\n    return pad(c, 3);\n  }).join('|') + \"\\n\";\n\n  for (var i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += pattern[i - 1] + \"|\";\n    }\n\n    ret += table[i].slice(0, wordLen + 1).map(function (n) {\n      return pad(n.toString(), 3);\n    }).join('|') + '\\n';\n  }\n\n  return ret;\n}\n\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_scores, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.charCodeAt(index);\n\n  switch (code) {\n    case 95\n    /* Underline */\n    :\n    case 45\n    /* Dash */\n    :\n    case 46\n    /* Period */\n    :\n    case 32\n    /* Space */\n    :\n    case 47\n    /* Slash */\n    :\n    case 92\n    /* Backslash */\n    :\n    case 39\n    /* SingleQuote */\n    :\n    case 34\n    /* DoubleQuote */\n    :\n    case 58\n    /* Colon */\n    :\n    case 36\n    /* DollarSign */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.charCodeAt(index);\n\n  switch (code) {\n    case 32\n    /* Space */\n    :\n    case 9\n    /* Tab */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      patternPos += 1;\n    }\n\n    wordPos += 1;\n  }\n\n  return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n\n(function (FuzzyScore) {\n  /**\r\n   * No matches and value `-100`\r\n   */\n  FuzzyScore.Default = Object.freeze([-100, 0, 0]);\n\n  function isDefault(score) {\n    return !score || score[0] === -100 && score[1] === 0 && score[2] === 0;\n  }\n\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\n\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  var wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  } // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n\n\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\n    return undefined;\n  }\n\n  var row = 1;\n  var column = 1;\n  var patternPos = patternStart;\n  var wordPos = wordStart; // There will be a match, fill in tables\n\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\n      var score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\n\n      _scores[row][column] = score;\n      var diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\n      var top_1 = _table[row - 1][column] + -1;\n      var left = _table[row][column - 1] + -1;\n\n      if (left >= top_1) {\n        // left or diag\n        if (left > diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4\n          /* Left */\n          ;\n        } else if (left === diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4\n          /* Left */\n          | 2\n          /* Diag */\n          ;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2\n          /* Diag */\n          ;\n        }\n      } else {\n        // top or diag\n        if (top_1 > diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1\n          /* Top */\n          ;\n        } else if (top_1 === diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1\n          /* Top */\n          | 2\n          /* Diag */\n          ;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2\n          /* Diag */\n          ;\n        }\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n\n  _matchesCount = 0;\n  _topScore = -100;\n  _wordStart = wordStart;\n  _firstMatchCanBeWeak = firstMatchCanBeWeak;\n\n  _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\n\n  if (_matchesCount === 0) {\n    return undefined;\n  }\n\n  return [_topScore, _topMatch2, wordStart];\n}\n\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return -1;\n  }\n\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    return 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    return 5;\n  } else {\n    return 1;\n  }\n}\n\nvar _matchesCount = 0;\nvar _topMatch2 = 0;\nvar _topScore = 0;\nvar _wordStart = 0;\nvar _firstMatchCanBeWeak = false;\n\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\n  if (_matchesCount >= 10 || total < -25) {\n    // stop when having already 10 results, or\n    // when a potential alignment as already 5 gaps\n    return;\n  }\n\n  var simpleMatchCount = 0;\n\n  while (row > 0 && column > 0) {\n    var score = _scores[row][column];\n    var arrow = _arrows[row][column];\n\n    if (arrow === 4\n    /* Left */\n    ) {\n        // left -> no match, skip a word character\n        column -= 1;\n\n        if (lastMatched) {\n          total -= 5; // new gap penalty\n        } else if (matches !== 0) {\n          total -= 1; // gap penalty after first match\n        }\n\n        lastMatched = false;\n        simpleMatchCount = 0;\n      } else if (arrow & 2\n    /* Diag */\n    ) {\n        if (arrow & 4\n        /* Left */\n        ) {\n            // left\n            _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\n            matches, lastMatched);\n          } // diag\n\n\n        total += score;\n        row -= 1;\n        column -= 1;\n        lastMatched = true; // match -> set a 1 at the word pos\n\n        matches += Math.pow(2, column + _wordStart); // count simple matches and boost a row of\n        // simple matches when they yield in a\n        // strong match.\n\n        if (score === 1) {\n          simpleMatchCount += 1;\n\n          if (row === 0 && !_firstMatchCanBeWeak) {\n            // when the first match is a weak\n            // match we discard it\n            return undefined;\n          }\n        } else {\n          // boost\n          total += 1 + simpleMatchCount * (score - 1);\n          simpleMatchCount = 0;\n        }\n      } else {\n      return undefined;\n    }\n  }\n\n  total -= column >= 3 ? 9 : column * 3; // late start penalty\n  // dynamically keep track of the current top score\n  // and insert the current best score at head, the rest at tail\n\n  _matchesCount += 1;\n\n  if (total > _topScore) {\n    _topScore = total;\n    _topMatch2 = matches;\n  }\n} //#endregion\n//#region --- graceful ---\n\n\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    var tries = Math.min(7, pattern.length - 1);\n\n    for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\n      if (newPattern) {\n        var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n\n  return top;\n}\n\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n\n  var swap1 = pattern[patternPos];\n  var swap2 = pattern[patternPos + 1];\n\n  if (swap1 === swap2) {\n    return undefined;\n  }\n\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n} //#endregion","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"names":["LRUCache","strings","or","filter","_i","arguments","length","word","wordToMatchAgainst","i","len","match","matchesPrefix","_matchesPrefix","bind","undefined","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","anyScore","pattern","lowPattern","_patternPos","lowWord","_wordPos","fuzzyScore","score","idx","patternPos","_maxLen","wordPos","charAt","Math","pow","createMatches","toString","wordStart","res","pos","last","push","initTable","table","row","thisRow","slice","_table","_scores","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","map","printTables","patternStart","substr","console","log","isSeparatorAtPos","value","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","FuzzyScore","Default","Object","freeze","isDefault","firstMatchCanBeWeak","column","_doScore","diag","top_1","left","_matchesCount","_topScore","_wordStart","_firstMatchCanBeWeak","_findAllMatches2","_topMatch2","total","lastMatched","simpleMatchCount","arrow","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","min","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"mappings":"AAAA;;;;AAIA,SAASA,QAAT,QAAyB,UAAzB;AACA,OAAO,KAAKC,OAAZ,MAAyB,cAAzB,C,CACA;;AACA;;;;;;;AAMA,OAAO,SAASC,EAAT,GAAc;AACjB,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC1CD,IAAAA,MAAM,CAACC,EAAD,CAAN,GAAaC,SAAS,CAACD,EAAD,CAAtB;AACH;;AACD,SAAO,UAAUG,IAAV,EAAgBC,kBAAhB,EAAoC;AACvC,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGP,MAAM,CAACG,MAA7B,EAAqCG,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AAC/C,UAAIE,KAAK,GAAGR,MAAM,CAACM,CAAD,CAAN,CAAUF,IAAV,EAAgBC,kBAAhB,CAAZ;;AACA,UAAIG,KAAJ,EAAW;AACP,eAAOA,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GARD;AASH;AACD,OAAO,IAAIC,aAAa,GAAGC,cAAc,CAACC,IAAf,CAAoBC,SAApB,EAA+B,IAA/B,CAApB;;AACP,SAASF,cAAT,CAAwBG,UAAxB,EAAoCT,IAApC,EAA0CC,kBAA1C,EAA8D;AAC1D,MAAI,CAACA,kBAAD,IAAuBA,kBAAkB,CAACF,MAAnB,GAA4BC,IAAI,CAACD,MAA5D,EAAoE;AAChE,WAAO,IAAP;AACH;;AACD,MAAIW,OAAJ;;AACA,MAAID,UAAJ,EAAgB;AACZC,IAAAA,OAAO,GAAGhB,OAAO,CAACiB,oBAAR,CAA6BV,kBAA7B,EAAiDD,IAAjD,CAAV;AACH,GAFD,MAGK;AACDU,IAAAA,OAAO,GAAGT,kBAAkB,CAACW,OAAnB,CAA2BZ,IAA3B,MAAqC,CAA/C;AACH;;AACD,MAAI,CAACU,OAAL,EAAc;AACV,WAAO,IAAP;AACH;;AACD,SAAOV,IAAI,CAACD,MAAL,GAAc,CAAd,GAAkB,CAAC;AAAEc,IAAAA,KAAK,EAAE,CAAT;AAAYC,IAAAA,GAAG,EAAEd,IAAI,CAACD;AAAtB,GAAD,CAAlB,GAAqD,EAA5D;AACH,C,CACD;;;AACA,OAAO,SAASgB,0BAAT,CAAoCf,IAApC,EAA0CC,kBAA1C,EAA8D;AACjE,MAAIe,KAAK,GAAGf,kBAAkB,CAACgB,WAAnB,GAAiCL,OAAjC,CAAyCZ,IAAI,CAACiB,WAAL,EAAzC,CAAZ;;AACA,MAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd,WAAO,IAAP;AACH;;AACD,SAAO,CAAC;AAAEH,IAAAA,KAAK,EAAEG,KAAT;AAAgBF,IAAAA,GAAG,EAAEE,KAAK,GAAGhB,IAAI,CAACD;AAAlC,GAAD,CAAP;AACH,C,CACD;;AACA,OAAO,SAASmB,gBAAT,CAA0BlB,IAA1B,EAAgCC,kBAAhC,EAAoD;AACvD,SAAOkB,iBAAiB,CAACnB,IAAI,CAACiB,WAAL,EAAD,EAAqBhB,kBAAkB,CAACgB,WAAnB,EAArB,EAAuD,CAAvD,EAA0D,CAA1D,CAAxB;AACH;;AACD,SAASE,iBAAT,CAA2BnB,IAA3B,EAAiCC,kBAAjC,EAAqDC,CAArD,EAAwDkB,CAAxD,EAA2D;AACvD,MAAIlB,CAAC,KAAKF,IAAI,CAACD,MAAf,EAAuB;AACnB,WAAO,EAAP;AACH,GAFD,MAGK,IAAIqB,CAAC,KAAKnB,kBAAkB,CAACF,MAA7B,EAAqC;AACtC,WAAO,IAAP;AACH,GAFI,MAGA;AACD,QAAIC,IAAI,CAACE,CAAD,CAAJ,KAAYD,kBAAkB,CAACmB,CAAD,CAAlC,EAAuC;AACnC,UAAIC,MAAM,GAAG,IAAb;;AACA,UAAIA,MAAM,GAAGF,iBAAiB,CAACnB,IAAD,EAAOC,kBAAP,EAA2BC,CAAC,GAAG,CAA/B,EAAkCkB,CAAC,GAAG,CAAtC,CAA9B,EAAwE;AACpE,eAAOE,IAAI,CAAC;AAAET,UAAAA,KAAK,EAAEO,CAAT;AAAYN,UAAAA,GAAG,EAAEM,CAAC,GAAG;AAArB,SAAD,EAA2BC,MAA3B,CAAX;AACH;;AACD,aAAO,IAAP;AACH;;AACD,WAAOF,iBAAiB,CAACnB,IAAD,EAAOC,kBAAP,EAA2BC,CAA3B,EAA8BkB,CAAC,GAAG,CAAlC,CAAxB;AACH;AACJ,C,CACD;;;AACA,SAASG,OAAT,CAAiBC,IAAjB,EAAuB;AACnB,SAAO;AAAG;AAAH,KAAcA,IAAd,IAAsBA,IAAI,IAAI;AAAI;AAAzC;AACH;;AACD,OAAO,SAASC,OAAT,CAAiBD,IAAjB,EAAuB;AAC1B,SAAO;AAAG;AAAH,KAAcA,IAAd,IAAsBA,IAAI,IAAI;AAAG;AAAxC;AACH;;AACD,SAASE,QAAT,CAAkBF,IAAlB,EAAwB;AACpB,SAAO;AAAG;AAAH,KAAmBA,IAAnB,IAA2BA,IAAI,IAAI;AAAG;AAA7C;AACH;;AACD,SAASG,YAAT,CAAsBH,IAAtB,EAA4B;AACxB,SAAQA,IAAI,KAAK;AAAG;AAAZ,KACDA,IAAI,KAAK;AAAE;AADV,KAEDA,IAAI,KAAK;AAAG;AAFX,KAGDA,IAAI,KAAK;AAAG;AAHnB;AAIH;;AACD,IAAII,cAAc,GAAG,IAAIC,GAAJ,EAArB;AACA,oCACKC,KADL,CACW,EADX,EAEKC,OAFL,CAEa,UAAUC,CAAV,EAAa;AAAE,SAAOJ,cAAc,CAACK,GAAf,CAAmBD,CAAC,CAACE,UAAF,CAAa,CAAb,CAAnB,CAAP;AAA6C,CAFzE;;AAGA,SAASC,cAAT,CAAwBX,IAAxB,EAA8B;AAC1B,SAAOD,OAAO,CAACC,IAAD,CAAP,IAAiBC,OAAO,CAACD,IAAD,CAAxB,IAAkCE,QAAQ,CAACF,IAAD,CAAjD;AACH;;AACD,SAASF,IAAT,CAAcc,IAAd,EAAoBC,IAApB,EAA0B;AACtB,MAAIA,IAAI,CAACtC,MAAL,KAAgB,CAApB,EAAuB;AACnBsC,IAAAA,IAAI,GAAG,CAACD,IAAD,CAAP;AACH,GAFD,MAGK,IAAIA,IAAI,CAACtB,GAAL,KAAauB,IAAI,CAAC,CAAD,CAAJ,CAAQxB,KAAzB,EAAgC;AACjCwB,IAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQxB,KAAR,GAAgBuB,IAAI,CAACvB,KAArB;AACH,GAFI,MAGA;AACDwB,IAAAA,IAAI,CAACC,OAAL,CAAaF,IAAb;AACH;;AACD,SAAOC,IAAP;AACH;;AACD,SAASE,UAAT,CAAoBC,aAApB,EAAmC3B,KAAnC,EAA0C;AACtC,OAAK,IAAIX,CAAC,GAAGW,KAAb,EAAoBX,CAAC,GAAGsC,aAAa,CAACzC,MAAtC,EAA8CG,CAAC,EAA/C,EAAmD;AAC/C,QAAIuC,CAAC,GAAGD,aAAa,CAACN,UAAd,CAAyBhC,CAAzB,CAAR;;AACA,QAAIuB,OAAO,CAACgB,CAAD,CAAP,IAAcf,QAAQ,CAACe,CAAD,CAAtB,IAA8BvC,CAAC,GAAG,CAAJ,IAAS,CAACiC,cAAc,CAACK,aAAa,CAACN,UAAd,CAAyBhC,CAAC,GAAG,CAA7B,CAAD,CAA1D,EAA8F;AAC1F,aAAOA,CAAP;AACH;AACJ;;AACD,SAAOsC,aAAa,CAACzC,MAArB;AACH;;AACD,SAAS2C,iBAAT,CAA2B1C,IAA3B,EAAiCwC,aAAjC,EAAgDtC,CAAhD,EAAmDkB,CAAnD,EAAsD;AAClD,MAAIlB,CAAC,KAAKF,IAAI,CAACD,MAAf,EAAuB;AACnB,WAAO,EAAP;AACH,GAFD,MAGK,IAAIqB,CAAC,KAAKoB,aAAa,CAACzC,MAAxB,EAAgC;AACjC,WAAO,IAAP;AACH,GAFI,MAGA,IAAIC,IAAI,CAACE,CAAD,CAAJ,KAAYsC,aAAa,CAACpB,CAAD,CAAb,CAAiBH,WAAjB,EAAhB,EAAgD;AACjD,WAAO,IAAP;AACH,GAFI,MAGA;AACD,QAAII,MAAM,GAAG,IAAb;AACA,QAAIsB,cAAc,GAAGvB,CAAC,GAAG,CAAzB;AACAC,IAAAA,MAAM,GAAGqB,iBAAiB,CAAC1C,IAAD,EAAOwC,aAAP,EAAsBtC,CAAC,GAAG,CAA1B,EAA6BkB,CAAC,GAAG,CAAjC,CAA1B;;AACA,WAAO,CAACC,MAAD,IAAW,CAACsB,cAAc,GAAGJ,UAAU,CAACC,aAAD,EAAgBG,cAAhB,CAA5B,IAA+DH,aAAa,CAACzC,MAA/F,EAAuG;AACnGsB,MAAAA,MAAM,GAAGqB,iBAAiB,CAAC1C,IAAD,EAAOwC,aAAP,EAAsBtC,CAAC,GAAG,CAA1B,EAA6ByC,cAA7B,CAA1B;AACAA,MAAAA,cAAc;AACjB;;AACD,WAAOtB,MAAM,KAAK,IAAX,GAAkB,IAAlB,GAAyBC,IAAI,CAAC;AAAET,MAAAA,KAAK,EAAEO,CAAT;AAAYN,MAAAA,GAAG,EAAEM,CAAC,GAAG;AAArB,KAAD,EAA2BC,MAA3B,CAApC;AACH;AACJ,C,CACD;AACA;;;AACA,SAASuB,oBAAT,CAA8B5C,IAA9B,EAAoC;AAChC,MAAI6C,KAAK,GAAG,CAAZ;AAAA,MAAeC,KAAK,GAAG,CAAvB;AAAA,MAA0BC,KAAK,GAAG,CAAlC;AAAA,MAAqCC,OAAO,GAAG,CAA/C;AAAA,MAAkDxB,IAAI,GAAG,CAAzD;;AACA,OAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACD,MAAzB,EAAiCG,CAAC,EAAlC,EAAsC;AAClCsB,IAAAA,IAAI,GAAGxB,IAAI,CAACkC,UAAL,CAAgBhC,CAAhB,CAAP;;AACA,QAAIuB,OAAO,CAACD,IAAD,CAAX,EAAmB;AACfqB,MAAAA,KAAK;AACR;;AACD,QAAItB,OAAO,CAACC,IAAD,CAAX,EAAmB;AACfsB,MAAAA,KAAK;AACR;;AACD,QAAIX,cAAc,CAACX,IAAD,CAAlB,EAA0B;AACtBuB,MAAAA,KAAK;AACR;;AACD,QAAIrB,QAAQ,CAACF,IAAD,CAAZ,EAAoB;AAChBwB,MAAAA,OAAO;AACV;AACJ;;AACD,MAAIC,YAAY,GAAGJ,KAAK,GAAG7C,IAAI,CAACD,MAAhC;AACA,MAAImD,YAAY,GAAGJ,KAAK,GAAG9C,IAAI,CAACD,MAAhC;AACA,MAAIoD,YAAY,GAAGJ,KAAK,GAAG/C,IAAI,CAACD,MAAhC;AACA,MAAIqD,cAAc,GAAGJ,OAAO,GAAGhD,IAAI,CAACD,MAApC;AACA,SAAO;AAAEkD,IAAAA,YAAY,EAAEA,YAAhB;AAA8BC,IAAAA,YAAY,EAAEA,YAA5C;AAA0DC,IAAAA,YAAY,EAAEA,YAAxE;AAAsFC,IAAAA,cAAc,EAAEA;AAAtG,GAAP;AACH;;AACD,SAASC,eAAT,CAAyBC,QAAzB,EAAmC;AAC/B,MAAIL,YAAY,GAAGK,QAAQ,CAACL,YAA5B;AAAA,MAA0CC,YAAY,GAAGI,QAAQ,CAACJ,YAAlE;AACA,SAAOA,YAAY,KAAK,CAAjB,IAAsBD,YAAY,GAAG,GAA5C;AACH;;AACD,SAASM,eAAT,CAAyBD,QAAzB,EAAmC;AAC/B,MAAIL,YAAY,GAAGK,QAAQ,CAACL,YAA5B;AAAA,MAA0CC,YAAY,GAAGI,QAAQ,CAACJ,YAAlE;AAAA,MAAgFC,YAAY,GAAGG,QAAQ,CAACH,YAAxG;AAAA,MAAsHC,cAAc,GAAGE,QAAQ,CAACF,cAAhJ;AACA,SAAOF,YAAY,GAAG,GAAf,IAAsBD,YAAY,GAAG,GAArC,IAA4CE,YAAY,GAAG,GAA3D,IAAkEC,cAAc,GAAG,GAA1F;AACH,C,CACD;AACA;;;AACA,SAASI,kBAAT,CAA4BxD,IAA5B,EAAkC;AAC9B,MAAI6C,KAAK,GAAG,CAAZ;AAAA,MAAeC,KAAK,GAAG,CAAvB;AAAA,MAA0BtB,IAAI,GAAG,CAAjC;AAAA,MAAoCiC,UAAU,GAAG,CAAjD;;AACA,OAAK,IAAIvD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACD,MAAzB,EAAiCG,CAAC,EAAlC,EAAsC;AAClCsB,IAAAA,IAAI,GAAGxB,IAAI,CAACkC,UAAL,CAAgBhC,CAAhB,CAAP;;AACA,QAAIuB,OAAO,CAACD,IAAD,CAAX,EAAmB;AACfqB,MAAAA,KAAK;AACR;;AACD,QAAItB,OAAO,CAACC,IAAD,CAAX,EAAmB;AACfsB,MAAAA,KAAK;AACR;;AACD,QAAInB,YAAY,CAACH,IAAD,CAAhB,EAAwB;AACpBiC,MAAAA,UAAU;AACb;AACJ;;AACD,MAAI,CAACZ,KAAK,KAAK,CAAV,IAAeC,KAAK,KAAK,CAA1B,KAAgCW,UAAU,KAAK,CAAnD,EAAsD;AAClD,WAAOzD,IAAI,CAACD,MAAL,IAAe,EAAtB;AACH,GAFD,MAGK;AACD,WAAO8C,KAAK,IAAI,CAAhB;AACH;AACJ;;AACD,OAAO,SAASa,gBAAT,CAA0B1D,IAA1B,EAAgCwC,aAAhC,EAA+C;AAClD,MAAI,CAACA,aAAL,EAAoB;AAChB,WAAO,IAAP;AACH;;AACDA,EAAAA,aAAa,GAAGA,aAAa,CAACmB,IAAd,EAAhB;;AACA,MAAInB,aAAa,CAACzC,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,WAAO,IAAP;AACH;;AACD,MAAI,CAACyD,kBAAkB,CAACxD,IAAD,CAAvB,EAA+B;AAC3B,WAAO,IAAP;AACH;;AACD,MAAIwC,aAAa,CAACzC,MAAd,GAAuB,EAA3B,EAA+B;AAC3B,WAAO,IAAP;AACH;;AACD,MAAIuD,QAAQ,GAAGV,oBAAoB,CAACJ,aAAD,CAAnC;;AACA,MAAI,CAACe,eAAe,CAACD,QAAD,CAApB,EAAgC;AAC5B,QAAI,CAACD,eAAe,CAACC,QAAD,CAApB,EAAgC;AAC5B,aAAO,IAAP;AACH;;AACDd,IAAAA,aAAa,GAAGA,aAAa,CAACvB,WAAd,EAAhB;AACH;;AACD,MAAII,MAAM,GAAG,IAAb;AACA,MAAInB,CAAC,GAAG,CAAR;AACAF,EAAAA,IAAI,GAAGA,IAAI,CAACiB,WAAL,EAAP;;AACA,SAAOf,CAAC,GAAGsC,aAAa,CAACzC,MAAlB,IAA4B,CAACsB,MAAM,GAAGqB,iBAAiB,CAAC1C,IAAD,EAAOwC,aAAP,EAAsB,CAAtB,EAAyBtC,CAAzB,CAA3B,MAA4D,IAA/F,EAAqG;AACjGA,IAAAA,CAAC,GAAGqC,UAAU,CAACC,aAAD,EAAgBtC,CAAC,GAAG,CAApB,CAAd;AACH;;AACD,SAAOmB,MAAP;AACH,C,CACD;;AACA,IAAIuC,qBAAqB,GAAGjE,EAAE,CAACU,aAAD,EAAgBqD,gBAAhB,EAAkC3C,0BAAlC,CAA9B;AACA,IAAI8C,mBAAmB,GAAGlE,EAAE,CAACU,aAAD,EAAgBqD,gBAAhB,EAAkCxC,gBAAlC,CAA5B;AACA,IAAI4C,gBAAgB,GAAG,IAAIrE,QAAJ,CAAa,KAAb,CAAvB,C,CAA4C;;AAC5C,OAAO,SAASsE,YAAT,CAAsB/D,IAAtB,EAA4BC,kBAA5B,EAAgD+D,+BAAhD,EAAiF;AACpF,MAAIA,+BAA+B,KAAK,KAAK,CAA7C,EAAgD;AAAEA,IAAAA,+BAA+B,GAAG,KAAlC;AAA0C;;AAC5F,MAAI,OAAOhE,IAAP,KAAgB,QAAhB,IAA4B,OAAOC,kBAAP,KAA8B,QAA9D,EAAwE;AACpE,WAAO,IAAP,CADoE,CACvD;AAChB,GAJmF,CAKpF;;;AACA,MAAIgE,MAAM,GAAGH,gBAAgB,CAACI,GAAjB,CAAqBlE,IAArB,CAAb;;AACA,MAAI,CAACiE,MAAL,EAAa;AACTA,IAAAA,MAAM,GAAG,IAAIE,MAAJ,CAAWzE,OAAO,CAAC0E,2BAAR,CAAoCpE,IAApC,CAAX,EAAsD,GAAtD,CAAT;AACA8D,IAAAA,gBAAgB,CAACO,GAAjB,CAAqBrE,IAArB,EAA2BiE,MAA3B;AACH,GAVmF,CAWpF;;;AACA,MAAI7D,KAAK,GAAG6D,MAAM,CAACK,IAAP,CAAYrE,kBAAZ,CAAZ;;AACA,MAAIG,KAAJ,EAAW;AACP,WAAO,CAAC;AAAES,MAAAA,KAAK,EAAET,KAAK,CAACY,KAAf;AAAsBF,MAAAA,GAAG,EAAEV,KAAK,CAACY,KAAN,GAAcZ,KAAK,CAAC,CAAD,CAAL,CAASL;AAAlD,KAAD,CAAP;AACH,GAfmF,CAgBpF;;;AACA,SAAOiE,+BAA+B,GAAGH,mBAAmB,CAAC7D,IAAD,EAAOC,kBAAP,CAAtB,GAAmD2D,qBAAqB,CAAC5D,IAAD,EAAOC,kBAAP,CAA9G;AACH;AACD,OAAO,SAASsE,QAAT,CAAkBC,OAAlB,EAA2BC,UAA3B,EAAuCC,WAAvC,EAAoD1E,IAApD,EAA0D2E,OAA1D,EAAmEC,QAAnE,EAA6E;AAChF,MAAIvD,MAAM,GAAGwD,UAAU,CAACL,OAAD,EAAUC,UAAV,EAAsB,CAAtB,EAAyBzE,IAAzB,EAA+B2E,OAA/B,EAAwC,CAAxC,EAA2C,IAA3C,CAAvB;;AACA,MAAItD,MAAJ,EAAY;AACR,WAAOA,MAAP;AACH;;AACD,MAAIX,OAAO,GAAG,CAAd;AACA,MAAIoE,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAGH,QAAV;;AACA,OAAK,IAAII,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGP,UAAU,CAAC1E,MAAxB,IAAkCiF,UAAU,GAAGC,OAAxE,EAAiF,EAAED,UAAnF,EAA+F;AAC3F,QAAIE,OAAO,GAAGP,OAAO,CAAC/D,OAAR,CAAgB6D,UAAU,CAACU,MAAX,CAAkBH,UAAlB,CAAhB,EAA+CD,GAA/C,CAAd;;AACA,QAAIG,OAAO,IAAI,CAAf,EAAkB;AACdJ,MAAAA,KAAK,IAAI,CAAT;AACApE,MAAAA,OAAO,IAAI0E,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,OAAZ,CAAX;AACAH,MAAAA,GAAG,GAAGG,OAAO,GAAG,CAAhB;AACH,KAJD,MAKK,IAAIxE,OAAO,KAAK,CAAhB,EAAmB;AACpB;AACA;AACA;AACA;AACH;AACJ;;AACD,SAAO,CAACoE,KAAD,EAAQpE,OAAR,EAAiBkE,QAAjB,CAAP;AACH,C,CACD;;AACA,OAAO,SAASU,aAAT,CAAuBR,KAAvB,EAA8B;AACjC,MAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC;AAC9B,WAAO,EAAP;AACH;;AACD,MAAIpE,OAAO,GAAGoE,KAAK,CAAC,CAAD,CAAL,CAASS,QAAT,CAAkB,CAAlB,CAAd;AACA,MAAIC,SAAS,GAAGV,KAAK,CAAC,CAAD,CAArB;AACA,MAAIW,GAAG,GAAG,EAAV;;AACA,OAAK,IAAIC,GAAG,GAAGF,SAAf,EAA0BE,GAAG,GAAGT,OAAhC,EAAyCS,GAAG,EAA5C,EAAgD;AAC5C,QAAIhF,OAAO,CAACA,OAAO,CAACX,MAAR,IAAkB2F,GAAG,GAAG,CAAxB,CAAD,CAAP,KAAwC,GAA5C,EAAiD;AAC7C,UAAIC,IAAI,GAAGF,GAAG,CAACA,GAAG,CAAC1F,MAAJ,GAAa,CAAd,CAAd;;AACA,UAAI4F,IAAI,IAAIA,IAAI,CAAC7E,GAAL,KAAa4E,GAAzB,EAA8B;AAC1BC,QAAAA,IAAI,CAAC7E,GAAL,GAAW4E,GAAG,GAAG,CAAjB;AACH,OAFD,MAGK;AACDD,QAAAA,GAAG,CAACG,IAAJ,CAAS;AAAE/E,UAAAA,KAAK,EAAE6E,GAAT;AAAc5E,UAAAA,GAAG,EAAE4E,GAAG,GAAG;AAAzB,SAAT;AACH;AACJ;AACJ;;AACD,SAAOD,GAAP;AACH;AACD,IAAIR,OAAO,GAAG,GAAd;;AACA,SAASY,SAAT,GAAqB;AACjB,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,GAAG,GAAG,CAAC,CAAD,CAAV;;AACA,OAAK,IAAI7F,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+E,OAArB,EAA8B/E,CAAC,EAA/B,EAAmC;AAC/B6F,IAAAA,GAAG,CAACH,IAAJ,CAAS,CAAC1F,CAAV;AACH;;AACD,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+E,OAArB,EAA8B/E,CAAC,EAA/B,EAAmC;AAC/B,QAAI8F,OAAO,GAAGD,GAAG,CAACE,KAAJ,CAAU,CAAV,CAAd;AACAD,IAAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAC9F,CAAd;AACA4F,IAAAA,KAAK,CAACF,IAAN,CAAWI,OAAX;AACH;;AACD,SAAOF,KAAP;AACH;;AACD,IAAII,MAAM,GAAGL,SAAS,EAAtB;;AACA,IAAIM,OAAO,GAAGN,SAAS,EAAvB;;AACA,IAAIO,OAAO,GAAGP,SAAS,EAAvB;;AACA,IAAIQ,MAAM,GAAG,KAAb;;AACA,SAASC,UAAT,CAAoBR,KAApB,EAA2BtB,OAA3B,EAAoC+B,UAApC,EAAgDvG,IAAhD,EAAsDwG,OAAtD,EAA+D;AAC3D,WAASC,GAAT,CAAazE,CAAb,EAAgB0E,CAAhB,EAAmBD,GAAnB,EAAwB;AACpB,QAAIA,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAAEA,MAAAA,GAAG,GAAG,GAAN;AAAY;;AAClC,WAAOzE,CAAC,CAACjC,MAAF,GAAW2G,CAAlB,EAAqB;AACjB1E,MAAAA,CAAC,GAAGyE,GAAG,GAAGzE,CAAV;AACH;;AACD,WAAOA,CAAP;AACH;;AACD,MAAI2E,GAAG,GAAG,WAAW3G,IAAI,CAAC8B,KAAL,CAAW,EAAX,EAAe8E,GAAf,CAAmB,UAAUnE,CAAV,EAAa;AAAE,WAAOgE,GAAG,CAAChE,CAAD,EAAI,CAAJ,CAAV;AAAmB,GAArD,EAAuDnB,IAAvD,CAA4D,GAA5D,CAAX,GAA8E,IAAxF;;AACA,OAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIqG,UAArB,EAAiCrG,CAAC,EAAlC,EAAsC;AAClC,QAAIA,CAAC,KAAK,CAAV,EAAa;AACTyG,MAAAA,GAAG,IAAI,IAAP;AACH,KAFD,MAGK;AACDA,MAAAA,GAAG,IAAInC,OAAO,CAACtE,CAAC,GAAG,CAAL,CAAP,GAAiB,GAAxB;AACH;;AACDyG,IAAAA,GAAG,IAAIb,KAAK,CAAC5F,CAAD,CAAL,CAAS+F,KAAT,CAAe,CAAf,EAAkBO,OAAO,GAAG,CAA5B,EAA+BI,GAA/B,CAAmC,UAAUF,CAAV,EAAa;AAAE,aAAOD,GAAG,CAACC,CAAC,CAACnB,QAAF,EAAD,EAAe,CAAf,CAAV;AAA8B,KAAhF,EAAkFjE,IAAlF,CAAuF,GAAvF,IAA8F,IAArG;AACH;;AACD,SAAOqF,GAAP;AACH;;AACD,SAASE,WAAT,CAAqBrC,OAArB,EAA8BsC,YAA9B,EAA4C9G,IAA5C,EAAkDwF,SAAlD,EAA6D;AACzDhB,EAAAA,OAAO,GAAGA,OAAO,CAACuC,MAAR,CAAeD,YAAf,CAAV;AACA9G,EAAAA,IAAI,GAAGA,IAAI,CAAC+G,MAAL,CAAYvB,SAAZ,CAAP;AACAwB,EAAAA,OAAO,CAACC,GAAR,CAAYX,UAAU,CAACJ,MAAD,EAAS1B,OAAT,EAAkBA,OAAO,CAACzE,MAA1B,EAAkCC,IAAlC,EAAwCA,IAAI,CAACD,MAA7C,CAAtB;AACAiH,EAAAA,OAAO,CAACC,GAAR,CAAYX,UAAU,CAACF,OAAD,EAAU5B,OAAV,EAAmBA,OAAO,CAACzE,MAA3B,EAAmCC,IAAnC,EAAyCA,IAAI,CAACD,MAA9C,CAAtB;AACAiH,EAAAA,OAAO,CAACC,GAAR,CAAYX,UAAU,CAACH,OAAD,EAAU3B,OAAV,EAAmBA,OAAO,CAACzE,MAA3B,EAAmCC,IAAnC,EAAyCA,IAAI,CAACD,MAA9C,CAAtB;AACH;;AACD,SAASmH,gBAAT,CAA0BC,KAA1B,EAAiCnG,KAAjC,EAAwC;AACpC,MAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAImG,KAAK,CAACpH,MAAhC,EAAwC;AACpC,WAAO,KAAP;AACH;;AACD,MAAIyB,IAAI,GAAG2F,KAAK,CAACjF,UAAN,CAAiBlB,KAAjB,CAAX;;AACA,UAAQQ,IAAR;AACI,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACA,SAAK;AAAG;AAAR;AACI,aAAO,IAAP;;AACJ;AACI,aAAO,KAAP;AAbR;AAeH;;AACD,SAAS4F,iBAAT,CAA2BD,KAA3B,EAAkCnG,KAAlC,EAAyC;AACrC,MAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAImG,KAAK,CAACpH,MAAhC,EAAwC;AACpC,WAAO,KAAP;AACH;;AACD,MAAIyB,IAAI,GAAG2F,KAAK,CAACjF,UAAN,CAAiBlB,KAAjB,CAAX;;AACA,UAAQQ,IAAR;AACI,SAAK;AAAG;AAAR;AACA,SAAK;AAAE;AAAP;AACI,aAAO,IAAP;;AACJ;AACI,aAAO,KAAP;AALR;AAOH;;AACD,SAAS6F,gBAAT,CAA0B3B,GAA1B,EAA+B1F,IAA/B,EAAqCsH,OAArC,EAA8C;AAC1C,SAAOtH,IAAI,CAAC0F,GAAD,CAAJ,KAAc4B,OAAO,CAAC5B,GAAD,CAA5B;AACH;;AACD,OAAO,SAAS6B,eAAT,CAAyBC,UAAzB,EAAqCxC,UAArC,EAAiDuB,UAAjD,EAA6De,OAA7D,EAAsEpC,OAAtE,EAA+EsB,OAA/E,EAAwF;AAC3F,SAAOxB,UAAU,GAAGuB,UAAb,IAA2BrB,OAAO,GAAGsB,OAA5C,EAAqD;AACjD,QAAIgB,UAAU,CAACxC,UAAD,CAAV,KAA2BsC,OAAO,CAACpC,OAAD,CAAtC,EAAiD;AAC7CF,MAAAA,UAAU,IAAI,CAAd;AACH;;AACDE,IAAAA,OAAO,IAAI,CAAX;AACH;;AACD,SAAOF,UAAU,KAAKuB,UAAtB,CAP2F,CAOzD;AACrC;AACD,OAAO,IAAIkB,UAAJ;;AACP,CAAC,UAAUA,UAAV,EAAsB;AACnB;;;AAGAA,EAAAA,UAAU,CAACC,OAAX,GAAqBC,MAAM,CAACC,MAAP,CAAc,CAAC,CAAC,GAAF,EAAO,CAAP,EAAU,CAAV,CAAd,CAArB;;AACA,WAASC,SAAT,CAAmB/C,KAAnB,EAA0B;AACtB,WAAO,CAACA,KAAD,IAAWA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAC,GAAd,IAAqBA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAlC,IAAuCA,KAAK,CAAC,CAAD,CAAL,KAAa,CAAtE;AACH;;AACD2C,EAAAA,UAAU,CAACI,SAAX,GAAuBA,SAAvB;AACH,CATD,EASGJ,UAAU,KAAKA,UAAU,GAAG,EAAlB,CATb;;AAUA,OAAO,SAAS5C,UAAT,CAAoBL,OAApB,EAA6BgD,UAA7B,EAAyCV,YAAzC,EAAuD9G,IAAvD,EAA6DsH,OAA7D,EAAsE9B,SAAtE,EAAiFsC,mBAAjF,EAAsG;AACzG,MAAIvB,UAAU,GAAG/B,OAAO,CAACzE,MAAR,GAAiBkF,OAAjB,GAA2BA,OAA3B,GAAqCT,OAAO,CAACzE,MAA9D;AACA,MAAIyG,OAAO,GAAGxG,IAAI,CAACD,MAAL,GAAckF,OAAd,GAAwBA,OAAxB,GAAkCjF,IAAI,CAACD,MAArD;;AACA,MAAI+G,YAAY,IAAIP,UAAhB,IAA8Bf,SAAS,IAAIgB,OAA3C,IAAuDD,UAAU,GAAGO,YAAd,GAA+BN,OAAO,GAAGhB,SAAnG,EAA+G;AAC3G,WAAOhF,SAAP;AACH,GALwG,CAMzG;AACA;AACA;;;AACA,MAAI,CAAC+G,eAAe,CAACC,UAAD,EAAaV,YAAb,EAA2BP,UAA3B,EAAuCe,OAAvC,EAAgD9B,SAAhD,EAA2DgB,OAA3D,CAApB,EAAyF;AACrF,WAAOhG,SAAP;AACH;;AACD,MAAIuF,GAAG,GAAG,CAAV;AACA,MAAIgC,MAAM,GAAG,CAAb;AACA,MAAI/C,UAAU,GAAG8B,YAAjB;AACA,MAAI5B,OAAO,GAAGM,SAAd,CAfyG,CAgBzG;;AACA,OAAKO,GAAG,GAAG,CAAN,EAASf,UAAU,GAAG8B,YAA3B,EAAyC9B,UAAU,GAAGuB,UAAtD,EAAkER,GAAG,IAAIf,UAAU,EAAnF,EAAuF;AACnF,SAAK+C,MAAM,GAAG,CAAT,EAAY7C,OAAO,GAAGM,SAA3B,EAAsCN,OAAO,GAAGsB,OAAhD,EAAyDuB,MAAM,IAAI7C,OAAO,EAA1E,EAA8E;AAC1E,UAAIJ,KAAK,GAAGkD,QAAQ,CAACxD,OAAD,EAAUgD,UAAV,EAAsBxC,UAAtB,EAAkC8B,YAAlC,EAAgD9G,IAAhD,EAAsDsH,OAAtD,EAA+DpC,OAA/D,CAApB;;AACAiB,MAAAA,OAAO,CAACJ,GAAD,CAAP,CAAagC,MAAb,IAAuBjD,KAAvB;AACA,UAAImD,IAAI,GAAG/B,MAAM,CAACH,GAAG,GAAG,CAAP,CAAN,CAAgBgC,MAAM,GAAG,CAAzB,KAA+BjD,KAAK,GAAG,CAAR,GAAY,CAAZ,GAAgBA,KAA/C,CAAX;AACA,UAAIoD,KAAK,GAAGhC,MAAM,CAACH,GAAG,GAAG,CAAP,CAAN,CAAgBgC,MAAhB,IAA0B,CAAC,CAAvC;AACA,UAAII,IAAI,GAAGjC,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAM,GAAG,CAArB,IAA0B,CAAC,CAAtC;;AACA,UAAII,IAAI,IAAID,KAAZ,EAAmB;AACf;AACA,YAAIC,IAAI,GAAGF,IAAX,EAAiB;AACb/B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBI,IAAtB;AACA/B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAzB;AACH,SAHD,MAIK,IAAII,IAAI,KAAKF,IAAb,EAAmB;AACpB/B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBI,IAAtB;AACA/B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAF,YAAe;AAAE;AAAxC;AACH,SAHI,MAIA;AACD7B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBE,IAAtB;AACA7B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAzB;AACH;AACJ,OAdD,MAeK;AACD;AACA,YAAIG,KAAK,GAAGD,IAAZ,EAAkB;AACd/B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBG,KAAtB;AACA9B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAzB;AACH,SAHD,MAIK,IAAIG,KAAK,KAAKD,IAAd,EAAoB;AACrB/B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBG,KAAtB;AACA9B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAF,YAAc;AAAE;AAAvC;AACH,SAHI,MAIA;AACD7B,UAAAA,MAAM,CAACH,GAAD,CAAN,CAAYgC,MAAZ,IAAsBE,IAAtB;AACA7B,UAAAA,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,IAAuB;AAAE;AAAzB;AACH;AACJ;AACJ;AACJ;;AACD,MAAI1B,MAAJ,EAAY;AACRQ,IAAAA,WAAW,CAACrC,OAAD,EAAUsC,YAAV,EAAwB9G,IAAxB,EAA8BwF,SAA9B,CAAX;AACH;;AACD4C,EAAAA,aAAa,GAAG,CAAhB;AACAC,EAAAA,SAAS,GAAG,CAAC,GAAb;AACAC,EAAAA,UAAU,GAAG9C,SAAb;AACA+C,EAAAA,oBAAoB,GAAGT,mBAAvB;;AACAU,EAAAA,gBAAgB,CAACzC,GAAG,GAAG,CAAP,EAAUgC,MAAM,GAAG,CAAnB,EAAsBxB,UAAU,KAAKC,OAAf,GAAyB,CAAzB,GAA6B,CAAnD,EAAsD,CAAtD,EAAyD,KAAzD,CAAhB;;AACA,MAAI4B,aAAa,KAAK,CAAtB,EAAyB;AACrB,WAAO5H,SAAP;AACH;;AACD,SAAO,CAAC6H,SAAD,EAAYI,UAAZ,EAAwBjD,SAAxB,CAAP;AACH;;AACD,SAASwC,QAAT,CAAkBxD,OAAlB,EAA2BgD,UAA3B,EAAuCxC,UAAvC,EAAmD8B,YAAnD,EAAiE9G,IAAjE,EAAuEsH,OAAvE,EAAgFpC,OAAhF,EAAyF;AACrF,MAAIsC,UAAU,CAACxC,UAAD,CAAV,KAA2BsC,OAAO,CAACpC,OAAD,CAAtC,EAAiD;AAC7C,WAAO,CAAC,CAAR;AACH;;AACD,MAAIA,OAAO,KAAMF,UAAU,GAAG8B,YAA9B,EAA6C;AACzC;AACA;AACA,QAAItC,OAAO,CAACQ,UAAD,CAAP,KAAwBhF,IAAI,CAACkF,OAAD,CAAhC,EAA2C;AACvC,aAAO,CAAP;AACH,KAFD,MAGK;AACD,aAAO,CAAP;AACH;AACJ,GATD,MAUK,IAAImC,gBAAgB,CAACnC,OAAD,EAAUlF,IAAV,EAAgBsH,OAAhB,CAAhB,KAA6CpC,OAAO,KAAK,CAAZ,IAAiB,CAACmC,gBAAgB,CAACnC,OAAO,GAAG,CAAX,EAAclF,IAAd,EAAoBsH,OAApB,CAA/E,CAAJ,EAAkH;AACnH;AACA;AACA,QAAI9C,OAAO,CAACQ,UAAD,CAAP,KAAwBhF,IAAI,CAACkF,OAAD,CAAhC,EAA2C;AACvC,aAAO,CAAP;AACH,KAFD,MAGK;AACD,aAAO,CAAP;AACH;AACJ,GATI,MAUA,IAAIgC,gBAAgB,CAACI,OAAD,EAAUpC,OAAV,CAAhB,KAAuCA,OAAO,KAAK,CAAZ,IAAiB,CAACgC,gBAAgB,CAACI,OAAD,EAAUpC,OAAO,GAAG,CAApB,CAAzE,CAAJ,EAAsG;AACvG;AACA;AACA,WAAO,CAAP;AACH,GAJI,MAKA,IAAIgC,gBAAgB,CAACI,OAAD,EAAUpC,OAAO,GAAG,CAApB,CAAhB,IAA0CkC,iBAAiB,CAACE,OAAD,EAAUpC,OAAO,GAAG,CAApB,CAA/D,EAAuF;AACxF;AACA;AACA,WAAO,CAAP;AACH,GAJI,MAKA;AACD,WAAO,CAAP;AACH;AACJ;;AACD,IAAIkD,aAAa,GAAG,CAApB;AACA,IAAIK,UAAU,GAAG,CAAjB;AACA,IAAIJ,SAAS,GAAG,CAAhB;AACA,IAAIC,UAAU,GAAG,CAAjB;AACA,IAAIC,oBAAoB,GAAG,KAA3B;;AACA,SAASC,gBAAT,CAA0BzC,GAA1B,EAA+BgC,MAA/B,EAAuCW,KAAvC,EAA8ChI,OAA9C,EAAuDiI,WAAvD,EAAoE;AAChE,MAAIP,aAAa,IAAI,EAAjB,IAAuBM,KAAK,GAAG,CAAC,EAApC,EAAwC;AACpC;AACA;AACA;AACH;;AACD,MAAIE,gBAAgB,GAAG,CAAvB;;AACA,SAAO7C,GAAG,GAAG,CAAN,IAAWgC,MAAM,GAAG,CAA3B,EAA8B;AAC1B,QAAIjD,KAAK,GAAGqB,OAAO,CAACJ,GAAD,CAAP,CAAagC,MAAb,CAAZ;AACA,QAAIc,KAAK,GAAGzC,OAAO,CAACL,GAAD,CAAP,CAAagC,MAAb,CAAZ;;AACA,QAAIc,KAAK,KAAK;AAAE;AAAhB,MAA4B;AACxB;AACAd,QAAAA,MAAM,IAAI,CAAV;;AACA,YAAIY,WAAJ,EAAiB;AACbD,UAAAA,KAAK,IAAI,CAAT,CADa,CACD;AACf,SAFD,MAGK,IAAIhI,OAAO,KAAK,CAAhB,EAAmB;AACpBgI,UAAAA,KAAK,IAAI,CAAT,CADoB,CACR;AACf;;AACDC,QAAAA,WAAW,GAAG,KAAd;AACAC,QAAAA,gBAAgB,GAAG,CAAnB;AACH,OAXD,MAYK,IAAIC,KAAK,GAAG;AAAE;AAAd,MAA0B;AAC3B,YAAIA,KAAK,GAAG;AAAE;AAAd,UAA0B;AACtB;AACAL,YAAAA,gBAAgB,CAACzC,GAAD,EAAMgC,MAAM,GAAG,CAAf,EAAkBrH,OAAO,KAAK,CAAZ,GAAgBgI,KAAK,GAAG,CAAxB,GAA4BA,KAA9C,EAAqD;AACrEhI,YAAAA,OADgB,EACPiI,WADO,CAAhB;AAEH,WAL0B,CAM3B;;;AACAD,QAAAA,KAAK,IAAI5D,KAAT;AACAiB,QAAAA,GAAG,IAAI,CAAP;AACAgC,QAAAA,MAAM,IAAI,CAAV;AACAY,QAAAA,WAAW,GAAG,IAAd,CAV2B,CAW3B;;AACAjI,QAAAA,OAAO,IAAI0E,IAAI,CAACC,GAAL,CAAS,CAAT,EAAa0C,MAAM,GAAGO,UAAtB,CAAX,CAZ2B,CAa3B;AACA;AACA;;AACA,YAAIxD,KAAK,KAAK,CAAd,EAAiB;AACb8D,UAAAA,gBAAgB,IAAI,CAApB;;AACA,cAAI7C,GAAG,KAAK,CAAR,IAAa,CAACwC,oBAAlB,EAAwC;AACpC;AACA;AACA,mBAAO/H,SAAP;AACH;AACJ,SAPD,MAQK;AACD;AACAkI,UAAAA,KAAK,IAAI,IAAKE,gBAAgB,IAAI9D,KAAK,GAAG,CAAZ,CAA9B;AACA8D,UAAAA,gBAAgB,GAAG,CAAnB;AACH;AACJ,OA7BI,MA8BA;AACD,aAAOpI,SAAP;AACH;AACJ;;AACDkI,EAAAA,KAAK,IAAIX,MAAM,IAAI,CAAV,GAAc,CAAd,GAAkBA,MAAM,GAAG,CAApC,CAxDgE,CAwDzB;AACvC;AACA;;AACAK,EAAAA,aAAa,IAAI,CAAjB;;AACA,MAAIM,KAAK,GAAGL,SAAZ,EAAuB;AACnBA,IAAAA,SAAS,GAAGK,KAAZ;AACAD,IAAAA,UAAU,GAAG/H,OAAb;AACH;AACJ,C,CACD;AACA;;;AACA,OAAO,SAASoI,4BAAT,CAAsCtE,OAAtC,EAA+CC,UAA/C,EAA2DO,UAA3D,EAAuEhF,IAAvE,EAA6E2E,OAA7E,EAAsFO,OAAtF,EAA+F4C,mBAA/F,EAAoH;AACvH,SAAOiB,0BAA0B,CAACvE,OAAD,EAAUC,UAAV,EAAsBO,UAAtB,EAAkChF,IAAlC,EAAwC2E,OAAxC,EAAiDO,OAAjD,EAA0D,IAA1D,EAAgE4C,mBAAhE,CAAjC;AACH;;AACD,SAASiB,0BAAT,CAAoCvE,OAApC,EAA6CC,UAA7C,EAAyDO,UAAzD,EAAqEhF,IAArE,EAA2E2E,OAA3E,EAAoFO,OAApF,EAA6F8D,UAA7F,EAAyGlB,mBAAzG,EAA8H;AAC1H,MAAImB,GAAG,GAAGpE,UAAU,CAACL,OAAD,EAAUC,UAAV,EAAsBO,UAAtB,EAAkChF,IAAlC,EAAwC2E,OAAxC,EAAiDO,OAAjD,EAA0D4C,mBAA1D,CAApB;;AACA,MAAImB,GAAG,IAAI,CAACD,UAAZ,EAAwB;AACpB;AACA;AACA;AACA,WAAOC,GAAP;AACH;;AACD,MAAIzE,OAAO,CAACzE,MAAR,IAAkB,CAAtB,EAAyB;AACrB;AACA;AACA;AACA;AACA,QAAImJ,KAAK,GAAG9D,IAAI,CAAC+D,GAAL,CAAS,CAAT,EAAY3E,OAAO,CAACzE,MAAR,GAAiB,CAA7B,CAAZ;;AACA,SAAK,IAAIqJ,gBAAgB,GAAGpE,UAAU,GAAG,CAAzC,EAA4CoE,gBAAgB,GAAGF,KAA/D,EAAsEE,gBAAgB,EAAtF,EAA0F;AACtF,UAAIC,UAAU,GAAGC,mBAAmB,CAAC9E,OAAD,EAAU4E,gBAAV,CAApC;;AACA,UAAIC,UAAJ,EAAgB;AACZ,YAAIE,SAAS,GAAG1E,UAAU,CAACwE,UAAD,EAAaA,UAAU,CAACpI,WAAX,EAAb,EAAuC+D,UAAvC,EAAmDhF,IAAnD,EAAyD2E,OAAzD,EAAkEO,OAAlE,EAA2E4C,mBAA3E,CAA1B;;AACA,YAAIyB,SAAJ,EAAe;AACXA,UAAAA,SAAS,CAAC,CAAD,CAAT,IAAgB,CAAhB,CADW,CACQ;;AACnB,cAAI,CAACN,GAAD,IAAQM,SAAS,CAAC,CAAD,CAAT,GAAeN,GAAG,CAAC,CAAD,CAA9B,EAAmC;AAC/BA,YAAAA,GAAG,GAAGM,SAAN;AACH;AACJ;AACJ;AACJ;AACJ;;AACD,SAAON,GAAP;AACH;;AACD,SAASK,mBAAT,CAA6B9E,OAA7B,EAAsCQ,UAAtC,EAAkD;AAC9C,MAAIA,UAAU,GAAG,CAAb,IAAkBR,OAAO,CAACzE,MAA9B,EAAsC;AAClC,WAAOS,SAAP;AACH;;AACD,MAAIgJ,KAAK,GAAGhF,OAAO,CAACQ,UAAD,CAAnB;AACA,MAAIyE,KAAK,GAAGjF,OAAO,CAACQ,UAAU,GAAG,CAAd,CAAnB;;AACA,MAAIwE,KAAK,KAAKC,KAAd,EAAqB;AACjB,WAAOjJ,SAAP;AACH;;AACD,SAAOgE,OAAO,CAACyB,KAAR,CAAc,CAAd,EAAiBjB,UAAjB,IACDyE,KADC,GAEDD,KAFC,GAGDhF,OAAO,CAACyB,KAAR,CAAcjB,UAAU,GAAG,CAA3B,CAHN;AAIH,C,CACD","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LRUCache } from './map.js';\r\nimport * as strings from './strings.js';\r\n// Combined filters\r\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\r\nexport function or() {\r\n    var filter = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        filter[_i] = arguments[_i];\r\n    }\r\n    return function (word, wordToMatchAgainst) {\r\n        for (var i = 0, len = filter.length; i < len; i++) {\r\n            var match = filter[i](word, wordToMatchAgainst);\r\n            if (match) {\r\n                return match;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n}\r\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\r\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\r\n        return null;\r\n    }\r\n    var matches;\r\n    if (ignoreCase) {\r\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\r\n    }\r\n    else {\r\n        matches = wordToMatchAgainst.indexOf(word) === 0;\r\n    }\r\n    if (!matches) {\r\n        return null;\r\n    }\r\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n}\r\n// Contiguous Substring\r\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n    var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n    if (index === -1) {\r\n        return null;\r\n    }\r\n    return [{ start: index, end: index + word.length }];\r\n}\r\n// Substring\r\nexport function matchesSubString(word, wordToMatchAgainst) {\r\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n}\r\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === wordToMatchAgainst.length) {\r\n        return null;\r\n    }\r\n    else {\r\n        if (word[i] === wordToMatchAgainst[j]) {\r\n            var result = null;\r\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                return join({ start: j, end: j + 1 }, result);\r\n            }\r\n            return null;\r\n        }\r\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n    }\r\n}\r\n// CamelCase\r\nfunction isLower(code) {\r\n    return 97 /* a */ <= code && code <= 122 /* z */;\r\n}\r\nexport function isUpper(code) {\r\n    return 65 /* A */ <= code && code <= 90 /* Z */;\r\n}\r\nfunction isNumber(code) {\r\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\r\n}\r\nfunction isWhitespace(code) {\r\n    return (code === 32 /* Space */\r\n        || code === 9 /* Tab */\r\n        || code === 10 /* LineFeed */\r\n        || code === 13 /* CarriageReturn */);\r\n}\r\nvar wordSeparators = new Set();\r\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\r\n    .split('')\r\n    .forEach(function (s) { return wordSeparators.add(s.charCodeAt(0)); });\r\nfunction isAlphanumeric(code) {\r\n    return isLower(code) || isUpper(code) || isNumber(code);\r\n}\r\nfunction join(head, tail) {\r\n    if (tail.length === 0) {\r\n        tail = [head];\r\n    }\r\n    else if (head.end === tail[0].start) {\r\n        tail[0].start = head.start;\r\n    }\r\n    else {\r\n        tail.unshift(head);\r\n    }\r\n    return tail;\r\n}\r\nfunction nextAnchor(camelCaseWord, start) {\r\n    for (var i = start; i < camelCaseWord.length; i++) {\r\n        var c = camelCaseWord.charCodeAt(i);\r\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return camelCaseWord.length;\r\n}\r\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === camelCaseWord.length) {\r\n        return null;\r\n    }\r\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n        return null;\r\n    }\r\n    else {\r\n        var result = null;\r\n        var nextUpperIndex = j + 1;\r\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n            nextUpperIndex++;\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camelCaseWords.\r\nfunction analyzeCamelCaseWord(word) {\r\n    var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n    for (var i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isAlphanumeric(code)) {\r\n            alpha++;\r\n        }\r\n        if (isNumber(code)) {\r\n            numeric++;\r\n        }\r\n    }\r\n    var upperPercent = upper / word.length;\r\n    var lowerPercent = lower / word.length;\r\n    var alphaPercent = alpha / word.length;\r\n    var numericPercent = numeric / word.length;\r\n    return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };\r\n}\r\nfunction isUpperCaseWord(analysis) {\r\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;\r\n    return lowerPercent === 0 && upperPercent > 0.6;\r\n}\r\nfunction isCamelCaseWord(analysis) {\r\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;\r\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camel case patterns.\r\nfunction isCamelCasePattern(word) {\r\n    var upper = 0, lower = 0, code = 0, whitespace = 0;\r\n    for (var i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isWhitespace(code)) {\r\n            whitespace++;\r\n        }\r\n    }\r\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n        return word.length <= 30;\r\n    }\r\n    else {\r\n        return upper <= 5;\r\n    }\r\n}\r\nexport function matchesCamelCase(word, camelCaseWord) {\r\n    if (!camelCaseWord) {\r\n        return null;\r\n    }\r\n    camelCaseWord = camelCaseWord.trim();\r\n    if (camelCaseWord.length === 0) {\r\n        return null;\r\n    }\r\n    if (!isCamelCasePattern(word)) {\r\n        return null;\r\n    }\r\n    if (camelCaseWord.length > 60) {\r\n        return null;\r\n    }\r\n    var analysis = analyzeCamelCaseWord(camelCaseWord);\r\n    if (!isCamelCaseWord(analysis)) {\r\n        if (!isUpperCaseWord(analysis)) {\r\n            return null;\r\n        }\r\n        camelCaseWord = camelCaseWord.toLowerCase();\r\n    }\r\n    var result = null;\r\n    var i = 0;\r\n    word = word.toLowerCase();\r\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\r\n        i = nextAnchor(camelCaseWord, i + 1);\r\n    }\r\n    return result;\r\n}\r\n// Fuzzy\r\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\r\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\r\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\r\n    if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\r\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n        return null; // return early for invalid input\r\n    }\r\n    // Form RegExp for wildcard matches\r\n    var regexp = fuzzyRegExpCache.get(word);\r\n    if (!regexp) {\r\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n        fuzzyRegExpCache.set(word, regexp);\r\n    }\r\n    // RegExp Filter\r\n    var match = regexp.exec(wordToMatchAgainst);\r\n    if (match) {\r\n        return [{ start: match.index, end: match.index + match[0].length }];\r\n    }\r\n    // Default Filter\r\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n}\r\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\r\n    var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\r\n    if (result) {\r\n        return result;\r\n    }\r\n    var matches = 0;\r\n    var score = 0;\r\n    var idx = _wordPos;\r\n    for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\r\n        var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\r\n        if (wordPos >= 0) {\r\n            score += 1;\r\n            matches += Math.pow(2, wordPos);\r\n            idx = wordPos + 1;\r\n        }\r\n        else if (matches !== 0) {\r\n            // once we have started matching things\r\n            // we need to match the remaining pattern\r\n            // characters\r\n            break;\r\n        }\r\n    }\r\n    return [score, matches, _wordPos];\r\n}\r\n//#region --- fuzzyScore ---\r\nexport function createMatches(score) {\r\n    if (typeof score === 'undefined') {\r\n        return [];\r\n    }\r\n    var matches = score[1].toString(2);\r\n    var wordStart = score[2];\r\n    var res = [];\r\n    for (var pos = wordStart; pos < _maxLen; pos++) {\r\n        if (matches[matches.length - (pos + 1)] === '1') {\r\n            var last = res[res.length - 1];\r\n            if (last && last.end === pos) {\r\n                last.end = pos + 1;\r\n            }\r\n            else {\r\n                res.push({ start: pos, end: pos + 1 });\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\nvar _maxLen = 128;\r\nfunction initTable() {\r\n    var table = [];\r\n    var row = [0];\r\n    for (var i = 1; i <= _maxLen; i++) {\r\n        row.push(-i);\r\n    }\r\n    for (var i = 0; i <= _maxLen; i++) {\r\n        var thisRow = row.slice(0);\r\n        thisRow[0] = -i;\r\n        table.push(thisRow);\r\n    }\r\n    return table;\r\n}\r\nvar _table = initTable();\r\nvar _scores = initTable();\r\nvar _arrows = initTable();\r\nvar _debug = false;\r\nfunction printTable(table, pattern, patternLen, word, wordLen) {\r\n    function pad(s, n, pad) {\r\n        if (pad === void 0) { pad = ' '; }\r\n        while (s.length < n) {\r\n            s = pad + s;\r\n        }\r\n        return s;\r\n    }\r\n    var ret = \" |   |\" + word.split('').map(function (c) { return pad(c, 3); }).join('|') + \"\\n\";\r\n    for (var i = 0; i <= patternLen; i++) {\r\n        if (i === 0) {\r\n            ret += ' |';\r\n        }\r\n        else {\r\n            ret += pattern[i - 1] + \"|\";\r\n        }\r\n        ret += table[i].slice(0, wordLen + 1).map(function (n) { return pad(n.toString(), 3); }).join('|') + '\\n';\r\n    }\r\n    return ret;\r\n}\r\nfunction printTables(pattern, patternStart, word, wordStart) {\r\n    pattern = pattern.substr(patternStart);\r\n    word = word.substr(wordStart);\r\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_scores, pattern, pattern.length, word, word.length));\r\n}\r\nfunction isSeparatorAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    var code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 95 /* Underline */:\r\n        case 45 /* Dash */:\r\n        case 46 /* Period */:\r\n        case 32 /* Space */:\r\n        case 47 /* Slash */:\r\n        case 92 /* Backslash */:\r\n        case 39 /* SingleQuote */:\r\n        case 34 /* DoubleQuote */:\r\n        case 58 /* Colon */:\r\n        case 36 /* DollarSign */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isWhitespaceAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    var code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 32 /* Space */:\r\n        case 9 /* Tab */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isUpperCaseAtPos(pos, word, wordLow) {\r\n    return word[pos] !== wordLow[pos];\r\n}\r\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\r\n    while (patternPos < patternLen && wordPos < wordLen) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            patternPos += 1;\r\n        }\r\n        wordPos += 1;\r\n    }\r\n    return patternPos === patternLen; // pattern must be exhausted\r\n}\r\nexport var FuzzyScore;\r\n(function (FuzzyScore) {\r\n    /**\r\n     * No matches and value `-100`\r\n     */\r\n    FuzzyScore.Default = Object.freeze([-100, 0, 0]);\r\n    function isDefault(score) {\r\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\r\n    }\r\n    FuzzyScore.isDefault = isDefault;\r\n})(FuzzyScore || (FuzzyScore = {}));\r\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\r\n    var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\r\n    var wordLen = word.length > _maxLen ? _maxLen : word.length;\r\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\r\n        return undefined;\r\n    }\r\n    // Run a simple check if the characters of pattern occur\r\n    // (in order) at all in word. If that isn't the case we\r\n    // stop because no match will be possible\r\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\r\n        return undefined;\r\n    }\r\n    var row = 1;\r\n    var column = 1;\r\n    var patternPos = patternStart;\r\n    var wordPos = wordStart;\r\n    // There will be a match, fill in tables\r\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\r\n        for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\r\n            var score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\r\n            _scores[row][column] = score;\r\n            var diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\r\n            var top_1 = _table[row - 1][column] + -1;\r\n            var left = _table[row][column - 1] + -1;\r\n            if (left >= top_1) {\r\n                // left or diag\r\n                if (left > diag) {\r\n                    _table[row][column] = left;\r\n                    _arrows[row][column] = 4 /* Left */;\r\n                }\r\n                else if (left === diag) {\r\n                    _table[row][column] = left;\r\n                    _arrows[row][column] = 4 /* Left */ | 2 /* Diag */;\r\n                }\r\n                else {\r\n                    _table[row][column] = diag;\r\n                    _arrows[row][column] = 2 /* Diag */;\r\n                }\r\n            }\r\n            else {\r\n                // top or diag\r\n                if (top_1 > diag) {\r\n                    _table[row][column] = top_1;\r\n                    _arrows[row][column] = 1 /* Top */;\r\n                }\r\n                else if (top_1 === diag) {\r\n                    _table[row][column] = top_1;\r\n                    _arrows[row][column] = 1 /* Top */ | 2 /* Diag */;\r\n                }\r\n                else {\r\n                    _table[row][column] = diag;\r\n                    _arrows[row][column] = 2 /* Diag */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (_debug) {\r\n        printTables(pattern, patternStart, word, wordStart);\r\n    }\r\n    _matchesCount = 0;\r\n    _topScore = -100;\r\n    _wordStart = wordStart;\r\n    _firstMatchCanBeWeak = firstMatchCanBeWeak;\r\n    _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\r\n    if (_matchesCount === 0) {\r\n        return undefined;\r\n    }\r\n    return [_topScore, _topMatch2, wordStart];\r\n}\r\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\r\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\r\n        return -1;\r\n    }\r\n    if (wordPos === (patternPos - patternStart)) {\r\n        // common prefix: `foobar <-> foobaz`\r\n        //                            ^^^^^\r\n        if (pattern[patternPos] === word[wordPos]) {\r\n            return 7;\r\n        }\r\n        else {\r\n            return 5;\r\n        }\r\n    }\r\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\r\n        // hitting upper-case: `foo <-> forOthers`\r\n        //                              ^^ ^\r\n        if (pattern[patternPos] === word[wordPos]) {\r\n            return 7;\r\n        }\r\n        else {\r\n            return 5;\r\n        }\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\r\n        // hitting a separator: `. <-> foo.bar`\r\n        //                                ^\r\n        return 5;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\r\n        // post separator: `foo <-> bar_foo`\r\n        //                              ^^^\r\n        return 5;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\nvar _matchesCount = 0;\r\nvar _topMatch2 = 0;\r\nvar _topScore = 0;\r\nvar _wordStart = 0;\r\nvar _firstMatchCanBeWeak = false;\r\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\r\n    if (_matchesCount >= 10 || total < -25) {\r\n        // stop when having already 10 results, or\r\n        // when a potential alignment as already 5 gaps\r\n        return;\r\n    }\r\n    var simpleMatchCount = 0;\r\n    while (row > 0 && column > 0) {\r\n        var score = _scores[row][column];\r\n        var arrow = _arrows[row][column];\r\n        if (arrow === 4 /* Left */) {\r\n            // left -> no match, skip a word character\r\n            column -= 1;\r\n            if (lastMatched) {\r\n                total -= 5; // new gap penalty\r\n            }\r\n            else if (matches !== 0) {\r\n                total -= 1; // gap penalty after first match\r\n            }\r\n            lastMatched = false;\r\n            simpleMatchCount = 0;\r\n        }\r\n        else if (arrow & 2 /* Diag */) {\r\n            if (arrow & 4 /* Left */) {\r\n                // left\r\n                _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\r\n                matches, lastMatched);\r\n            }\r\n            // diag\r\n            total += score;\r\n            row -= 1;\r\n            column -= 1;\r\n            lastMatched = true;\r\n            // match -> set a 1 at the word pos\r\n            matches += Math.pow(2, (column + _wordStart));\r\n            // count simple matches and boost a row of\r\n            // simple matches when they yield in a\r\n            // strong match.\r\n            if (score === 1) {\r\n                simpleMatchCount += 1;\r\n                if (row === 0 && !_firstMatchCanBeWeak) {\r\n                    // when the first match is a weak\r\n                    // match we discard it\r\n                    return undefined;\r\n                }\r\n            }\r\n            else {\r\n                // boost\r\n                total += 1 + (simpleMatchCount * (score - 1));\r\n                simpleMatchCount = 0;\r\n            }\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    total -= column >= 3 ? 9 : column * 3; // late start penalty\r\n    // dynamically keep track of the current top score\r\n    // and insert the current best score at head, the rest at tail\r\n    _matchesCount += 1;\r\n    if (total > _topScore) {\r\n        _topScore = total;\r\n        _topMatch2 = matches;\r\n    }\r\n}\r\n//#endregion\r\n//#region --- graceful ---\r\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\r\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\r\n}\r\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\r\n    var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n    if (top && !aggressive) {\r\n        // when using the original pattern yield a result we`\r\n        // return it unless we are aggressive and try to find\r\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\r\n        return top;\r\n    }\r\n    if (pattern.length >= 3) {\r\n        // When the pattern is long enough then try a few (max 7)\r\n        // permutations of the pattern to find a better match. The\r\n        // permutations only swap neighbouring characters, e.g\r\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\r\n        var tries = Math.min(7, pattern.length - 1);\r\n        for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\r\n            var newPattern = nextTypoPermutation(pattern, movingPatternPos);\r\n            if (newPattern) {\r\n                var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n                if (candidate) {\r\n                    candidate[0] -= 3; // permutation penalty\r\n                    if (!top || candidate[0] > top[0]) {\r\n                        top = candidate;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return top;\r\n}\r\nfunction nextTypoPermutation(pattern, patternPos) {\r\n    if (patternPos + 1 >= pattern.length) {\r\n        return undefined;\r\n    }\r\n    var swap1 = pattern[patternPos];\r\n    var swap2 = pattern[patternPos + 1];\r\n    if (swap1 === swap2) {\r\n        return undefined;\r\n    }\r\n    return pattern.slice(0, patternPos)\r\n        + swap2\r\n        + swap1\r\n        + pattern.slice(patternPos + 2);\r\n}\r\n//#endregion\r\n"]},"metadata":{},"sourceType":"module"}