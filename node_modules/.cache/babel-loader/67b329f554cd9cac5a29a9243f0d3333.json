{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch } from '../model.js';\nvar LIMIT_FIND_COUNT = 999;\n\nvar SearchParams =\n/** @class */\nfunction () {\n  function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n\n  SearchParams.prototype.parseSearchRequest = function () {\n    if (this.searchString === '') {\n      return null;\n    } // Try to create a RegExp out of the params\n\n\n    var multiline;\n\n    if (this.isRegex) {\n      multiline = isMultilineRegexSource(this.searchString);\n    } else {\n      multiline = this.searchString.indexOf('\\n') >= 0;\n    }\n\n    var regex = null;\n\n    try {\n      regex = strings.createRegExp(this.searchString, this.isRegex, {\n        matchCase: this.matchCase,\n        wholeWord: false,\n        multiline: multiline,\n        global: true,\n        unicode: true\n      });\n    } catch (err) {\n      return null;\n    }\n\n    if (!regex) {\n      return null;\n    }\n\n    var canUseSimpleSearch = !this.isRegex && !multiline;\n\n    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n      // casing might make a difference\n      canUseSimpleSearch = this.matchCase;\n    }\n\n    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n  };\n\n  return SearchParams;\n}();\n\nexport { SearchParams };\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n\n  for (var i = 0, len = searchString.length; i < len; i++) {\n    var chCode = searchString.charCodeAt(i);\n\n    if (chCode === 92\n    /* Backslash */\n    ) {\n        // move to next char\n        i++;\n\n        if (i >= len) {\n          // string ends with a \\\n          break;\n        }\n\n        var nextChCode = searchString.charCodeAt(i);\n\n        if (nextChCode === 110\n        /* n */\n        || nextChCode === 114\n        /* r */\n        || nextChCode === 87\n        /* W */\n        || nextChCode === 119\n        /* w */\n        ) {\n            return true;\n          }\n      }\n  }\n\n  return false;\n}\n\nvar SearchData =\n/** @class */\nfunction () {\n  function SearchData(regex, wordSeparators, simpleSearch) {\n    this.regex = regex;\n    this.wordSeparators = wordSeparators;\n    this.simpleSearch = simpleSearch;\n  }\n\n  return SearchData;\n}();\n\nexport { SearchData };\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n\n  var matches = [];\n\n  for (var i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n\n  return new FindMatch(range, matches);\n}\n\nvar LineFeedCounter =\n/** @class */\nfunction () {\n  function LineFeedCounter(text) {\n    var lineFeedsOffsets = [];\n    var lineFeedsOffsetsLen = 0;\n\n    for (var i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10\n      /* LineFeed */\n      ) {\n          lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n        }\n    }\n\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n\n  LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\n    var lineFeedsOffsets = this._lineFeedsOffsets;\n    var min = 0;\n    var max = lineFeedsOffsets.length - 1;\n\n    if (max === -1) {\n      // no line feeds\n      return 0;\n    }\n\n    if (offset <= lineFeedsOffsets[0]) {\n      // before first line feed\n      return 0;\n    }\n\n    while (min < max) {\n      var mid = min + ((max - min) / 2 >> 0);\n\n      if (lineFeedsOffsets[mid] >= offset) {\n        max = mid - 1;\n      } else {\n        if (lineFeedsOffsets[mid + 1] >= offset) {\n          // bingo!\n          min = mid;\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n    }\n\n    return min + 1;\n  };\n\n  return LineFeedCounter;\n}();\n\nvar TextModelSearch =\n/** @class */\nfunction () {\n  function TextModelSearch() {}\n\n  TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return [];\n    }\n\n    if (searchData.regex.multiline) {\n      return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n    }\n\n    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\r\n   * Multiline search always executes on the lines concatenated with \\n.\r\n   * We must therefore compensate for the count of \\n in case the model is CRLF\r\n   */\n\n\n  TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\n    var startOffset;\n    var lineFeedCountBeforeMatch = 0;\n\n    if (lfCounter) {\n      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      startOffset = deltaOffset + matchIndex;\n    }\n\n    var endOffset;\n\n    if (lfCounter) {\n      var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n      var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n      endOffset = startOffset + match0.length + lineFeedCountInMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      endOffset = startOffset + match0.length;\n    }\n\n    var startPosition = model.getPositionAt(startOffset);\n    var endPosition = model.getPositionAt(endOffset);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n\n  TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\n    var deltaOffset = model.getOffsetAt(searchRange.getStartPosition()); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    var text = model.getValueInRange(searchRange, 1\n    /* LF */\n    );\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    var result = [];\n    var counter = 0;\n    var m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\n      if (counter >= limitResultCount) {\n        return result;\n      }\n    }\n\n    return result;\n  };\n\n  TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0; // Early case for a search range that starts & stops on the same line number\n\n    if (searchRange.startLineNumber === searchRange.endLineNumber) {\n      var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    } // Collect results from first line\n\n\n    var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount); // Collect results from middle lines\n\n    for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n      resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    } // Collect results from last line\n\n\n    if (resultLen < limitResultCount) {\n      var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    }\n\n    return result;\n  };\n\n  TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  };\n\n  TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n\n  TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var searchTextStart = new Position(searchStart.lineNumber, 1);\n    var deltaOffset = model.getOffsetAt(searchTextStart);\n    var lineCount = model.getLineCount(); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1\n    /* LF */\n    );\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    searcher.reset(searchStart.column - 1);\n    var m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n    }\n\n    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n      // Try again from the top\n      return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber; // Look in first line\n\n    var text = model.getLineContent(startLineNumber);\n\n    var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (startLineNumber + i - 1) % lineCount;\n      var text_3 = model.getLineContent(lineIndex + 1);\n\n      var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\n\n      if (r_1) {\n        return r_1;\n      }\n    }\n\n    return null;\n  };\n\n  TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\n    // Set regex to search from column\n    searcher.reset(fromColumn - 1);\n    var m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n\n  TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\n    if (matches.length > 0) {\n      return matches[matches.length - 1];\n    }\n\n    var lineCount = model.getLineCount();\n\n    if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n      // Try again with all content\n      return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber; // Look in first line\n\n    var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\n    var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n      var text_4 = model.getLineContent(lineIndex + 1);\n\n      var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\n\n      if (r_2) {\n        return r_2;\n      }\n    }\n\n    return null;\n  };\n\n  TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\n    var bestResult = null;\n    var m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return bestResult;\n  };\n\n  return TextModelSearch;\n}();\n\nexport { TextModelSearch };\n\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n\n  var charBefore = text.charCodeAt(matchStartIndex - 1);\n\n  if (wordSeparators.get(charBefore) !== 0\n  /* Regular */\n  ) {\n      // The character before the match is a word separator\n      return true;\n    }\n\n  if (charBefore === 13\n  /* CarriageReturn */\n  || charBefore === 10\n  /* LineFeed */\n  ) {\n      // The character before the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var firstCharInMatch = text.charCodeAt(matchStartIndex);\n\n    if (wordSeparators.get(firstCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The first character inside the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n\n  var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\n  if (wordSeparators.get(charAfter) !== 0\n  /* Regular */\n  ) {\n      // The character after the match is a word separator\n      return true;\n    }\n\n  if (charAfter === 13\n  /* CarriageReturn */\n  || charAfter === 10\n  /* LineFeed */\n  ) {\n      // The character after the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\n    if (wordSeparators.get(lastCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The last character in the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\n\nvar Searcher =\n/** @class */\nfunction () {\n  function Searcher(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n\n  Searcher.prototype.reset = function (lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  };\n\n  Searcher.prototype.next = function (text) {\n    var textLength = text.length;\n    var m;\n\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        // Reached the end of the line\n        return null;\n      }\n\n      m = this._searchRegex.exec(text);\n\n      if (!m) {\n        return null;\n      }\n\n      var matchStartIndex = m.index;\n      var matchLength = m[0].length;\n\n      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n          // we attempt to recover from that by advancing by one\n          this._searchRegex.lastIndex += 1;\n          continue;\n        } // Exit early if the regex matches the same range twice\n\n\n        return null;\n      }\n\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n\n    return null;\n  };\n\n  return Searcher;\n}();\n\nexport { Searcher };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"names":["strings","getMapForWordSeparators","Position","Range","FindMatch","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","wordSeparators","prototype","parseSearchRequest","multiline","isMultilineRegexSource","indexOf","regex","createRegExp","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","length","i","len","chCode","charCodeAt","nextChCode","simpleSearch","createFindMatch","range","rawMatches","captureMatches","matches","LineFeedCounter","text","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","offset","min","max","mid","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","lineFeedCountBeforeMatch","endOffset","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","lineNumber","column","searcher","getOffsetAt","getStartPosition","getValueInRange","getEOL","result","counter","m","reset","next","index","resultLen","startLineNumber","endLineNumber","text_1","getLineContent","substring","startColumn","endColumn","_findMatchesInLine","text_2","searchStringLen","textLength","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","lineIndex","text_3","r_1","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","text_4","r_2","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { FindMatch } from '../model.js';\r\nvar LIMIT_FIND_COUNT = 999;\r\nvar SearchParams = /** @class */ (function () {\r\n    function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\r\n        this.searchString = searchString;\r\n        this.isRegex = isRegex;\r\n        this.matchCase = matchCase;\r\n        this.wordSeparators = wordSeparators;\r\n    }\r\n    SearchParams.prototype.parseSearchRequest = function () {\r\n        if (this.searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        var multiline;\r\n        if (this.isRegex) {\r\n            multiline = isMultilineRegexSource(this.searchString);\r\n        }\r\n        else {\r\n            multiline = (this.searchString.indexOf('\\n') >= 0);\r\n        }\r\n        var regex = null;\r\n        try {\r\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\r\n                matchCase: this.matchCase,\r\n                wholeWord: false,\r\n                multiline: multiline,\r\n                global: true,\r\n                unicode: true\r\n            });\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        if (!regex) {\r\n            return null;\r\n        }\r\n        var canUseSimpleSearch = (!this.isRegex && !multiline);\r\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\r\n            // casing might make a difference\r\n            canUseSimpleSearch = this.matchCase;\r\n        }\r\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\r\n    };\r\n    return SearchParams;\r\n}());\r\nexport { SearchParams };\r\nexport function isMultilineRegexSource(searchString) {\r\n    if (!searchString || searchString.length === 0) {\r\n        return false;\r\n    }\r\n    for (var i = 0, len = searchString.length; i < len; i++) {\r\n        var chCode = searchString.charCodeAt(i);\r\n        if (chCode === 92 /* Backslash */) {\r\n            // move to next char\r\n            i++;\r\n            if (i >= len) {\r\n                // string ends with a \\\r\n                break;\r\n            }\r\n            var nextChCode = searchString.charCodeAt(i);\r\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nvar SearchData = /** @class */ (function () {\r\n    function SearchData(regex, wordSeparators, simpleSearch) {\r\n        this.regex = regex;\r\n        this.wordSeparators = wordSeparators;\r\n        this.simpleSearch = simpleSearch;\r\n    }\r\n    return SearchData;\r\n}());\r\nexport { SearchData };\r\nexport function createFindMatch(range, rawMatches, captureMatches) {\r\n    if (!captureMatches) {\r\n        return new FindMatch(range, null);\r\n    }\r\n    var matches = [];\r\n    for (var i = 0, len = rawMatches.length; i < len; i++) {\r\n        matches[i] = rawMatches[i];\r\n    }\r\n    return new FindMatch(range, matches);\r\n}\r\nvar LineFeedCounter = /** @class */ (function () {\r\n    function LineFeedCounter(text) {\r\n        var lineFeedsOffsets = [];\r\n        var lineFeedsOffsetsLen = 0;\r\n        for (var i = 0, textLen = text.length; i < textLen; i++) {\r\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\r\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\r\n            }\r\n        }\r\n        this._lineFeedsOffsets = lineFeedsOffsets;\r\n    }\r\n    LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\r\n        var lineFeedsOffsets = this._lineFeedsOffsets;\r\n        var min = 0;\r\n        var max = lineFeedsOffsets.length - 1;\r\n        if (max === -1) {\r\n            // no line feeds\r\n            return 0;\r\n        }\r\n        if (offset <= lineFeedsOffsets[0]) {\r\n            // before first line feed\r\n            return 0;\r\n        }\r\n        while (min < max) {\r\n            var mid = min + ((max - min) / 2 >> 0);\r\n            if (lineFeedsOffsets[mid] >= offset) {\r\n                max = mid - 1;\r\n            }\r\n            else {\r\n                if (lineFeedsOffsets[mid + 1] >= offset) {\r\n                    // bingo!\r\n                    min = mid;\r\n                    max = mid;\r\n                }\r\n                else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n        }\r\n        return min + 1;\r\n    };\r\n    return LineFeedCounter;\r\n}());\r\nvar TextModelSearch = /** @class */ (function () {\r\n    function TextModelSearch() {\r\n    }\r\n    TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return [];\r\n        }\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\r\n        }\r\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\r\n    TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\r\n        var startOffset;\r\n        var lineFeedCountBeforeMatch = 0;\r\n        if (lfCounter) {\r\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\r\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            startOffset = deltaOffset + matchIndex;\r\n        }\r\n        var endOffset;\r\n        if (lfCounter) {\r\n            var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\r\n            var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\r\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            endOffset = startOffset + match0.length;\r\n        }\r\n        var startPosition = model.getPositionAt(startOffset);\r\n        var endPosition = model.getPositionAt(endOffset);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    };\r\n    TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\r\n        var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(searchRange, 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        var result = [];\r\n        var counter = 0;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n            if (counter >= limitResultCount) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\r\n        var result = [];\r\n        var resultLen = 0;\r\n        // Early case for a search range that starts & stops on the same line number\r\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\r\n            var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        // Collect results from first line\r\n        var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\r\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n        // Collect results from middle lines\r\n        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\r\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        // Collect results from last line\r\n        if (resultLen < limitResultCount) {\r\n            var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        var wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            var searchString = searchData.simpleSearch;\r\n            var searchStringLen = searchString.length;\r\n            var textLength = text.length;\r\n            var lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var searchTextStart = new Position(searchStart.lineNumber, 1);\r\n        var deltaOffset = model.getOffsetAt(searchTextStart);\r\n        var lineCount = model.getLineCount();\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        searcher.reset(searchStart.column - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n        }\r\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\r\n            // Try again from the top\r\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber);\r\n        var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (startLineNumber + i - 1) % lineCount;\r\n            var text_3 = model.getLineContent(lineIndex + 1);\r\n            var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\r\n            if (r_1) {\r\n                return r_1;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\r\n        // Set regex to search from column\r\n        searcher.reset(fromColumn - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\r\n        if (matches.length > 0) {\r\n            return matches[matches.length - 1];\r\n        }\r\n        var lineCount = model.getLineCount();\r\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\r\n            // Try again with all content\r\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\r\n        var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\r\n            var text_4 = model.getLineContent(lineIndex + 1);\r\n            var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\r\n            if (r_2) {\r\n                return r_2;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\r\n        var bestResult = null;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return bestResult;\r\n    };\r\n    return TextModelSearch;\r\n}());\r\nexport { TextModelSearch };\r\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex === 0) {\r\n        // Match starts at start of string\r\n        return true;\r\n    }\r\n    var charBefore = text.charCodeAt(matchStartIndex - 1);\r\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\r\n        // The character before the match is a word separator\r\n        return true;\r\n    }\r\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\r\n        // The character before the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var firstCharInMatch = text.charCodeAt(matchStartIndex);\r\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\r\n            // The first character inside the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex + matchLength === textLength) {\r\n        // Match ends at end of string\r\n        return true;\r\n    }\r\n    var charAfter = text.charCodeAt(matchStartIndex + matchLength);\r\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\r\n        // The character after the match is a word separator\r\n        return true;\r\n    }\r\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\r\n        // The character after the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\r\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\r\n            // The last character in the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\r\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\r\n}\r\nvar Searcher = /** @class */ (function () {\r\n    function Searcher(wordSeparators, searchRegex) {\r\n        this._wordSeparators = wordSeparators;\r\n        this._searchRegex = searchRegex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    Searcher.prototype.reset = function (lastIndex) {\r\n        this._searchRegex.lastIndex = lastIndex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    };\r\n    Searcher.prototype.next = function (text) {\r\n        var textLength = text.length;\r\n        var m;\r\n        do {\r\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\r\n                // Reached the end of the line\r\n                return null;\r\n            }\r\n            m = this._searchRegex.exec(text);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            var matchStartIndex = m.index;\r\n            var matchLength = m[0].length;\r\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\r\n                if (matchLength === 0) {\r\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\r\n                    // we attempt to recover from that by advancing by one\r\n                    this._searchRegex.lastIndex += 1;\r\n                    continue;\r\n                }\r\n                // Exit early if the regex matches the same range twice\r\n                return null;\r\n            }\r\n            this._prevMatchStartIndex = matchStartIndex;\r\n            this._prevMatchLength = matchLength;\r\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\r\n                return m;\r\n            }\r\n        } while (m);\r\n        return null;\r\n    };\r\n    return Searcher;\r\n}());\r\nexport { Searcher };\r\n"]},"metadata":{},"sourceType":"module"}