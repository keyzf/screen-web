{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges.js';\nvar MAX_FOLDING_REGIONS = 5000;\nvar foldingContext = {};\nexport var ID_SYNTAX_PROVIDER = 'syntax';\n\nvar SyntaxRangeProvider =\n/** @class */\nfunction () {\n  function SyntaxRangeProvider(editorModel, providers, limit) {\n    if (limit === void 0) {\n      limit = MAX_FOLDING_REGIONS;\n    }\n\n    this.editorModel = editorModel;\n    this.providers = providers;\n    this.limit = limit;\n    this.id = ID_SYNTAX_PROVIDER;\n  }\n\n  SyntaxRangeProvider.prototype.compute = function (cancellationToken) {\n    var _this = this;\n\n    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(function (ranges) {\n      if (ranges) {\n        var res = sanitizeRanges(ranges, _this.limit);\n        return res;\n      }\n\n      return null;\n    });\n  };\n\n  SyntaxRangeProvider.prototype.dispose = function () {};\n\n  return SyntaxRangeProvider;\n}();\n\nexport { SyntaxRangeProvider };\n\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n  var rangeData = null;\n  var promises = providers.map(function (provider, i) {\n    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(function (ranges) {\n      if (cancellationToken.isCancellationRequested) {\n        return;\n      }\n\n      if (Array.isArray(ranges)) {\n        if (!Array.isArray(rangeData)) {\n          rangeData = [];\n        }\n\n        var nLines = model.getLineCount();\n\n        for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {\n          var r = ranges_1[_i];\n\n          if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n            rangeData.push({\n              start: r.start,\n              end: r.end,\n              rank: i,\n              kind: r.kind\n            });\n          }\n        }\n      }\n    }, onUnexpectedExternalError);\n  });\n  return Promise.all(promises).then(function (_) {\n    return rangeData;\n  });\n}\n\nvar RangesCollector =\n/** @class */\nfunction () {\n  function RangesCollector(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._nestingLevels = [];\n    this._nestingLevelCounts = [];\n    this._types = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  RangesCollector.prototype.add = function (startLineNumber, endLineNumber, type, nestingLevel) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    var index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._nestingLevels[index] = nestingLevel;\n    this._types[index] = type;\n    this._length++;\n\n    if (nestingLevel < 30) {\n      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n    }\n  };\n\n  RangesCollector.prototype.toIndentRanges = function () {\n    if (this._length <= this._foldingRangesLimit) {\n      var startIndexes = new Uint32Array(this._length);\n      var endIndexes = new Uint32Array(this._length);\n\n      for (var i = 0; i < this._length; i++) {\n        startIndexes[i] = this._startIndexes[i];\n        endIndexes[i] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, this._types);\n    } else {\n      var entries = 0;\n      var maxLevel = this._nestingLevelCounts.length;\n\n      for (var i = 0; i < this._nestingLevelCounts.length; i++) {\n        var n = this._nestingLevelCounts[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxLevel = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      var startIndexes = new Uint32Array(this._foldingRangesLimit);\n      var endIndexes = new Uint32Array(this._foldingRangesLimit);\n      var types = [];\n\n      for (var i = 0, k = 0; i < this._length; i++) {\n        var level = this._nestingLevels[i];\n\n        if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n          types[k] = this._types[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, types);\n    }\n  };\n\n  return RangesCollector;\n}();\n\nexport { RangesCollector };\nexport function sanitizeRanges(rangeData, limit) {\n  var sorted = rangeData.sort(function (d1, d2) {\n    var diff = d1.start - d2.start;\n\n    if (diff === 0) {\n      diff = d1.rank - d2.rank;\n    }\n\n    return diff;\n  });\n  var collector = new RangesCollector(limit);\n  var top = undefined;\n  var previous = [];\n\n  for (var _i = 0, sorted_1 = sorted; _i < sorted_1.length; _i++) {\n    var entry = sorted_1[_i];\n\n    if (!top) {\n      top = entry;\n      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n    } else {\n      if (entry.start > top.start) {\n        if (entry.end <= top.end) {\n          previous.push(top);\n          top = entry;\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        } else {\n          if (entry.start > top.end) {\n            do {\n              top = previous.pop();\n            } while (top && entry.start > top.end);\n\n            if (top) {\n              previous.push(top);\n            }\n\n            top = entry;\n          }\n\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n      }\n    }\n  }\n\n  return collector.toIndentRanges();\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js"],"names":["onUnexpectedExternalError","MAX_LINE_NUMBER","FoldingRegions","MAX_FOLDING_REGIONS","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","editorModel","providers","limit","id","prototype","compute","cancellationToken","_this","collectSyntaxRanges","then","ranges","res","sanitizeRanges","dispose","model","rangeData","promises","map","provider","i","Promise","resolve","provideFoldingRanges","isCancellationRequested","Array","isArray","nLines","getLineCount","_i","ranges_1","length","r","start","end","push","rank","kind","all","_","RangesCollector","foldingRangesLimit","_startIndexes","_endIndexes","_nestingLevels","_nestingLevelCounts","_types","_length","_foldingRangesLimit","add","startLineNumber","endLineNumber","type","nestingLevel","index","toIndentRanges","startIndexes","Uint32Array","endIndexes","entries","maxLevel","n","types","k","level","sorted","sort","d1","d2","diff","collector","top","undefined","previous","sorted_1","entry","value","pop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\r\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges.js';\r\nvar MAX_FOLDING_REGIONS = 5000;\r\nvar foldingContext = {};\r\nexport var ID_SYNTAX_PROVIDER = 'syntax';\r\nvar SyntaxRangeProvider = /** @class */ (function () {\r\n    function SyntaxRangeProvider(editorModel, providers, limit) {\r\n        if (limit === void 0) { limit = MAX_FOLDING_REGIONS; }\r\n        this.editorModel = editorModel;\r\n        this.providers = providers;\r\n        this.limit = limit;\r\n        this.id = ID_SYNTAX_PROVIDER;\r\n    }\r\n    SyntaxRangeProvider.prototype.compute = function (cancellationToken) {\r\n        var _this = this;\r\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(function (ranges) {\r\n            if (ranges) {\r\n                var res = sanitizeRanges(ranges, _this.limit);\r\n                return res;\r\n            }\r\n            return null;\r\n        });\r\n    };\r\n    SyntaxRangeProvider.prototype.dispose = function () {\r\n    };\r\n    return SyntaxRangeProvider;\r\n}());\r\nexport { SyntaxRangeProvider };\r\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\r\n    var rangeData = null;\r\n    var promises = providers.map(function (provider, i) {\r\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(function (ranges) {\r\n            if (cancellationToken.isCancellationRequested) {\r\n                return;\r\n            }\r\n            if (Array.isArray(ranges)) {\r\n                if (!Array.isArray(rangeData)) {\r\n                    rangeData = [];\r\n                }\r\n                var nLines = model.getLineCount();\r\n                for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {\r\n                    var r = ranges_1[_i];\r\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\r\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\r\n                    }\r\n                }\r\n            }\r\n        }, onUnexpectedExternalError);\r\n    });\r\n    return Promise.all(promises).then(function (_) {\r\n        return rangeData;\r\n    });\r\n}\r\nvar RangesCollector = /** @class */ (function () {\r\n    function RangesCollector(foldingRangesLimit) {\r\n        this._startIndexes = [];\r\n        this._endIndexes = [];\r\n        this._nestingLevels = [];\r\n        this._nestingLevelCounts = [];\r\n        this._types = [];\r\n        this._length = 0;\r\n        this._foldingRangesLimit = foldingRangesLimit;\r\n    }\r\n    RangesCollector.prototype.add = function (startLineNumber, endLineNumber, type, nestingLevel) {\r\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\r\n            return;\r\n        }\r\n        var index = this._length;\r\n        this._startIndexes[index] = startLineNumber;\r\n        this._endIndexes[index] = endLineNumber;\r\n        this._nestingLevels[index] = nestingLevel;\r\n        this._types[index] = type;\r\n        this._length++;\r\n        if (nestingLevel < 30) {\r\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\r\n        }\r\n    };\r\n    RangesCollector.prototype.toIndentRanges = function () {\r\n        if (this._length <= this._foldingRangesLimit) {\r\n            var startIndexes = new Uint32Array(this._length);\r\n            var endIndexes = new Uint32Array(this._length);\r\n            for (var i = 0; i < this._length; i++) {\r\n                startIndexes[i] = this._startIndexes[i];\r\n                endIndexes[i] = this._endIndexes[i];\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\r\n        }\r\n        else {\r\n            var entries = 0;\r\n            var maxLevel = this._nestingLevelCounts.length;\r\n            for (var i = 0; i < this._nestingLevelCounts.length; i++) {\r\n                var n = this._nestingLevelCounts[i];\r\n                if (n) {\r\n                    if (n + entries > this._foldingRangesLimit) {\r\n                        maxLevel = i;\r\n                        break;\r\n                    }\r\n                    entries += n;\r\n                }\r\n            }\r\n            var startIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            var endIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            var types = [];\r\n            for (var i = 0, k = 0; i < this._length; i++) {\r\n                var level = this._nestingLevels[i];\r\n                if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\r\n                    startIndexes[k] = this._startIndexes[i];\r\n                    endIndexes[k] = this._endIndexes[i];\r\n                    types[k] = this._types[i];\r\n                    k++;\r\n                }\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes, types);\r\n        }\r\n    };\r\n    return RangesCollector;\r\n}());\r\nexport { RangesCollector };\r\nexport function sanitizeRanges(rangeData, limit) {\r\n    var sorted = rangeData.sort(function (d1, d2) {\r\n        var diff = d1.start - d2.start;\r\n        if (diff === 0) {\r\n            diff = d1.rank - d2.rank;\r\n        }\r\n        return diff;\r\n    });\r\n    var collector = new RangesCollector(limit);\r\n    var top = undefined;\r\n    var previous = [];\r\n    for (var _i = 0, sorted_1 = sorted; _i < sorted_1.length; _i++) {\r\n        var entry = sorted_1[_i];\r\n        if (!top) {\r\n            top = entry;\r\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n        }\r\n        else {\r\n            if (entry.start > top.start) {\r\n                if (entry.end <= top.end) {\r\n                    previous.push(top);\r\n                    top = entry;\r\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n                }\r\n                else {\r\n                    if (entry.start > top.end) {\r\n                        do {\r\n                            top = previous.pop();\r\n                        } while (top && entry.start > top.end);\r\n                        if (top) {\r\n                            previous.push(top);\r\n                        }\r\n                        top = entry;\r\n                    }\r\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return collector.toIndentRanges();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}