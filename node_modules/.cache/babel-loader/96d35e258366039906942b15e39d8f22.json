{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\n\n\nimport * as process from './process.js';\nvar CHAR_UPPERCASE_A = 65;\n/* A */\n\nvar CHAR_LOWERCASE_A = 97;\n/* a */\n\nvar CHAR_UPPERCASE_Z = 90;\n/* Z */\n\nvar CHAR_LOWERCASE_Z = 122;\n/* z */\n\nvar CHAR_DOT = 46;\n/* . */\n\nvar CHAR_FORWARD_SLASH = 47;\n/* / */\n\nvar CHAR_BACKWARD_SLASH = 92;\n/* \\ */\n\nvar CHAR_COLON = 58;\n/* : */\n\nvar CHAR_QUESTION_MARK = 63;\n/* ? */\n\nvar ErrorInvalidArgType =\n/** @class */\nfunction (_super) {\n  __extends(ErrorInvalidArgType, _super);\n\n  function ErrorInvalidArgType(name, expected, actual) {\n    var _this = this; // determiner: 'must be' or 'must not be'\n\n\n    var determiner;\n\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    var msg = \"The \\\"\" + name + \"\\\" \" + type + \" \" + determiner + \" of type \" + expected;\n    msg += \". Received type \" + typeof actual;\n    _this = _super.call(this, msg) || this;\n    _this.code = 'ERR_INVALID_ARG_TYPE';\n    return _this;\n  }\n\n  return ErrorInvalidArgType;\n}(Error);\n\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n} // Resolves . and .. elements in a path with directory names\n\n\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {// NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf(separator);\n\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += separator + \"..\";\n          } else {\n            res = '..';\n          }\n\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += separator + path.slice(lastSlash + 1, i);\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n\n        lastSegmentLength = i - lastSlash - 1;\n      }\n\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n\n  if (!dir) {\n    return base;\n  }\n\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n\n  return dir + sep + base;\n}\n\nexport var win32 = {\n  // path.resolve([from ...], to)\n  resolve: function () {\n    var pathSegments = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = pathSegments.length - 1; i >= -1; i--) {\n      var path = void 0;\n\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd(); // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n\n        if (path === undefined || path.slice(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      validateString(path, 'path'); // Skip empty entries\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var device = '';\n      var isAbsolute = false;\n      var code = path.charCodeAt(0); // Try to match a root\n\n      if (len > 1) {\n        if (isPathSeparator(code)) {\n          // Possible UNC root\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n\n          if (isPathSeparator(path.charCodeAt(1))) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j; // Match 1 or more non-path separators\n\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              var firstPart = path.slice(last, j); // Matched!\n\n              last = j; // Match 1 or more path separators\n\n              for (; j < len; ++j) {\n                if (!isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j < len && j !== last) {\n                // Matched!\n                last = j; // Match 1 or more non-path separators\n\n                for (; j < len; ++j) {\n                  if (isPathSeparator(path.charCodeAt(j))) {\n                    break;\n                  }\n                }\n\n                if (j === len) {\n                  // We matched a UNC root only\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if (isWindowsDeviceRoot(code)) {\n          // Possible device root\n          if (path.charCodeAt(1) === CHAR_COLON) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n\n            if (len > 2) {\n              if (isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (isPathSeparator(code)) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n\n      if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    } // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n    // Normalize the tail path\n\n\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail || '.';\n  },\n  normalize: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = 0;\n    var device;\n    var isAbsolute = false;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            var firstPart = path.slice(last, j); // Matched!\n\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n\n    var tail;\n\n    if (rootEnd < len) {\n      tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator);\n    } else {\n      tail = '';\n    }\n\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0) {\n          return '\\\\' + tail;\n        } else {\n          return '\\\\';\n        }\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else if (isAbsolute) {\n      if (tail.length > 0) {\n        return device + '\\\\' + tail;\n      } else {\n        return device + '\\\\';\n      }\n    } else if (tail.length > 0) {\n      return device + tail;\n    } else {\n      return device;\n    }\n  },\n  isAbsolute: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return false;\n    }\n\n    var code = path.charCodeAt(0);\n\n    if (isPathSeparator(code)) {\n      return true;\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n        if (isPathSeparator(path.charCodeAt(2))) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n  join: function () {\n    var paths = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n\n    if (paths.length === 0) {\n      return '.';\n    }\n\n    var joined;\n    var firstPart;\n\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = paths[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += '\\\\' + arg;\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    } // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\n\n    var needsReplace = true;\n    var slashCount = 0;\n\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      var firstLen = firstPart.length;\n\n      if (firstLen > 1) {\n        if (isPathSeparator(firstPart.charCodeAt(1))) {\n          ++slashCount;\n\n          if (firstLen > 2) {\n            if (isPathSeparator(firstPart.charCodeAt(2))) {\n              ++slashCount;\n            } else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        if (!isPathSeparator(joined.charCodeAt(slashCount))) {\n          break;\n        }\n      } // Replace the slashes if needed\n\n\n      if (slashCount >= 2) {\n        joined = '\\\\' + joined.slice(slashCount);\n      }\n    }\n\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function (from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig) {\n      return '';\n    }\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to) {\n      return '';\n    } // Trim any leading backslashes\n\n\n    var fromStart = 0;\n\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var fromEnd = from.length;\n\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n\n    var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n    var toStart = 0;\n\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var toEnd = to.length;\n\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n\n    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n\n        break;\n      }\n\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    } // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n\n\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n\n    var out = '';\n\n    if (lastCommonSep === -1) {\n      lastCommonSep = 0;\n    } // Generate the relative path based on the path difference between `to` and\n    // `from`\n\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '\\\\..';\n        }\n      }\n    } // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n\n\n    if (out.length > 0) {\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    } else {\n      toStart += lastCommonSep;\n\n      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n        ++toStart;\n      }\n\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n  toNamespacedPath: function (path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string') {\n      return path;\n    }\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    var resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length >= 3) {\n      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n        // Possible UNC root\n        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n          var code = resolvedPath.charCodeAt(2);\n\n          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n          }\n        }\n      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n        // Possible device root\n        if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n\n    return path;\n  },\n  dirname: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = offset = 1;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = offset = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              rootEnd = offset = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      return path;\n    }\n\n    for (var i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      } else {\n        end = rootEnd;\n      }\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function (path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2) {\n      var drive = path.charCodeAt(0);\n\n      if (isWindowsDeviceRoot(drive)) {\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          start = 2;\n        }\n      }\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= start; --i) {\n        var code = path.charCodeAt(i);\n\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        if (isPathSeparator(path.charCodeAt(i))) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) {\n        return '';\n      }\n\n      return path.slice(start, end);\n    }\n  },\n  extname: function (path) {\n    validateString(path, 'path');\n    var start = 0;\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n\n    for (var i = path.length - 1; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: function (pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n\n    return _format('\\\\', pathObject);\n  },\n  parse: function (path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = 1;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n              }\n\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path;\n            return ret;\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path;\n      return ret;\n    }\n\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n\n    var startDot = -1;\n    var startPart = rootEnd;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n      ret.ext = path.slice(startDot, end);\n    } // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\n\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nexport var posix = {\n  // path.resolve([from ...], to)\n  resolve: function () {\n    var pathSegments = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n\n    for (var i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = void 0;\n\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else {\n        path = process.cwd();\n      }\n\n      validateString(path, 'path'); // Skip empty entries\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    } // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path\n\n\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) {\n        return '/' + resolvedPath;\n      } else {\n        return '/';\n      }\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n  normalize: function (path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH; // Normalize the path\n\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0 && !isAbsolute) {\n      path = '.';\n    }\n\n    if (path.length > 0 && trailingSeparator) {\n      path += '/';\n    }\n\n    if (isAbsolute) {\n      return '/' + path;\n    }\n\n    return path;\n  },\n  isAbsolute: function (path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join: function () {\n    var paths = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n\n    if (paths.length === 0) {\n      return '.';\n    }\n\n    var joined;\n\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = arguments[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += '/' + arg;\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    }\n\n    return posix.normalize(joined);\n  },\n  relative: function (from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    } // Trim any leading backslashes\n\n\n    var fromStart = 1;\n\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n    var toStart = 1;\n\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n\n    var toEnd = to.length;\n    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n\n        break;\n      }\n\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n\n    var out = ''; // Generate the relative path based on the path difference between `to`\n    // and `from`\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '/..';\n        }\n      }\n    } // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n\n\n    if (out.length > 0) {\n      return out + to.slice(toStart + lastCommonSep);\n    } else {\n      toStart += lastCommonSep;\n\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n        ++toStart;\n      }\n\n      return to.slice(toStart);\n    }\n  },\n  toNamespacedPath: function (path) {\n    // Non-op on posix systems\n    return path;\n  },\n  dirname: function (path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var end = -1;\n    var matchedSlash = true;\n\n    for (var i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function (path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) {\n        return '';\n      }\n\n      return path.slice(start, end);\n    }\n  },\n  extname: function (path) {\n    validateString(path, 'path');\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0;\n\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: function (pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n\n    return _format('/', pathObject);\n  },\n  parse: function (path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var start;\n\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) {\n          ret.base = ret.name = path.slice(1, end);\n        } else {\n          ret.base = ret.name = path.slice(startPart, end);\n        }\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport var normalize = process.platform === 'win32' ? win32.normalize : posix.normalize;\nexport var join = process.platform === 'win32' ? win32.join : posix.join;\nexport var relative = process.platform === 'win32' ? win32.relative : posix.relative;\nexport var dirname = process.platform === 'win32' ? win32.dirname : posix.dirname;\nexport var basename = process.platform === 'win32' ? win32.basename : posix.basename;\nexport var extname = process.platform === 'win32' ? win32.extname : posix.extname;\nexport var sep = process.platform === 'win32' ? win32.sep : posix.sep;","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/path.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","_super","name","expected","actual","_this","determiner","indexOf","replace","type","msg","call","code","Error","validateString","value","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","resolve","pathSegments","_i","arguments","resolvedDevice","resolvedTail","resolvedAbsolute","cwd","env","undefined","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","paths","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","toCode","out","toNamespacedPath","resolvedPath","dirname","end","matchedSlash","offset","basename","start","drive","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","parse","ret","delimiter","posix","trailingSeparator","hasRoot","platform"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\nimport * as process from './process.js';\r\nvar CHAR_UPPERCASE_A = 65; /* A */\r\nvar CHAR_LOWERCASE_A = 97; /* a */\r\nvar CHAR_UPPERCASE_Z = 90; /* Z */\r\nvar CHAR_LOWERCASE_Z = 122; /* z */\r\nvar CHAR_DOT = 46; /* . */\r\nvar CHAR_FORWARD_SLASH = 47; /* / */\r\nvar CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nvar CHAR_COLON = 58; /* : */\r\nvar CHAR_QUESTION_MARK = 63; /* ? */\r\nvar ErrorInvalidArgType = /** @class */ (function (_super) {\r\n    __extends(ErrorInvalidArgType, _super);\r\n    function ErrorInvalidArgType(name, expected, actual) {\r\n        var _this = this;\r\n        // determiner: 'must be' or 'must not be'\r\n        var determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        var msg = \"The \\\"\" + name + \"\\\" \" + type + \" \" + determiner + \" of type \" + expected;\r\n        msg += \". Received type \" + typeof actual;\r\n        _this = _super.call(this, msg) || this;\r\n        _this.code = 'ERR_INVALID_ARG_TYPE';\r\n        return _this;\r\n    }\r\n    return ErrorInvalidArgType;\r\n}(Error));\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\r\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    var res = '';\r\n    var lastSegmentLength = 0;\r\n    var lastSlash = -1;\r\n    var dots = 0;\r\n    var code;\r\n    for (var i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (lastSlash !== i - 1 && dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        var lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length === 2 || res.length === 1) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    if (res.length > 0) {\r\n                        res += separator + \"..\";\r\n                    }\r\n                    else {\r\n                        res = '..';\r\n                    }\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += separator + path.slice(lastSlash + 1, i);\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    var dir = pathObject.dir || pathObject.root;\r\n    var base = pathObject.base ||\r\n        ((pathObject.name || '') + (pathObject.ext || ''));\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    if (dir === pathObject.root) {\r\n        return dir + base;\r\n    }\r\n    return dir + sep + base;\r\n}\r\nexport var win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve: function () {\r\n        var pathSegments = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            pathSegments[_i] = arguments[_i];\r\n        }\r\n        var resolvedDevice = '';\r\n        var resolvedTail = '';\r\n        var resolvedAbsolute = false;\r\n        for (var i = pathSegments.length - 1; i >= -1; i--) {\r\n            var path = void 0;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n            }\r\n            else if (!resolvedDevice) {\r\n                path = process.cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = process.env['=' + resolvedDevice] || process.cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    path.slice(0, 3).toLowerCase() !==\r\n                        resolvedDevice.toLowerCase() + '\\\\') {\r\n                    path = resolvedDevice + '\\\\';\r\n                }\r\n            }\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            var len = path.length;\r\n            var rootEnd = 0;\r\n            var device = '';\r\n            var isAbsolute = false;\r\n            var code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len > 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // Possible UNC root\r\n                    // If we started with a separator, we know we at least have an\r\n                    // absolute path of some kind (UNC or otherwise)\r\n                    isAbsolute = true;\r\n                    if (isPathSeparator(path.charCodeAt(1))) {\r\n                        // Matched double path separator at beginning\r\n                        var j = 2;\r\n                        var last = j;\r\n                        // Match 1 or more non-path separators\r\n                        for (; j < len; ++j) {\r\n                            if (isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            var firstPart = path.slice(last, j);\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more path separators\r\n                            for (; j < len; ++j) {\r\n                                if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j < len && j !== last) {\r\n                                // Matched!\r\n                                last = j;\r\n                                // Match 1 or more non-path separators\r\n                                for (; j < len; ++j) {\r\n                                    if (isPathSeparator(path.charCodeAt(j))) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (j === len) {\r\n                                    // We matched a UNC root only\r\n                                    device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\r\n                                    rootEnd = j;\r\n                                }\r\n                                else if (j !== last) {\r\n                                    // We matched a UNC root with leftovers\r\n                                    device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\r\n                                    rootEnd = j;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        rootEnd = 1;\r\n                    }\r\n                }\r\n                else if (isWindowsDeviceRoot(code)) {\r\n                    // Possible device root\r\n                    if (path.charCodeAt(1) === CHAR_COLON) {\r\n                        device = path.slice(0, 2);\r\n                        rootEnd = 2;\r\n                        if (len > 2) {\r\n                            if (isPathSeparator(path.charCodeAt(2))) {\r\n                                // Treat separator following drive name as an absolute path\r\n                                // indicator\r\n                                isAbsolute = true;\r\n                                rootEnd = 3;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator\r\n                rootEnd = 1;\r\n                isAbsolute = true;\r\n            }\r\n            if (device.length > 0 &&\r\n                resolvedDevice.length > 0 &&\r\n                device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                // This path points to another device so it is not applicable\r\n                continue;\r\n            }\r\n            if (resolvedDevice.length === 0 && device.length > 0) {\r\n                resolvedDevice = device;\r\n            }\r\n            if (!resolvedAbsolute) {\r\n                resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\r\n                resolvedAbsolute = isAbsolute;\r\n            }\r\n            if (resolvedDevice.length > 0 && resolvedAbsolute) {\r\n                break;\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n            '.';\r\n    },\r\n    normalize: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        var rootEnd = 0;\r\n        var device;\r\n        var isAbsolute = false;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an absolute\r\n                // path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        var firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                // Return the normalized version of the UNC root since there\r\n                                // is nothing left to process\r\n                                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\r\n                            }\r\n                            else if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    device = path.slice(0, 2);\r\n                    rootEnd = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            // Treat separator following drive name as an absolute path\r\n                            // indicator\r\n                            isAbsolute = true;\r\n                            rootEnd = 3;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid unnecessary\r\n            // work\r\n            return '\\\\';\r\n        }\r\n        var tail;\r\n        if (rootEnd < len) {\r\n            tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator);\r\n        }\r\n        else {\r\n            tail = '';\r\n        }\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            if (isAbsolute) {\r\n                if (tail.length > 0) {\r\n                    return '\\\\' + tail;\r\n                }\r\n                else {\r\n                    return '\\\\';\r\n                }\r\n            }\r\n            else if (tail.length > 0) {\r\n                return tail;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        }\r\n        else if (isAbsolute) {\r\n            if (tail.length > 0) {\r\n                return device + '\\\\' + tail;\r\n            }\r\n            else {\r\n                return device + '\\\\';\r\n            }\r\n        }\r\n        else if (tail.length > 0) {\r\n            return device + tail;\r\n        }\r\n        else {\r\n            return device;\r\n        }\r\n    },\r\n    isAbsolute: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        var code = path.charCodeAt(0);\r\n        if (isPathSeparator(code)) {\r\n            return true;\r\n        }\r\n        else if (isWindowsDeviceRoot(code)) {\r\n            // Possible device root\r\n            if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\r\n                if (isPathSeparator(path.charCodeAt(2))) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    join: function () {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i] = arguments[_i];\r\n        }\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        var joined;\r\n        var firstPart;\r\n        for (var i = 0; i < paths.length; ++i) {\r\n            var arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += '\\\\' + arg;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for an UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at an UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as an UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        var needsReplace = true;\r\n        var slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            var firstLen = firstPart.length;\r\n            if (firstLen > 1) {\r\n                if (isPathSeparator(firstPart.charCodeAt(1))) {\r\n                    ++slashCount;\r\n                    if (firstLen > 2) {\r\n                        if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                            ++slashCount;\r\n                        }\r\n                        else {\r\n                            // We matched a UNC path in the first part\r\n                            needsReplace = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            for (; slashCount < joined.length; ++slashCount) {\r\n                if (!isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                    break;\r\n                }\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = '\\\\' + joined.slice(slashCount);\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative: function (from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        var fromOrig = win32.resolve(from);\r\n        var toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        var fromStart = 0;\r\n        for (; fromStart < from.length; ++fromStart) {\r\n            if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        var fromEnd = from.length;\r\n        for (; fromEnd - 1 > fromStart; --fromEnd) {\r\n            if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var fromLen = (fromEnd - fromStart);\r\n        // Trim any leading backslashes\r\n        var toStart = 0;\r\n        for (; toStart < to.length; ++toStart) {\r\n            if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        var toEnd = to.length;\r\n        for (; toEnd - 1 > toStart; --toEnd) {\r\n            if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var toLen = (toEnd - toStart);\r\n        // Compare paths to find the longest common path from root\r\n        var length = (fromLen < toLen ? fromLen : toLen);\r\n        var lastCommonSep = -1;\r\n        var i = 0;\r\n        for (; i <= length; ++i) {\r\n            if (i === length) {\r\n                if (toLen > length) {\r\n                    if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                        // We get here if `from` is the exact base path for `to`.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                        return toOrig.slice(toStart + i + 1);\r\n                    }\r\n                    else if (i === 2) {\r\n                        // We get here if `from` is the device root.\r\n                        // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                        return toOrig.slice(toStart + i);\r\n                    }\r\n                }\r\n                if (fromLen > length) {\r\n                    if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                        // We get here if `to` is the exact base path for `from`.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                        lastCommonSep = i;\r\n                    }\r\n                    else if (i === 2) {\r\n                        // We get here if `to` is the device root.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                        lastCommonSep = 3;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            var fromCode = from.charCodeAt(fromStart + i);\r\n            var toCode = to.charCodeAt(toStart + i);\r\n            if (fromCode !== toCode) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length && lastCommonSep === -1) {\r\n            return toOrig;\r\n        }\r\n        var out = '';\r\n        if (lastCommonSep === -1) {\r\n            lastCommonSep = 0;\r\n        }\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                if (out.length === 0) {\r\n                    out += '..';\r\n                }\r\n                else {\r\n                    out += '\\\\..';\r\n                }\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return out + toOrig.slice(toStart + lastCommonSep, toEnd);\r\n        }\r\n        else {\r\n            toStart += lastCommonSep;\r\n            if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n                ++toStart;\r\n            }\r\n            return toOrig.slice(toStart, toEnd);\r\n        }\r\n    },\r\n    toNamespacedPath: function (path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string') {\r\n            return path;\r\n        }\r\n        if (path.length === 0) {\r\n            return '';\r\n        }\r\n        var resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length >= 3) {\r\n            if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n                // Possible UNC root\r\n                if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                    var code = resolvedPath.charCodeAt(2);\r\n                    if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                        // Matched non-long UNC root, convert the path to a long UNC path\r\n                        return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\r\n                // Possible device root\r\n                if (resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n                    resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n                    // Matched device root, convert the path to a long UNC path\r\n                    return '\\\\\\\\?\\\\' + resolvedPath;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    },\r\n    dirname: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        var rootEnd = -1;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var offset = 0;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                rootEnd = offset = 1;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                return path;\r\n                            }\r\n                            if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                // Offset by 1 to include the separator after the UNC root to\r\n                                // treat it as a \"normal root\" on top of a (UNC) root\r\n                                rootEnd = offset = j + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    rootEnd = offset = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            rootEnd = offset = 3;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work\r\n            return path;\r\n        }\r\n        for (var i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            else {\r\n                end = rootEnd;\r\n            }\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename: function (path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2) {\r\n            var drive = path.charCodeAt(0);\r\n            if (isWindowsDeviceRoot(drive)) {\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    start = 2;\r\n                }\r\n            }\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext.length === path.length && ext === path) {\r\n                return '';\r\n            }\r\n            var extIdx = ext.length - 1;\r\n            var firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                var code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        else {\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                if (isPathSeparator(path.charCodeAt(i))) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (end === -1) {\r\n                    // We saw the first non-path separator, mark this as the end of our\r\n                    // path component\r\n                    matchedSlash = false;\r\n                    end = i + 1;\r\n                }\r\n            }\r\n            if (end === -1) {\r\n                return '';\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n    },\r\n    extname: function (path) {\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (var i = path.length - 1; i >= start; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: function (pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n        }\r\n        return _format('\\\\', pathObject);\r\n    },\r\n    parse: function (path) {\r\n        validateString(path, 'path');\r\n        var ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        var len = path.length;\r\n        var rootEnd = 0;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                rootEnd = 1;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                rootEnd = j;\r\n                            }\r\n                            else if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                rootEnd = j + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    rootEnd = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            if (len === 3) {\r\n                                // `path` contains just a drive root, exit early to avoid\r\n                                // unnecessary work\r\n                                ret.root = ret.dir = path;\r\n                                return ret;\r\n                            }\r\n                            rootEnd = 3;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // `path` contains just a drive root, exit early to avoid\r\n                        // unnecessary work\r\n                        ret.root = ret.dir = path;\r\n                        return ret;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work\r\n            ret.root = ret.dir = path;\r\n            return ret;\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        var startDot = -1;\r\n        var startPart = rootEnd;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            if (end !== -1) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n        }\r\n        else {\r\n            ret.name = path.slice(startPart, startDot);\r\n            ret.base = path.slice(startPart, end);\r\n            ret.ext = path.slice(startDot, end);\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nexport var posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve: function () {\r\n        var pathSegments = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            pathSegments[_i] = arguments[_i];\r\n        }\r\n        var resolvedPath = '';\r\n        var resolvedAbsolute = false;\r\n        for (var i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            var path = void 0;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n            }\r\n            else {\r\n                path = process.cwd();\r\n            }\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = path + '/' + resolvedPath;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            if (resolvedPath.length > 0) {\r\n                return '/' + resolvedPath;\r\n            }\r\n            else {\r\n                return '/';\r\n            }\r\n        }\r\n        else if (resolvedPath.length > 0) {\r\n            return resolvedPath;\r\n        }\r\n        else {\r\n            return '.';\r\n        }\r\n    },\r\n    normalize: function (path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0 && !isAbsolute) {\r\n            path = '.';\r\n        }\r\n        if (path.length > 0 && trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        if (isAbsolute) {\r\n            return '/' + path;\r\n        }\r\n        return path;\r\n    },\r\n    isAbsolute: function (path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join: function () {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i] = arguments[_i];\r\n        }\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        var joined;\r\n        for (var i = 0; i < paths.length; ++i) {\r\n            var arg = arguments[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += '/' + arg;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative: function (from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        var fromStart = 1;\r\n        for (; fromStart < from.length; ++fromStart) {\r\n            if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var fromEnd = from.length;\r\n        var fromLen = (fromEnd - fromStart);\r\n        // Trim any leading backslashes\r\n        var toStart = 1;\r\n        for (; toStart < to.length; ++toStart) {\r\n            if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var toEnd = to.length;\r\n        var toLen = (toEnd - toStart);\r\n        // Compare paths to find the longest common path from root\r\n        var length = (fromLen < toLen ? fromLen : toLen);\r\n        var lastCommonSep = -1;\r\n        var i = 0;\r\n        for (; i <= length; ++i) {\r\n            if (i === length) {\r\n                if (toLen > length) {\r\n                    if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                        // We get here if `from` is the exact base path for `to`.\r\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                        return to.slice(toStart + i + 1);\r\n                    }\r\n                    else if (i === 0) {\r\n                        // We get here if `from` is the root\r\n                        // For example: from='/'; to='/foo'\r\n                        return to.slice(toStart + i);\r\n                    }\r\n                }\r\n                else if (fromLen > length) {\r\n                    if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                        // We get here if `to` is the exact base path for `from`.\r\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                        lastCommonSep = i;\r\n                    }\r\n                    else if (i === 0) {\r\n                        // We get here if `to` is the root.\r\n                        // For example: from='/foo'; to='/'\r\n                        lastCommonSep = 0;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            var fromCode = from.charCodeAt(fromStart + i);\r\n            var toCode = to.charCodeAt(toStart + i);\r\n            if (fromCode !== toCode) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        var out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (out.length === 0) {\r\n                    out += '..';\r\n                }\r\n                else {\r\n                    out += '/..';\r\n                }\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return out + to.slice(toStart + lastCommonSep);\r\n        }\r\n        else {\r\n            toStart += lastCommonSep;\r\n            if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\r\n                ++toStart;\r\n            }\r\n            return to.slice(toStart);\r\n        }\r\n    },\r\n    toNamespacedPath: function (path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname: function (path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        for (var i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename: function (path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext.length === path.length && ext === path) {\r\n                return '';\r\n            }\r\n            var extIdx = ext.length - 1;\r\n            var firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                var code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        else {\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (end === -1) {\r\n                    // We saw the first non-path separator, mark this as the end of our\r\n                    // path component\r\n                    matchedSlash = false;\r\n                    end = i + 1;\r\n                }\r\n            }\r\n            if (end === -1) {\r\n                return '';\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n    },\r\n    extname: function (path) {\r\n        validateString(path, 'path');\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        for (var i = path.length - 1; i >= 0; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: function (pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n        }\r\n        return _format('/', pathObject);\r\n    },\r\n    parse: function (path) {\r\n        validateString(path, 'path');\r\n        var ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            if (end !== -1) {\r\n                if (startPart === 0 && isAbsolute) {\r\n                    ret.base = ret.name = path.slice(1, end);\r\n                }\r\n                else {\r\n                    ret.base = ret.name = path.slice(startPart, end);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (startPart === 0 && isAbsolute) {\r\n                ret.name = path.slice(1, startDot);\r\n                ret.base = path.slice(1, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n            }\r\n            ret.ext = path.slice(startDot, end);\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nexport var normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\r\nexport var join = (process.platform === 'win32' ? win32.join : posix.join);\r\nexport var relative = (process.platform === 'win32' ? win32.relative : posix.relative);\r\nexport var dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\r\nexport var basename = (process.platform === 'win32' ? win32.basename : posix.basename);\r\nexport var extname = (process.platform === 'win32' ? win32.extname : posix.extname);\r\nexport var sep = (process.platform === 'win32' ? win32.sep : posix.sep);\r\n"]},"metadata":{},"sourceType":"module"}