{"ast":null,"code":"import { ContextKeyOrExpr } from '../../contextkey/common/contextkey.js';\n\nvar KeybindingResolver =\n/** @class */\nfunction () {\n  function KeybindingResolver(defaultKeybindings, overrides) {\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n\n    for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\n      var command = defaultKeybindings[i].command;\n\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n\n    for (var i = 0, len = this._keybindings.length; i < len; i++) {\n      var k = this._keybindings[i];\n\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      } // TODO@chords\n\n\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n\n  KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n    if (defaultKb.command !== command) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n\n      if (!when.equals(defaultKb.when)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n   */\n\n\n  KeybindingResolver.combine = function (defaults, rawOverrides) {\n    defaults = defaults.slice(0);\n    var overrides = [];\n\n    for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\n      var override = rawOverrides_1[_i];\n\n      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n        overrides.push(override);\n        continue;\n      }\n\n      var command = override.command.substr(1); // TODO@chords\n\n      var keypressFirstPart = override.keypressParts[0];\n      var keypressChordPart = override.keypressParts[1];\n      var when = override.when;\n\n      for (var j = defaults.length - 1; j >= 0; j--) {\n        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n          defaults.splice(j, 1);\n        }\n      }\n    }\n\n    return defaults.concat(overrides);\n  };\n\n  KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\n    var conflicts = this._map.get(keypress);\n\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n\n      this._addToLookupMap(item);\n\n      return;\n    }\n\n    for (var i = conflicts.length - 1; i >= 0; i--) {\n      var conflict = conflicts[i];\n\n      if (conflict.command === item.command) {\n        continue;\n      }\n\n      var conflictIsChord = conflict.keypressParts.length > 1;\n      var itemIsChord = item.keypressParts.length > 1; // TODO@chords\n\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n\n    conflicts.push(item);\n\n    this._addToLookupMap(item);\n  };\n\n  KeybindingResolver.prototype._addToLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n\n    var arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      arr = [item];\n\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  };\n\n  KeybindingResolver.prototype._removeFromLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n\n    var arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      return;\n    }\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  };\n  /**\r\n   * Returns true if it is provable `a` implies `b`.\r\n   */\n\n\n  KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\n    if (!b) {\n      return true;\n    }\n\n    if (!a) {\n      return false;\n    }\n\n    return this._implies(a, b);\n  };\n  /**\r\n   * Returns true if it is provable `p` implies `q`.\r\n   */\n\n\n  KeybindingResolver._implies = function (p, q) {\n    var notP = p.negate();\n\n    var terminals = function (node) {\n      if (node instanceof ContextKeyOrExpr) {\n        return node.expr;\n      }\n\n      return [node];\n    };\n\n    var expr = terminals(notP).concat(terminals(q));\n\n    for (var i = 0; i < expr.length; i++) {\n      var a = expr[i];\n      var notA = a.negate();\n\n      for (var j = i + 1; j < expr.length; j++) {\n        var b = expr[j];\n\n        if (notA.equals(b)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  KeybindingResolver.prototype.getKeybindings = function () {\n    return this._keybindings;\n  };\n\n  KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\n    var items = this._lookupMap.get(commandId);\n\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n\n    return items[items.length - 1];\n  };\n\n  KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\n    var lookupMap = null;\n\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      var candidates = this._map.get(currentChord);\n\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        return null;\n      }\n\n      lookupMap = [];\n\n      for (var i = 0, len = candidates.length; i < len; i++) {\n        var candidate = candidates[i]; // TODO@chords\n\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      var candidates = this._map.get(keypress);\n\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        return null;\n      }\n\n      lookupMap = candidates;\n    }\n\n    var result = this._findCommand(context, lookupMap);\n\n    if (!result) {\n      return null;\n    } // TODO@chords\n\n\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      return {\n        enterChord: true,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n\n    return {\n      enterChord: false,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  };\n\n  KeybindingResolver.prototype._findCommand = function (context, matches) {\n    for (var i = matches.length - 1; i >= 0; i--) {\n      var k = matches[i];\n\n      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n        continue;\n      }\n\n      return k;\n    }\n\n    return null;\n  };\n\n  KeybindingResolver.contextMatchesRules = function (context, rules) {\n    if (!rules) {\n      return true;\n    }\n\n    return rules.evaluate(context);\n  };\n\n  return KeybindingResolver;\n}();\n\nexport { KeybindingResolver };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"names":["ContextKeyOrExpr","KeybindingResolver","defaultKeybindings","overrides","_defaultKeybindings","_defaultBoundCommands","Map","i","len","length","command","set","_map","_lookupMap","_keybindings","combine","k","keypressParts","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","when","equals","defaults","rawOverrides","slice","_i","rawOverrides_1","override","charAt","push","substr","j","splice","concat","prototype","keypress","item","conflicts","get","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","a","b","_implies","p","q","notP","negate","terminals","node","expr","notA","getKeybindings","lookupPrimaryKeybinding","commandId","items","resolve","context","currentChord","lookupMap","candidates","candidate","result","_findCommand","enterChord","commandArgs","bubble","matches","contextMatchesRules","rules","evaluate"],"mappings":"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","sourcesContent":["import { ContextKeyOrExpr } from '../../contextkey/common/contextkey.js';\r\nvar KeybindingResolver = /** @class */ (function () {\r\n    function KeybindingResolver(defaultKeybindings, overrides) {\r\n        this._defaultKeybindings = defaultKeybindings;\r\n        this._defaultBoundCommands = new Map();\r\n        for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\r\n            var command = defaultKeybindings[i].command;\r\n            if (command) {\r\n                this._defaultBoundCommands.set(command, true);\r\n            }\r\n        }\r\n        this._map = new Map();\r\n        this._lookupMap = new Map();\r\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\r\n        for (var i = 0, len = this._keybindings.length; i < len; i++) {\r\n            var k = this._keybindings[i];\r\n            if (k.keypressParts.length === 0) {\r\n                // unbound\r\n                continue;\r\n            }\r\n            // TODO@chords\r\n            this._addKeyPress(k.keypressParts[0], k);\r\n        }\r\n    }\r\n    KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\r\n        if (defaultKb.command !== command) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\r\n            return false;\r\n        }\r\n        if (when) {\r\n            if (!defaultKb.when) {\r\n                return false;\r\n            }\r\n            if (!when.equals(defaultKb.when)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n     */\r\n    KeybindingResolver.combine = function (defaults, rawOverrides) {\r\n        defaults = defaults.slice(0);\r\n        var overrides = [];\r\n        for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\r\n            var override = rawOverrides_1[_i];\r\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\r\n                overrides.push(override);\r\n                continue;\r\n            }\r\n            var command = override.command.substr(1);\r\n            // TODO@chords\r\n            var keypressFirstPart = override.keypressParts[0];\r\n            var keypressChordPart = override.keypressParts[1];\r\n            var when = override.when;\r\n            for (var j = defaults.length - 1; j >= 0; j--) {\r\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\r\n                    defaults.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n        return defaults.concat(overrides);\r\n    };\r\n    KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\r\n        var conflicts = this._map.get(keypress);\r\n        if (typeof conflicts === 'undefined') {\r\n            // There is no conflict so far\r\n            this._map.set(keypress, [item]);\r\n            this._addToLookupMap(item);\r\n            return;\r\n        }\r\n        for (var i = conflicts.length - 1; i >= 0; i--) {\r\n            var conflict = conflicts[i];\r\n            if (conflict.command === item.command) {\r\n                continue;\r\n            }\r\n            var conflictIsChord = (conflict.keypressParts.length > 1);\r\n            var itemIsChord = (item.keypressParts.length > 1);\r\n            // TODO@chords\r\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\r\n                // The conflict only shares the chord start with this command\r\n                continue;\r\n            }\r\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\r\n                // `item` completely overwrites `conflict`\r\n                // Remove conflict from the lookupMap\r\n                this._removeFromLookupMap(conflict);\r\n            }\r\n        }\r\n        conflicts.push(item);\r\n        this._addToLookupMap(item);\r\n    };\r\n    KeybindingResolver.prototype._addToLookupMap = function (item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        var arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            arr = [item];\r\n            this._lookupMap.set(item.command, arr);\r\n        }\r\n        else {\r\n            arr.push(item);\r\n        }\r\n    };\r\n    KeybindingResolver.prototype._removeFromLookupMap = function (item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        var arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            return;\r\n        }\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === item) {\r\n                arr.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if it is provable `a` implies `b`.\r\n     */\r\n    KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\r\n        if (!b) {\r\n            return true;\r\n        }\r\n        if (!a) {\r\n            return false;\r\n        }\r\n        return this._implies(a, b);\r\n    };\r\n    /**\r\n     * Returns true if it is provable `p` implies `q`.\r\n     */\r\n    KeybindingResolver._implies = function (p, q) {\r\n        var notP = p.negate();\r\n        var terminals = function (node) {\r\n            if (node instanceof ContextKeyOrExpr) {\r\n                return node.expr;\r\n            }\r\n            return [node];\r\n        };\r\n        var expr = terminals(notP).concat(terminals(q));\r\n        for (var i = 0; i < expr.length; i++) {\r\n            var a = expr[i];\r\n            var notA = a.negate();\r\n            for (var j = i + 1; j < expr.length; j++) {\r\n                var b = expr[j];\r\n                if (notA.equals(b)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    KeybindingResolver.prototype.getKeybindings = function () {\r\n        return this._keybindings;\r\n    };\r\n    KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\r\n        var items = this._lookupMap.get(commandId);\r\n        if (typeof items === 'undefined' || items.length === 0) {\r\n            return null;\r\n        }\r\n        return items[items.length - 1];\r\n    };\r\n    KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\r\n        var lookupMap = null;\r\n        if (currentChord !== null) {\r\n            // Fetch all chord bindings for `currentChord`\r\n            var candidates = this._map.get(currentChord);\r\n            if (typeof candidates === 'undefined') {\r\n                // No chords starting with `currentChord`\r\n                return null;\r\n            }\r\n            lookupMap = [];\r\n            for (var i = 0, len = candidates.length; i < len; i++) {\r\n                var candidate = candidates[i];\r\n                // TODO@chords\r\n                if (candidate.keypressParts[1] === keypress) {\r\n                    lookupMap.push(candidate);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var candidates = this._map.get(keypress);\r\n            if (typeof candidates === 'undefined') {\r\n                // No bindings with `keypress`\r\n                return null;\r\n            }\r\n            lookupMap = candidates;\r\n        }\r\n        var result = this._findCommand(context, lookupMap);\r\n        if (!result) {\r\n            return null;\r\n        }\r\n        // TODO@chords\r\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\r\n            return {\r\n                enterChord: true,\r\n                commandId: null,\r\n                commandArgs: null,\r\n                bubble: false\r\n            };\r\n        }\r\n        return {\r\n            enterChord: false,\r\n            commandId: result.command,\r\n            commandArgs: result.commandArgs,\r\n            bubble: result.bubble\r\n        };\r\n    };\r\n    KeybindingResolver.prototype._findCommand = function (context, matches) {\r\n        for (var i = matches.length - 1; i >= 0; i--) {\r\n            var k = matches[i];\r\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\r\n                continue;\r\n            }\r\n            return k;\r\n        }\r\n        return null;\r\n    };\r\n    KeybindingResolver.contextMatchesRules = function (context, rules) {\r\n        if (!rules) {\r\n            return true;\r\n        }\r\n        return rules.evaluate(context);\r\n    };\r\n    return KeybindingResolver;\r\n}());\r\nexport { KeybindingResolver };\r\n"]},"metadata":{},"sourceType":"module"}