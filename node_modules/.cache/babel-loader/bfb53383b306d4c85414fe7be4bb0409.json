{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as json from './_deps/jsonc-parser/main.js';\nexport function createTokenizationSupport(supportComments) {\n  return {\n    getInitialState: function () {\n      return new JSONState(null, null, false);\n    },\n    tokenize: function (line, state, offsetDelta, stopAtOffset) {\n      return tokenize(supportComments, line, state, offsetDelta, stopAtOffset);\n    }\n  };\n}\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\nexport var TOKEN_VALUE_NULL = 'keyword.json';\nexport var TOKEN_VALUE_STRING = 'string.value.json';\nexport var TOKEN_VALUE_NUMBER = 'number.json';\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\n\nvar JSONState =\n/** @class */\nfunction () {\n  function JSONState(state, scanError, lastWasColon) {\n    this._state = state;\n    this.scanError = scanError;\n    this.lastWasColon = lastWasColon;\n  }\n\n  JSONState.prototype.clone = function () {\n    return new JSONState(this._state, this.scanError, this.lastWasColon);\n  };\n\n  JSONState.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (!other || !(other instanceof JSONState)) {\n      return false;\n    }\n\n    return this.scanError === other.scanError && this.lastWasColon === other.lastWasColon;\n  };\n\n  JSONState.prototype.getStateData = function () {\n    return this._state;\n  };\n\n  JSONState.prototype.setStateData = function (state) {\n    this._state = state;\n  };\n\n  return JSONState;\n}();\n\nfunction tokenize(comments, line, state, offsetDelta, stopAtOffset) {\n  if (offsetDelta === void 0) {\n    offsetDelta = 0;\n  } // handle multiline strings and block comments\n\n\n  var numberOfInsertedCharacters = 0,\n      adjustOffset = false;\n\n  switch (state.scanError) {\n    case 2\n    /* UnexpectedEndOfString */\n    :\n      line = '\"' + line;\n      numberOfInsertedCharacters = 1;\n      break;\n\n    case 1\n    /* UnexpectedEndOfComment */\n    :\n      line = '/*' + line;\n      numberOfInsertedCharacters = 2;\n      break;\n  }\n\n  var scanner = json.createScanner(line),\n      kind,\n      ret,\n      lastWasColon = state.lastWasColon;\n  ret = {\n    tokens: [],\n    endState: state.clone()\n  };\n\n  while (true) {\n    var offset = offsetDelta + scanner.getPosition(),\n        type = '';\n    kind = scanner.scan();\n\n    if (kind === 17\n    /* EOF */\n    ) {\n        break;\n      } // Check that the scanner has advanced\n\n\n    if (offset === offsetDelta + scanner.getPosition()) {\n      throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n    } // In case we inserted /* or \" character, we need to\n    // adjust the offset of all tokens (except the first)\n\n\n    if (adjustOffset) {\n      offset -= numberOfInsertedCharacters;\n    }\n\n    adjustOffset = numberOfInsertedCharacters > 0; // brackets and type\n\n    switch (kind) {\n      case 1\n      /* OpenBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 2\n      /* CloseBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 3\n      /* OpenBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 4\n      /* CloseBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 6\n      /* ColonToken */\n      :\n        type = TOKEN_DELIM_COLON;\n        lastWasColon = true;\n        break;\n\n      case 5\n      /* CommaToken */\n      :\n        type = TOKEN_DELIM_COMMA;\n        lastWasColon = false;\n        break;\n\n      case 8\n      /* TrueKeyword */\n      :\n      case 9\n      /* FalseKeyword */\n      :\n        type = TOKEN_VALUE_BOOLEAN;\n        lastWasColon = false;\n        break;\n\n      case 7\n      /* NullKeyword */\n      :\n        type = TOKEN_VALUE_NULL;\n        lastWasColon = false;\n        break;\n\n      case 10\n      /* StringLiteral */\n      :\n        type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\n        lastWasColon = false;\n        break;\n\n      case 11\n      /* NumericLiteral */\n      :\n        type = TOKEN_VALUE_NUMBER;\n        lastWasColon = false;\n        break;\n    } // comments, iff enabled\n\n\n    if (comments) {\n      switch (kind) {\n        case 12\n        /* LineCommentTrivia */\n        :\n          type = TOKEN_COMMENT_LINE;\n          break;\n\n        case 13\n        /* BlockCommentTrivia */\n        :\n          type = TOKEN_COMMENT_BLOCK;\n          break;\n      }\n    }\n\n    ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\n    ret.tokens.push({\n      startIndex: offset,\n      scopes: type\n    });\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/tokenization.js"],"names":["json","createTokenizationSupport","supportComments","getInitialState","JSONState","tokenize","line","state","offsetDelta","stopAtOffset","TOKEN_DELIM_OBJECT","TOKEN_DELIM_ARRAY","TOKEN_DELIM_COLON","TOKEN_DELIM_COMMA","TOKEN_VALUE_BOOLEAN","TOKEN_VALUE_NULL","TOKEN_VALUE_STRING","TOKEN_VALUE_NUMBER","TOKEN_PROPERTY_NAME","TOKEN_COMMENT_BLOCK","TOKEN_COMMENT_LINE","scanError","lastWasColon","_state","prototype","clone","equals","other","getStateData","setStateData","comments","numberOfInsertedCharacters","adjustOffset","scanner","createScanner","kind","ret","tokens","endState","offset","getPosition","type","scan","Error","substr","getTokenError","push","startIndex","scopes"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\nimport * as json from './_deps/jsonc-parser/main.js';\r\nexport function createTokenizationSupport(supportComments) {\r\n    return {\r\n        getInitialState: function () { return new JSONState(null, null, false); },\r\n        tokenize: function (line, state, offsetDelta, stopAtOffset) { return tokenize(supportComments, line, state, offsetDelta, stopAtOffset); }\r\n    };\r\n}\r\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\r\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\r\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\r\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\r\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\r\nexport var TOKEN_VALUE_NULL = 'keyword.json';\r\nexport var TOKEN_VALUE_STRING = 'string.value.json';\r\nexport var TOKEN_VALUE_NUMBER = 'number.json';\r\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\r\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\r\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\r\nvar JSONState = /** @class */ (function () {\r\n    function JSONState(state, scanError, lastWasColon) {\r\n        this._state = state;\r\n        this.scanError = scanError;\r\n        this.lastWasColon = lastWasColon;\r\n    }\r\n    JSONState.prototype.clone = function () {\r\n        return new JSONState(this._state, this.scanError, this.lastWasColon);\r\n    };\r\n    JSONState.prototype.equals = function (other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        if (!other || !(other instanceof JSONState)) {\r\n            return false;\r\n        }\r\n        return this.scanError === other.scanError &&\r\n            this.lastWasColon === other.lastWasColon;\r\n    };\r\n    JSONState.prototype.getStateData = function () {\r\n        return this._state;\r\n    };\r\n    JSONState.prototype.setStateData = function (state) {\r\n        this._state = state;\r\n    };\r\n    return JSONState;\r\n}());\r\nfunction tokenize(comments, line, state, offsetDelta, stopAtOffset) {\r\n    if (offsetDelta === void 0) { offsetDelta = 0; }\r\n    // handle multiline strings and block comments\r\n    var numberOfInsertedCharacters = 0, adjustOffset = false;\r\n    switch (state.scanError) {\r\n        case 2 /* UnexpectedEndOfString */:\r\n            line = '\"' + line;\r\n            numberOfInsertedCharacters = 1;\r\n            break;\r\n        case 1 /* UnexpectedEndOfComment */:\r\n            line = '/*' + line;\r\n            numberOfInsertedCharacters = 2;\r\n            break;\r\n    }\r\n    var scanner = json.createScanner(line), kind, ret, lastWasColon = state.lastWasColon;\r\n    ret = {\r\n        tokens: [],\r\n        endState: state.clone()\r\n    };\r\n    while (true) {\r\n        var offset = offsetDelta + scanner.getPosition(), type = '';\r\n        kind = scanner.scan();\r\n        if (kind === 17 /* EOF */) {\r\n            break;\r\n        }\r\n        // Check that the scanner has advanced\r\n        if (offset === offsetDelta + scanner.getPosition()) {\r\n            throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\r\n        }\r\n        // In case we inserted /* or \" character, we need to\r\n        // adjust the offset of all tokens (except the first)\r\n        if (adjustOffset) {\r\n            offset -= numberOfInsertedCharacters;\r\n        }\r\n        adjustOffset = numberOfInsertedCharacters > 0;\r\n        // brackets and type\r\n        switch (kind) {\r\n            case 1 /* OpenBraceToken */:\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 2 /* CloseBraceToken */:\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 3 /* OpenBracketToken */:\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 4 /* CloseBracketToken */:\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 6 /* ColonToken */:\r\n                type = TOKEN_DELIM_COLON;\r\n                lastWasColon = true;\r\n                break;\r\n            case 5 /* CommaToken */:\r\n                type = TOKEN_DELIM_COMMA;\r\n                lastWasColon = false;\r\n                break;\r\n            case 8 /* TrueKeyword */:\r\n            case 9 /* FalseKeyword */:\r\n                type = TOKEN_VALUE_BOOLEAN;\r\n                lastWasColon = false;\r\n                break;\r\n            case 7 /* NullKeyword */:\r\n                type = TOKEN_VALUE_NULL;\r\n                lastWasColon = false;\r\n                break;\r\n            case 10 /* StringLiteral */:\r\n                type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\r\n                lastWasColon = false;\r\n                break;\r\n            case 11 /* NumericLiteral */:\r\n                type = TOKEN_VALUE_NUMBER;\r\n                lastWasColon = false;\r\n                break;\r\n        }\r\n        // comments, iff enabled\r\n        if (comments) {\r\n            switch (kind) {\r\n                case 12 /* LineCommentTrivia */:\r\n                    type = TOKEN_COMMENT_LINE;\r\n                    break;\r\n                case 13 /* BlockCommentTrivia */:\r\n                    type = TOKEN_COMMENT_BLOCK;\r\n                    break;\r\n            }\r\n        }\r\n        ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\r\n        ret.tokens.push({\r\n            startIndex: offset,\r\n            scopes: type\r\n        });\r\n    }\r\n    return ret;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}