{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\r\n * Returns the intersection between a ranged group and a range.\r\n * Returns `[]` if the intersection is empty.\r\n */\n\nexport function groupIntersect(range, groups) {\n  var result = [];\n\n  for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n    var r = groups_1[_i];\n\n    if (range.start >= r.range.end) {\n      continue;\n    }\n\n    if (range.end < r.range.start) {\n      break;\n    }\n\n    var intersection = Range.intersect(range, r.range);\n\n    if (Range.isEmpty(intersection)) {\n      continue;\n    }\n\n    result.push({\n      range: intersection,\n      size: r.size\n    });\n  }\n\n  return result;\n}\n/**\r\n * Shifts a range by that `much`.\r\n */\n\nexport function shift(_a, much) {\n  var start = _a.start,\n      end = _a.end;\n  return {\n    start: start + much,\n    end: end + much\n  };\n}\n/**\r\n * Consolidates a collection of ranged groups.\r\n *\r\n * Consolidation is the process of merging consecutive ranged groups\r\n * that share the same `size`.\r\n */\n\nexport function consolidate(groups) {\n  var result = [];\n  var previousGroup = null;\n\n  for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {\n    var group = groups_2[_i];\n    var start = group.range.start;\n    var end = group.range.end;\n    var size = group.size;\n\n    if (previousGroup && size === previousGroup.size) {\n      previousGroup.range.end = end;\n      continue;\n    }\n\n    previousGroup = {\n      range: {\n        start: start,\n        end: end\n      },\n      size: size\n    };\n    result.push(previousGroup);\n  }\n\n  return result;\n}\n/**\r\n * Concatenates several collections of ranged groups into a single\r\n * collection.\r\n */\n\nfunction concat() {\n  var groups = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    groups[_i] = arguments[_i];\n  }\n\n  return consolidate(groups.reduce(function (r, g) {\n    return r.concat(g);\n  }, []));\n}\n\nvar RangeMap =\n/** @class */\nfunction () {\n  function RangeMap() {\n    this.groups = [];\n    this._size = 0;\n  }\n\n  RangeMap.prototype.splice = function (index, deleteCount, items) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    var diff = items.length - deleteCount;\n    var before = groupIntersect({\n      start: 0,\n      end: index\n    }, this.groups);\n    var after = groupIntersect({\n      start: index + deleteCount,\n      end: Number.POSITIVE_INFINITY\n    }, this.groups).map(function (g) {\n      return {\n        range: shift(g.range, diff),\n        size: g.size\n      };\n    });\n    var middle = items.map(function (item, i) {\n      return {\n        range: {\n          start: index + i,\n          end: index + i + 1\n        },\n        size: item.size\n      };\n    });\n    this.groups = concat(before, middle, after);\n    this._size = this.groups.reduce(function (t, g) {\n      return t + g.size * (g.range.end - g.range.start);\n    }, 0);\n  };\n\n  Object.defineProperty(RangeMap.prototype, \"count\", {\n    /**\r\n     * Returns the number of items in the range map.\r\n     */\n    get: function () {\n      var len = this.groups.length;\n\n      if (!len) {\n        return 0;\n      }\n\n      return this.groups[len - 1].range.end;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RangeMap.prototype, \"size\", {\n    /**\r\n     * Returns the sum of the sizes of all items in the range map.\r\n     */\n    get: function () {\n      return this._size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the index of the item at the given position.\r\n   */\n\n  RangeMap.prototype.indexAt = function (position) {\n    if (position < 0) {\n      return -1;\n    }\n\n    var index = 0;\n    var size = 0;\n\n    for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n      var group = _a[_i];\n      var count = group.range.end - group.range.start;\n      var newSize = size + count * group.size;\n\n      if (position < newSize) {\n        return index + Math.floor((position - size) / group.size);\n      }\n\n      index += count;\n      size = newSize;\n    }\n\n    return index;\n  };\n  /**\r\n   * Returns the index of the item right after the item at the\r\n   * index of the given position.\r\n   */\n\n\n  RangeMap.prototype.indexAfter = function (position) {\n    return Math.min(this.indexAt(position) + 1, this.count);\n  };\n  /**\r\n   * Returns the start position of the item at the given index.\r\n   */\n\n\n  RangeMap.prototype.positionAt = function (index) {\n    if (index < 0) {\n      return -1;\n    }\n\n    var position = 0;\n    var count = 0;\n\n    for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n      var group = _a[_i];\n      var groupCount = group.range.end - group.range.start;\n      var newCount = count + groupCount;\n\n      if (index < newCount) {\n        return position + (index - count) * group.size;\n      }\n\n      position += groupCount * group.size;\n      count = newCount;\n    }\n\n    return -1;\n  };\n\n  return RangeMap;\n}();\n\nexport { RangeMap };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js"],"names":["Range","groupIntersect","range","groups","result","_i","groups_1","length","r","start","end","intersection","intersect","isEmpty","push","size","shift","_a","much","consolidate","previousGroup","groups_2","group","concat","arguments","reduce","g","RangeMap","_size","prototype","splice","index","deleteCount","items","diff","before","after","Number","POSITIVE_INFINITY","map","middle","item","i","t","Object","defineProperty","get","len","enumerable","configurable","indexAt","position","count","newSize","Math","floor","indexAfter","min","positionAt","groupCount","newCount"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Range } from '../../../common/range.js';\r\n/**\r\n * Returns the intersection between a ranged group and a range.\r\n * Returns `[]` if the intersection is empty.\r\n */\r\nexport function groupIntersect(range, groups) {\r\n    var result = [];\r\n    for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\r\n        var r = groups_1[_i];\r\n        if (range.start >= r.range.end) {\r\n            continue;\r\n        }\r\n        if (range.end < r.range.start) {\r\n            break;\r\n        }\r\n        var intersection = Range.intersect(range, r.range);\r\n        if (Range.isEmpty(intersection)) {\r\n            continue;\r\n        }\r\n        result.push({\r\n            range: intersection,\r\n            size: r.size\r\n        });\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Shifts a range by that `much`.\r\n */\r\nexport function shift(_a, much) {\r\n    var start = _a.start, end = _a.end;\r\n    return { start: start + much, end: end + much };\r\n}\r\n/**\r\n * Consolidates a collection of ranged groups.\r\n *\r\n * Consolidation is the process of merging consecutive ranged groups\r\n * that share the same `size`.\r\n */\r\nexport function consolidate(groups) {\r\n    var result = [];\r\n    var previousGroup = null;\r\n    for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {\r\n        var group = groups_2[_i];\r\n        var start = group.range.start;\r\n        var end = group.range.end;\r\n        var size = group.size;\r\n        if (previousGroup && size === previousGroup.size) {\r\n            previousGroup.range.end = end;\r\n            continue;\r\n        }\r\n        previousGroup = { range: { start: start, end: end }, size: size };\r\n        result.push(previousGroup);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Concatenates several collections of ranged groups into a single\r\n * collection.\r\n */\r\nfunction concat() {\r\n    var groups = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        groups[_i] = arguments[_i];\r\n    }\r\n    return consolidate(groups.reduce(function (r, g) { return r.concat(g); }, []));\r\n}\r\nvar RangeMap = /** @class */ (function () {\r\n    function RangeMap() {\r\n        this.groups = [];\r\n        this._size = 0;\r\n    }\r\n    RangeMap.prototype.splice = function (index, deleteCount, items) {\r\n        if (items === void 0) { items = []; }\r\n        var diff = items.length - deleteCount;\r\n        var before = groupIntersect({ start: 0, end: index }, this.groups);\r\n        var after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\r\n            .map(function (g) { return ({ range: shift(g.range, diff), size: g.size }); });\r\n        var middle = items.map(function (item, i) { return ({\r\n            range: { start: index + i, end: index + i + 1 },\r\n            size: item.size\r\n        }); });\r\n        this.groups = concat(before, middle, after);\r\n        this._size = this.groups.reduce(function (t, g) { return t + (g.size * (g.range.end - g.range.start)); }, 0);\r\n    };\r\n    Object.defineProperty(RangeMap.prototype, \"count\", {\r\n        /**\r\n         * Returns the number of items in the range map.\r\n         */\r\n        get: function () {\r\n            var len = this.groups.length;\r\n            if (!len) {\r\n                return 0;\r\n            }\r\n            return this.groups[len - 1].range.end;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RangeMap.prototype, \"size\", {\r\n        /**\r\n         * Returns the sum of the sizes of all items in the range map.\r\n         */\r\n        get: function () {\r\n            return this._size;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the index of the item at the given position.\r\n     */\r\n    RangeMap.prototype.indexAt = function (position) {\r\n        if (position < 0) {\r\n            return -1;\r\n        }\r\n        var index = 0;\r\n        var size = 0;\r\n        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\r\n            var group = _a[_i];\r\n            var count = group.range.end - group.range.start;\r\n            var newSize = size + (count * group.size);\r\n            if (position < newSize) {\r\n                return index + Math.floor((position - size) / group.size);\r\n            }\r\n            index += count;\r\n            size = newSize;\r\n        }\r\n        return index;\r\n    };\r\n    /**\r\n     * Returns the index of the item right after the item at the\r\n     * index of the given position.\r\n     */\r\n    RangeMap.prototype.indexAfter = function (position) {\r\n        return Math.min(this.indexAt(position) + 1, this.count);\r\n    };\r\n    /**\r\n     * Returns the start position of the item at the given index.\r\n     */\r\n    RangeMap.prototype.positionAt = function (index) {\r\n        if (index < 0) {\r\n            return -1;\r\n        }\r\n        var position = 0;\r\n        var count = 0;\r\n        for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\r\n            var group = _a[_i];\r\n            var groupCount = group.range.end - group.range.start;\r\n            var newCount = count + groupCount;\r\n            if (index < newCount) {\r\n                return position + ((index - count) * group.size);\r\n            }\r\n            position += groupCount * group.size;\r\n            count = newCount;\r\n        }\r\n        return -1;\r\n    };\r\n    return RangeMap;\r\n}());\r\nexport { RangeMap };\r\n"]},"metadata":{},"sourceType":"module"}