{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './../../jsonc-parser/main.js';\nimport { FoldingRangeKind, Position } from '../jsonLanguageTypes.js';\nexport function getFoldingRanges(document, context) {\n  var ranges = [];\n  var nestingLevels = [];\n  var stack = [];\n  var prevStart = -1;\n  var scanner = createScanner(document.getText(), false);\n  var token = scanner.scan();\n\n  function addRange(range) {\n    ranges.push(range);\n    nestingLevels.push(stack.length);\n  }\n\n  while (token !== 17\n  /* EOF */\n  ) {\n    switch (token) {\n      case 1\n      /* OpenBraceToken */\n      :\n      case 3\n      /* OpenBracketToken */\n      :\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var range = {\n            startLine: startLine,\n            endLine: startLine,\n            kind: token === 1\n            /* OpenBraceToken */\n            ? 'object' : 'array'\n          };\n          stack.push(range);\n          break;\n        }\n\n      case 2\n      /* CloseBraceToken */\n      :\n      case 4\n      /* CloseBracketToken */\n      :\n        {\n          var kind = token === 2\n          /* CloseBraceToken */\n          ? 'object' : 'array';\n\n          if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n            var range = stack.pop();\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n\n            if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n              range.endLine = line - 1;\n              addRange(range);\n              prevStart = range.startLine;\n            }\n          }\n\n          break;\n        }\n\n      case 13\n      /* BlockCommentTrivia */\n      :\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n\n          if (scanner.getTokenError() === 1\n          /* UnexpectedEndOfComment */\n          && startLine + 1 < document.lineCount) {\n            scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\n          } else {\n            if (startLine < endLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine,\n                kind: FoldingRangeKind.Comment\n              });\n              prevStart = startLine;\n            }\n          }\n\n          break;\n        }\n\n      case 12\n      /* LineCommentTrivia */\n      :\n        {\n          var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n          var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n\n          if (m) {\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n\n            if (m[1]) {\n              // start pattern match\n              var range = {\n                startLine: line,\n                endLine: line,\n                kind: FoldingRangeKind.Region\n              };\n              stack.push(range);\n            } else {\n              var i = stack.length - 1;\n\n              while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                i--;\n              }\n\n              if (i >= 0) {\n                var range = stack[i];\n                stack.length = i;\n\n                if (line > range.startLine && prevStart !== range.startLine) {\n                  range.endLine = line;\n                  addRange(range);\n                  prevStart = range.startLine;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  var rangeLimit = context && context.rangeLimit;\n\n  if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n    return ranges;\n  }\n\n  if (context && context.onRangeLimitExceeded) {\n    context.onRangeLimitExceeded(document.uri);\n  }\n\n  var counts = [];\n\n  for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {\n    var level = nestingLevels_1[_i];\n\n    if (level < 30) {\n      counts[level] = (counts[level] || 0) + 1;\n    }\n  }\n\n  var entries = 0;\n  var maxLevel = 0;\n\n  for (var i = 0; i < counts.length; i++) {\n    var n = counts[i];\n\n    if (n) {\n      if (n + entries > rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n\n      entries += n;\n    }\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i++) {\n    var level = nestingLevels[i];\n\n    if (typeof level === 'number') {\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonFolding.js"],"names":["createScanner","FoldingRangeKind","Position","getFoldingRanges","document","context","ranges","nestingLevels","stack","prevStart","scanner","getText","token","scan","addRange","range","push","length","startLine","positionAt","getTokenOffset","line","endLine","kind","pop","getTokenLength","getTokenError","lineCount","setPosition","offsetAt","create","Comment","text","substr","m","match","Region","i","rangeLimit","onRangeLimitExceeded","uri","counts","_i","nestingLevels_1","level","entries","maxLevel","n","result"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './../../jsonc-parser/main.js';\nimport { FoldingRangeKind, Position } from '../jsonLanguageTypes.js';\nexport function getFoldingRanges(document, context) {\n    var ranges = [];\n    var nestingLevels = [];\n    var stack = [];\n    var prevStart = -1;\n    var scanner = createScanner(document.getText(), false);\n    var token = scanner.scan();\n    function addRange(range) {\n        ranges.push(range);\n        nestingLevels.push(stack.length);\n    }\n    while (token !== 17 /* EOF */) {\n        switch (token) {\n            case 1 /* OpenBraceToken */:\n            case 3 /* OpenBracketToken */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var range = { startLine: startLine, endLine: startLine, kind: token === 1 /* OpenBraceToken */ ? 'object' : 'array' };\n                stack.push(range);\n                break;\n            }\n            case 2 /* CloseBraceToken */:\n            case 4 /* CloseBracketToken */: {\n                var kind = token === 2 /* CloseBraceToken */ ? 'object' : 'array';\n                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n                    var range = stack.pop();\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n                        range.endLine = line - 1;\n                        addRange(range);\n                        prevStart = range.startLine;\n                    }\n                }\n                break;\n            }\n            case 13 /* BlockCommentTrivia */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                if (scanner.getTokenError() === 1 /* UnexpectedEndOfComment */ && startLine + 1 < document.lineCount) {\n                    scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\n                }\n                else {\n                    if (startLine < endLine) {\n                        addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Comment });\n                        prevStart = startLine;\n                    }\n                }\n                break;\n            }\n            case 12 /* LineCommentTrivia */: {\n                var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n                var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (m[1]) { // start pattern match\n                        var range = { startLine: line, endLine: line, kind: FoldingRangeKind.Region };\n                        stack.push(range);\n                    }\n                    else {\n                        var i = stack.length - 1;\n                        while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            var range = stack[i];\n                            stack.length = i;\n                            if (line > range.startLine && prevStart !== range.startLine) {\n                                range.endLine = line;\n                                addRange(range);\n                                prevStart = range.startLine;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    var rangeLimit = context && context.rangeLimit;\n    if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n        return ranges;\n    }\n    if (context && context.onRangeLimitExceeded) {\n        context.onRangeLimitExceeded(document.uri);\n    }\n    var counts = [];\n    for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {\n        var level = nestingLevels_1[_i];\n        if (level < 30) {\n            counts[level] = (counts[level] || 0) + 1;\n        }\n    }\n    var entries = 0;\n    var maxLevel = 0;\n    for (var i = 0; i < counts.length; i++) {\n        var n = counts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    var result = [];\n    for (var i = 0; i < ranges.length; i++) {\n        var level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}