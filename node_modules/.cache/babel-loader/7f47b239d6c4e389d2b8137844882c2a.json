{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\n\nvar MinimapCharRendererFactory =\n/** @class */\nfunction () {\n  function MinimapCharRendererFactory() {}\n  /**\r\n   * Creates a new character renderer factory with the given scale.\r\n   */\n\n\n  MinimapCharRendererFactory.create = function (scale, fontFamily) {\n    // renderers are immutable. By default we'll 'create' a new minimap\n    // character renderer whenever we switch editors, no need to do extra work.\n    if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n      return this.lastCreated;\n    }\n\n    var factory;\n\n    if (prebakedMiniMaps[scale]) {\n      factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n    } else {\n      factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n    }\n\n    this.lastFontFamily = fontFamily;\n    this.lastCreated = factory;\n    return factory;\n  };\n  /**\r\n   * Creates the font sample data, writing to a canvas.\r\n   */\n\n\n  MinimapCharRendererFactory.createSampleData = function (fontFamily) {\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    canvas.style.height = 16\n    /* SAMPLED_CHAR_HEIGHT */\n    + \"px\";\n    canvas.height = 16\n    /* SAMPLED_CHAR_HEIGHT */\n    ;\n    canvas.width = 96\n    /* CHAR_COUNT */\n    * 10\n    /* SAMPLED_CHAR_WIDTH */\n    ;\n    canvas.style.width = 96\n    /* CHAR_COUNT */\n    * 10\n    /* SAMPLED_CHAR_WIDTH */\n    + 'px';\n    ctx.fillStyle = '#ffffff';\n    ctx.font = \"bold \" + 16\n    /* SAMPLED_CHAR_HEIGHT */\n    + \"px \" + fontFamily;\n    ctx.textBaseline = 'middle';\n    var x = 0;\n\n    for (var _i = 0, allCharCodes_1 = allCharCodes; _i < allCharCodes_1.length; _i++) {\n      var code = allCharCodes_1[_i];\n      ctx.fillText(String.fromCharCode(code), x, 16\n      /* SAMPLED_CHAR_HEIGHT */\n      / 2);\n      x += 10\n      /* SAMPLED_CHAR_WIDTH */\n      ;\n    }\n\n    return ctx.getImageData(0, 0, 96\n    /* CHAR_COUNT */\n    * 10\n    /* SAMPLED_CHAR_WIDTH */\n    , 16\n    /* SAMPLED_CHAR_HEIGHT */\n    );\n  };\n  /**\r\n   * Creates a character renderer from the canvas sample data.\r\n   */\n\n\n  MinimapCharRendererFactory.createFromSampleData = function (source, scale) {\n    var expectedLength = 16\n    /* SAMPLED_CHAR_HEIGHT */\n    * 10\n    /* SAMPLED_CHAR_WIDTH */\n    * 4\n    /* RGBA_CHANNELS_CNT */\n    * 96\n    /* CHAR_COUNT */\n    ;\n\n    if (source.length !== expectedLength) {\n      throw new Error('Unexpected source in MinimapCharRenderer');\n    }\n\n    var charData = MinimapCharRendererFactory._downsample(source, scale);\n\n    return new MinimapCharRenderer(charData, scale);\n  };\n\n  MinimapCharRendererFactory._downsampleChar = function (source, sourceOffset, dest, destOffset, scale) {\n    var width = 1\n    /* BASE_CHAR_WIDTH */\n    * scale;\n    var height = 2\n    /* BASE_CHAR_HEIGHT */\n    * scale;\n    var targetIndex = destOffset;\n    var brightest = 0; // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n    // like bicubic interpolation are awesome for scaling between image sizes,\n    // but don't work so well when scaling to very small pixel values, we end\n    // up with blurry, indistinct forms.\n    //\n    // The approach taken here is simply mapping each source pixel to the target\n    // pixels, and taking the weighted values for all pixels in each, and then\n    // averaging them out. Finally we apply an intensity boost in _downsample,\n    // since when scaling to the smallest pixel sizes there's more black space\n    // which causes characters to be much less distinct.\n\n    for (var y = 0; y < height; y++) {\n      // 1. For this destination pixel, get the source pixels we're sampling\n      // from (x1, y1) to the next pixel (x2, y2)\n      var sourceY1 = y / height * 16\n      /* SAMPLED_CHAR_HEIGHT */\n      ;\n      var sourceY2 = (y + 1) / height * 16\n      /* SAMPLED_CHAR_HEIGHT */\n      ;\n\n      for (var x = 0; x < width; x++) {\n        var sourceX1 = x / width * 10\n        /* SAMPLED_CHAR_WIDTH */\n        ;\n        var sourceX2 = (x + 1) / width * 10\n        /* SAMPLED_CHAR_WIDTH */\n        ; // 2. Sample all of them, summing them up and weighting them. Similar\n        // to bilinear interpolation.\n\n        var value = 0;\n        var samples = 0;\n\n        for (var sy = sourceY1; sy < sourceY2; sy++) {\n          var sourceRow = sourceOffset + Math.floor(sy) * 3840\n          /* RGBA_SAMPLED_ROW_WIDTH */\n          ;\n          var yBalance = 1 - (sy - Math.floor(sy));\n\n          for (var sx = sourceX1; sx < sourceX2; sx++) {\n            var xBalance = 1 - (sx - Math.floor(sx));\n            var sourceIndex = sourceRow + Math.floor(sx) * 4\n            /* RGBA_CHANNELS_CNT */\n            ;\n            var weight = xBalance * yBalance;\n            samples += weight;\n            value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;\n          }\n        }\n\n        var final = value / samples;\n        brightest = Math.max(brightest, final);\n        dest[targetIndex++] = final;\n      }\n    }\n\n    return brightest;\n  };\n\n  MinimapCharRendererFactory._downsample = function (data, scale) {\n    var pixelsPerCharacter = 2\n    /* BASE_CHAR_HEIGHT */\n    * scale * 1\n    /* BASE_CHAR_WIDTH */\n    * scale;\n    var resultLen = pixelsPerCharacter * 96\n    /* CHAR_COUNT */\n    ;\n    var result = new Uint8ClampedArray(resultLen);\n    var resultOffset = 0;\n    var sourceOffset = 0;\n    var brightest = 0;\n\n    for (var charIndex = 0; charIndex < 96\n    /* CHAR_COUNT */\n    ; charIndex++) {\n      brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n      resultOffset += pixelsPerCharacter;\n      sourceOffset += 10\n      /* SAMPLED_CHAR_WIDTH */\n      * 4\n      /* RGBA_CHANNELS_CNT */\n      ;\n    }\n\n    if (brightest > 0) {\n      var adjust = 255 / brightest;\n\n      for (var i = 0; i < resultLen; i++) {\n        result[i] *= adjust;\n      }\n    }\n\n    return result;\n  };\n\n  return MinimapCharRendererFactory;\n}();\n\nexport { MinimapCharRendererFactory };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js"],"names":["MinimapCharRenderer","allCharCodes","prebakedMiniMaps","MinimapCharRendererFactory","create","scale","fontFamily","lastCreated","lastFontFamily","factory","createFromSampleData","createSampleData","data","canvas","document","createElement","ctx","getContext","style","height","width","fillStyle","font","textBaseline","x","_i","allCharCodes_1","length","code","fillText","String","fromCharCode","getImageData","source","expectedLength","Error","charData","_downsample","_downsampleChar","sourceOffset","dest","destOffset","targetIndex","brightest","y","sourceY1","sourceY2","sourceX1","sourceX2","value","samples","sy","sourceRow","Math","floor","yBalance","sx","xBalance","sourceIndex","weight","final","max","pixelsPerCharacter","resultLen","result","Uint8ClampedArray","resultOffset","charIndex","adjust","i"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\r\nimport { allCharCodes } from './minimapCharSheet.js';\r\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\r\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\r\nvar MinimapCharRendererFactory = /** @class */ (function () {\r\n    function MinimapCharRendererFactory() {\r\n    }\r\n    /**\r\n     * Creates a new character renderer factory with the given scale.\r\n     */\r\n    MinimapCharRendererFactory.create = function (scale, fontFamily) {\r\n        // renderers are immutable. By default we'll 'create' a new minimap\r\n        // character renderer whenever we switch editors, no need to do extra work.\r\n        if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\r\n            return this.lastCreated;\r\n        }\r\n        var factory;\r\n        if (prebakedMiniMaps[scale]) {\r\n            factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\r\n        }\r\n        else {\r\n            factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\r\n        }\r\n        this.lastFontFamily = fontFamily;\r\n        this.lastCreated = factory;\r\n        return factory;\r\n    };\r\n    /**\r\n     * Creates the font sample data, writing to a canvas.\r\n     */\r\n    MinimapCharRendererFactory.createSampleData = function (fontFamily) {\r\n        var canvas = document.createElement('canvas');\r\n        var ctx = canvas.getContext('2d');\r\n        canvas.style.height = 16 /* SAMPLED_CHAR_HEIGHT */ + \"px\";\r\n        canvas.height = 16 /* SAMPLED_CHAR_HEIGHT */;\r\n        canvas.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */;\r\n        canvas.style.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */ + 'px';\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = \"bold \" + 16 /* SAMPLED_CHAR_HEIGHT */ + \"px \" + fontFamily;\r\n        ctx.textBaseline = 'middle';\r\n        var x = 0;\r\n        for (var _i = 0, allCharCodes_1 = allCharCodes; _i < allCharCodes_1.length; _i++) {\r\n            var code = allCharCodes_1[_i];\r\n            ctx.fillText(String.fromCharCode(code), x, 16 /* SAMPLED_CHAR_HEIGHT */ / 2);\r\n            x += 10 /* SAMPLED_CHAR_WIDTH */;\r\n        }\r\n        return ctx.getImageData(0, 0, 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */, 16 /* SAMPLED_CHAR_HEIGHT */);\r\n    };\r\n    /**\r\n     * Creates a character renderer from the canvas sample data.\r\n     */\r\n    MinimapCharRendererFactory.createFromSampleData = function (source, scale) {\r\n        var expectedLength = 16 /* SAMPLED_CHAR_HEIGHT */ * 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */ * 96 /* CHAR_COUNT */;\r\n        if (source.length !== expectedLength) {\r\n            throw new Error('Unexpected source in MinimapCharRenderer');\r\n        }\r\n        var charData = MinimapCharRendererFactory._downsample(source, scale);\r\n        return new MinimapCharRenderer(charData, scale);\r\n    };\r\n    MinimapCharRendererFactory._downsampleChar = function (source, sourceOffset, dest, destOffset, scale) {\r\n        var width = 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        var height = 2 /* BASE_CHAR_HEIGHT */ * scale;\r\n        var targetIndex = destOffset;\r\n        var brightest = 0;\r\n        // This is essentially an ad-hoc rescaling algorithm. Standard approaches\r\n        // like bicubic interpolation are awesome for scaling between image sizes,\r\n        // but don't work so well when scaling to very small pixel values, we end\r\n        // up with blurry, indistinct forms.\r\n        //\r\n        // The approach taken here is simply mapping each source pixel to the target\r\n        // pixels, and taking the weighted values for all pixels in each, and then\r\n        // averaging them out. Finally we apply an intensity boost in _downsample,\r\n        // since when scaling to the smallest pixel sizes there's more black space\r\n        // which causes characters to be much less distinct.\r\n        for (var y = 0; y < height; y++) {\r\n            // 1. For this destination pixel, get the source pixels we're sampling\r\n            // from (x1, y1) to the next pixel (x2, y2)\r\n            var sourceY1 = (y / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            var sourceY2 = ((y + 1) / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            for (var x = 0; x < width; x++) {\r\n                var sourceX1 = (x / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                var sourceX2 = ((x + 1) / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                // 2. Sample all of them, summing them up and weighting them. Similar\r\n                // to bilinear interpolation.\r\n                var value = 0;\r\n                var samples = 0;\r\n                for (var sy = sourceY1; sy < sourceY2; sy++) {\r\n                    var sourceRow = sourceOffset + Math.floor(sy) * 3840 /* RGBA_SAMPLED_ROW_WIDTH */;\r\n                    var yBalance = 1 - (sy - Math.floor(sy));\r\n                    for (var sx = sourceX1; sx < sourceX2; sx++) {\r\n                        var xBalance = 1 - (sx - Math.floor(sx));\r\n                        var sourceIndex = sourceRow + Math.floor(sx) * 4 /* RGBA_CHANNELS_CNT */;\r\n                        var weight = xBalance * yBalance;\r\n                        samples += weight;\r\n                        value += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\r\n                    }\r\n                }\r\n                var final = value / samples;\r\n                brightest = Math.max(brightest, final);\r\n                dest[targetIndex++] = final;\r\n            }\r\n        }\r\n        return brightest;\r\n    };\r\n    MinimapCharRendererFactory._downsample = function (data, scale) {\r\n        var pixelsPerCharacter = 2 /* BASE_CHAR_HEIGHT */ * scale * 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        var resultLen = pixelsPerCharacter * 96 /* CHAR_COUNT */;\r\n        var result = new Uint8ClampedArray(resultLen);\r\n        var resultOffset = 0;\r\n        var sourceOffset = 0;\r\n        var brightest = 0;\r\n        for (var charIndex = 0; charIndex < 96 /* CHAR_COUNT */; charIndex++) {\r\n            brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\r\n            resultOffset += pixelsPerCharacter;\r\n            sourceOffset += 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */;\r\n        }\r\n        if (brightest > 0) {\r\n            var adjust = 255 / brightest;\r\n            for (var i = 0; i < resultLen; i++) {\r\n                result[i] *= adjust;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return MinimapCharRendererFactory;\r\n}());\r\nexport { MinimapCharRendererFactory };\r\n"]},"metadata":{},"sourceType":"module"}