{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\n\nfunction createWordRegExp(allowInWords) {\n  if (allowInWords === void 0) {\n    allowInWords = '';\n  }\n\n  var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\n  for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\n    var sep = USUAL_WORD_SEPARATORS_1[_i];\n\n    if (allowInWords.indexOf(sep) >= 0) {\n      continue;\n    }\n\n    source += '\\\\' + sep;\n  }\n\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n} // catches numbers (including floating numbers) in the first group, and alphanum in the second\n\n\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  var result = DEFAULT_WORD_REGEXP;\n\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      var flags = 'g';\n\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n\n  result.lastIndex = 0;\n  return result;\n}\n\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\n  // find whitespace enclosed text around column and match from there\n  var pos = column - 1 - textOffset;\n  var start = text.lastIndexOf(' ', pos - 1) + 1;\n  wordDefinition.lastIndex = start;\n  var match;\n\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return {\n        word: match[0],\n        startColumn: textOffset + 1 + matchIndex,\n        endColumn: textOffset + 1 + wordDefinition.lastIndex\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\n  // matches all words starting at the beginning\n  // of the input until it finds a match that encloses\n  // the desired column. slow but correct\n  var pos = column - 1 - textOffset;\n  wordDefinition.lastIndex = 0;\n  var match;\n\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n\n    if (matchIndex > pos) {\n      // |nW -> matched only after the pos\n      return null;\n    } else if (wordDefinition.lastIndex >= pos) {\n      // W|W -> match encloses pos\n      return {\n        word: match[0],\n        startColumn: textOffset + 1 + matchIndex,\n        endColumn: textOffset + 1 + wordDefinition.lastIndex\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\n  // if `words` can contain whitespace character we have to use the slow variant\n  // otherwise we use the fast variant of finding a word\n  wordDefinition.lastIndex = 0;\n  var match = wordDefinition.exec(text);\n\n  if (!match) {\n    return null;\n  } // todo@joh the `match` could already be the (first) word\n\n\n  var ret = match[0].indexOf(' ') >= 0 // did match a word which contains a space character -> use slow word find\n  ? getWordAtPosSlow(column, wordDefinition, text, textOffset) // sane word definition -> use fast word find\n  : getWordAtPosFast(column, wordDefinition, text, textOffset); // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n  // in an undefined state and to not confuse other users of the wordDefinition\n  // we reset the lastIndex\n\n  wordDefinition.lastIndex = 0;\n  return ret;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js"],"names":["USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","_i","USUAL_WORD_SEPARATORS_1","length","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","getWordAtPosFast","column","text","textOffset","pos","start","lastIndexOf","match","exec","matchIndex","index","word","startColumn","endColumn","getWordAtPosSlow","getWordAtText","ret"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords) {\r\n    if (allowInWords === void 0) { allowInWords = ''; }\r\n    var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\r\n        var sep = USUAL_WORD_SEPARATORS_1[_i];\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\r\nexport function ensureValidWordDefinition(wordDefinition) {\r\n    var result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            var flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\r\n    // find whitespace enclosed text around column and match from there\r\n    var pos = column - 1 - textOffset;\r\n    var start = text.lastIndexOf(' ', pos - 1) + 1;\r\n    wordDefinition.lastIndex = start;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\r\n    // matches all words starting at the beginning\r\n    // of the input until it finds a match that encloses\r\n    // the desired column. slow but correct\r\n    var pos = column - 1 - textOffset;\r\n    wordDefinition.lastIndex = 0;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex > pos) {\r\n            // |nW -> matched only after the pos\r\n            return null;\r\n        }\r\n        else if (wordDefinition.lastIndex >= pos) {\r\n            // W|W -> match encloses pos\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\r\n    // if `words` can contain whitespace character we have to use the slow variant\r\n    // otherwise we use the fast variant of finding a word\r\n    wordDefinition.lastIndex = 0;\r\n    var match = wordDefinition.exec(text);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    // todo@joh the `match` could already be the (first) word\r\n    var ret = match[0].indexOf(' ') >= 0\r\n        // did match a word which contains a space character -> use slow word find\r\n        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\r\n        // sane word definition -> use fast word find\r\n        : getWordAtPosFast(column, wordDefinition, text, textOffset);\r\n    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\r\n    // in an undefined state and to not confuse other users of the wordDefinition\r\n    // we reset the lastIndex\r\n    wordDefinition.lastIndex = 0;\r\n    return ret;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}