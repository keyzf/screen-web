{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js'; // const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\n\nexport var AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n  var r;\n\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n\n  r.set(arr, 0);\n  return r;\n}\n\nvar LineStarts =\n/** @class */\nfunction () {\n  function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n    this.lineStarts = lineStarts;\n    this.cr = cr;\n    this.lf = lf;\n    this.crlf = crlf;\n    this.isBasicASCII = isBasicASCII;\n  }\n\n  return LineStarts;\n}();\n\nexport { LineStarts };\nexport function createLineStartsFast(str, readonly) {\n  if (readonly === void 0) {\n    readonly = true;\n  }\n\n  var r = [0],\n      rLength = 1;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          // \\r... case\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        r[rLength++] = i + 1;\n      }\n  }\n\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  var rLength = 1;\n  var cr = 0,\n      lf = 0,\n      crlf = 0;\n  var isBasicASCII = true;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            crlf++;\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          cr++; // \\r... case\n\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        lf++;\n        r[rLength++] = i + 1;\n      } else {\n      if (isBasicASCII) {\n        if (chr !== 9\n        /* Tab */\n        && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n\n  var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\n\nvar Piece =\n/** @class */\nfunction () {\n  function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n    this.bufferIndex = bufferIndex;\n    this.start = start;\n    this.end = end;\n    this.lineFeedCnt = lineFeedCnt;\n    this.length = length;\n  }\n\n  return Piece;\n}();\n\nexport { Piece };\n\nvar StringBuffer =\n/** @class */\nfunction () {\n  function StringBuffer(buffer, lineStarts) {\n    this.buffer = buffer;\n    this.lineStarts = lineStarts;\n  }\n\n  return StringBuffer;\n}();\n\nexport { StringBuffer };\n\nvar PieceTreeSearchCache =\n/** @class */\nfunction () {\n  function PieceTreeSearchCache(limit) {\n    this._limit = limit;\n    this._cache = [];\n  }\n\n  PieceTreeSearchCache.prototype.get = function (offset) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n\n      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n\n      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeSearchCache.prototype.set = function (nodePosition) {\n    if (this._cache.length >= this._limit) {\n      this._cache.shift();\n    }\n\n    this._cache.push(nodePosition);\n  };\n\n  PieceTreeSearchCache.prototype.valdiate = function (offset) {\n    var hasInvalidVal = false;\n    var tmp = this._cache;\n\n    for (var i = 0; i < tmp.length; i++) {\n      var nodePos = tmp[i];\n\n      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n        tmp[i] = null;\n        hasInvalidVal = true;\n        continue;\n      }\n    }\n\n    if (hasInvalidVal) {\n      var newArr = [];\n\n      for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\n        var entry = tmp_1[_i];\n\n        if (entry !== null) {\n          newArr.push(entry);\n        }\n      }\n\n      this._cache = newArr;\n    }\n  };\n\n  return PieceTreeSearchCache;\n}();\n\nvar PieceTreeBase =\n/** @class */\nfunction () {\n  function PieceTreeBase(chunks, eol, eolNormalized) {\n    this.create(chunks, eol, eolNormalized);\n  }\n\n  PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\n    this._buffers = [new StringBuffer('', [0])];\n    this._lastChangeBufferPos = {\n      line: 0,\n      column: 0\n    };\n    this.root = SENTINEL;\n    this._lineCnt = 1;\n    this._length = 0;\n    this._EOL = eol;\n    this._EOLLength = eol.length;\n    this._EOLNormalized = eolNormalized;\n    var lastNode = null;\n\n    for (var i = 0, len = chunks.length; i < len; i++) {\n      if (chunks[i].buffer.length > 0) {\n        if (!chunks[i].lineStarts) {\n          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n        }\n\n        var piece = new Piece(i + 1, {\n          line: 0,\n          column: 0\n        }, {\n          line: chunks[i].lineStarts.length - 1,\n          column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n        }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n\n        this._buffers.push(chunks[i]);\n\n        lastNode = this.rbInsertRight(lastNode, piece);\n      }\n    }\n\n    this._searchCache = new PieceTreeSearchCache(1);\n    this._lastVisitedLine = {\n      lineNumber: 0,\n      value: ''\n    };\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.normalizeEOL = function (eol) {\n    var _this = this;\n\n    var averageBufferSize = AverageBufferSize;\n    var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n    var max = min * 2;\n    var tempChunk = '';\n    var tempChunkLen = 0;\n    var chunks = [];\n    this.iterate(this.root, function (node) {\n      var str = _this.getNodeContent(node);\n\n      var len = str.length;\n\n      if (tempChunkLen <= min || tempChunkLen + len < max) {\n        tempChunk += str;\n        tempChunkLen += len;\n        return true;\n      } // flush anyways\n\n\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      tempChunk = str;\n      tempChunkLen = len;\n      return true;\n    });\n\n    if (tempChunkLen > 0) {\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n    }\n\n    this.create(chunks, eol, true);\n  }; // #region Buffer API\n\n\n  PieceTreeBase.prototype.getEOL = function () {\n    return this._EOL;\n  };\n\n  PieceTreeBase.prototype.setEOL = function (newEOL) {\n    this._EOL = newEOL;\n    this._EOLLength = this._EOL.length;\n    this.normalizeEOL(newEOL);\n  };\n\n  PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\n    var leftLen = 0; // inorder\n\n    var x = this.root;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n        leftLen += x.size_left; // lineNumber >= 2\n\n        var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        return leftLen += accumualtedValInCurrentIndex + column - 1;\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        leftLen += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return leftLen;\n  };\n\n  PieceTreeBase.prototype.getPositionAt = function (offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    var x = this.root;\n    var lfCnt = 0;\n    var originalOffset = offset;\n\n    while (x !== SENTINEL) {\n      if (x.size_left !== 0 && x.size_left >= offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        var out = this.getIndexOf(x, offset - x.size_left);\n        lfCnt += x.lf_left + out.index;\n\n        if (out.index === 0) {\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        }\n\n        return new Position(lfCnt + 1, out.remainder + 1);\n      } else {\n        offset -= x.size_left + x.piece.length;\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n        if (x.right === SENTINEL) {\n          // last node\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - offset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        } else {\n          x = x.right;\n        }\n      }\n    }\n\n    return new Position(1, 1);\n  };\n\n  PieceTreeBase.prototype.getValueInRange = function (range, eol) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      return '';\n    }\n\n    var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n    var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n    var value = this.getValueInRange2(startPosition, endPosition);\n\n    if (eol) {\n      if (eol !== this._EOL || !this._EOLNormalized) {\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n\n      if (eol === this.getEOL() && this._EOLNormalized) {\n        if (eol === '\\r\\n') {}\n\n        return value;\n      }\n\n      return value.replace(/\\r\\n|\\r|\\n/g, eol);\n    }\n\n    return value;\n  };\n\n  PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\n    if (startPosition.node === endPosition.node) {\n      var node = startPosition.node;\n      var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\n      var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\n    }\n\n    var x = startPosition.node;\n    var buffer = this._buffers[x.piece.bufferIndex].buffer;\n    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n    var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (x === endPosition.node) {\n        ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\n        break;\n      } else {\n        ret += buffer_2.substr(startOffset_2, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  };\n\n  PieceTreeBase.prototype.getLinesContent = function () {\n    var _this = this;\n\n    var lines = [];\n    var linesLength = 0;\n    var currentLine = '';\n    var danglingCR = false;\n    this.iterate(this.root, function (node) {\n      if (node === SENTINEL) {\n        return true;\n      }\n\n      var piece = node.piece;\n      var pieceLength = piece.length;\n\n      if (pieceLength === 0) {\n        return true;\n      }\n\n      var buffer = _this._buffers[piece.bufferIndex].buffer;\n      var lineStarts = _this._buffers[piece.bufferIndex].lineStarts;\n      var pieceStartLine = piece.start.line;\n      var pieceEndLine = piece.end.line;\n      var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n      if (danglingCR) {\n        if (buffer.charCodeAt(pieceStartOffset) === 10\n        /* LineFeed */\n        ) {\n            // pretend the \\n was in the previous piece..\n            pieceStartOffset++;\n            pieceLength--;\n          }\n\n        lines[linesLength++] = currentLine;\n        currentLine = '';\n        danglingCR = false;\n\n        if (pieceLength === 0) {\n          return true;\n        }\n      }\n\n      if (pieceStartLine === pieceEndLine) {\n        // this piece has no new lines\n        if (!_this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13\n        /* CarriageReturn */\n        ) {\n            danglingCR = true;\n            currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n          } else {\n          currentLine += buffer.substr(pieceStartOffset, pieceLength);\n        }\n\n        return true;\n      } // add the text before the first line start in this piece\n\n\n      currentLine += _this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n      lines[linesLength++] = currentLine;\n\n      for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\n        currentLine = _this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n        lines[linesLength++] = currentLine;\n      }\n\n      if (!_this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13\n      /* CarriageReturn */\n      ) {\n          danglingCR = true;\n\n          if (piece.end.column === 0) {\n            // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n            linesLength--;\n          } else {\n            currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n          }\n        } else {\n        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n      }\n\n      return true;\n    });\n\n    if (danglingCR) {\n      lines[linesLength++] = currentLine;\n      currentLine = '';\n    }\n\n    lines[linesLength++] = currentLine;\n    return lines;\n  };\n\n  PieceTreeBase.prototype.getLength = function () {\n    return this._length;\n  };\n\n  PieceTreeBase.prototype.getLineCount = function () {\n    return this._lineCnt;\n  };\n\n  PieceTreeBase.prototype.getLineContent = function (lineNumber) {\n    if (this._lastVisitedLine.lineNumber === lineNumber) {\n      return this._lastVisitedLine.value;\n    }\n\n    this._lastVisitedLine.lineNumber = lineNumber;\n\n    if (lineNumber === this._lineCnt) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n    } else if (this._EOLNormalized) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n    } else {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n    }\n\n    return this._lastVisitedLine.value;\n  };\n\n  PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\n    var nodePos = this.nodeAt2(lineNumber, index + 1);\n\n    if (nodePos.remainder === nodePos.node.piece.length) {\n      // the char we want to fetch is at the head of next node.\n      var matchingNode = nodePos.node.next();\n\n      if (!matchingNode) {\n        return 0;\n      }\n\n      var buffer = this._buffers[matchingNode.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n      return buffer.buffer.charCodeAt(startOffset);\n    } else {\n      var buffer = this._buffers[nodePos.node.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n      var targetOffset = startOffset + nodePos.remainder;\n      return buffer.buffer.charCodeAt(targetOffset);\n    }\n  };\n\n  PieceTreeBase.prototype.getLineLength = function (lineNumber) {\n    if (lineNumber === this.getLineCount()) {\n      var startOffset = this.getOffsetAt(lineNumber, 1);\n      return this.getLength() - startOffset;\n    }\n\n    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n  };\n\n  PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n    var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n    var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n    var m; // Reset regex to search from the beginning\n\n    var ret = {\n      line: 0,\n      column: 0\n    };\n    var searchText;\n    var offsetInBuffer;\n\n    if (searcher._wordSeparators) {\n      searchText = buffer.buffer.substring(start, end);\n\n      offsetInBuffer = function (offset) {\n        return offset + start;\n      };\n\n      searcher.reset(-1);\n    } else {\n      searchText = buffer.buffer;\n\n      offsetInBuffer = function (offset) {\n        return offset;\n      };\n\n      searcher.reset(start);\n    }\n\n    do {\n      m = searcher.next(searchText);\n\n      if (m) {\n        if (offsetInBuffer(m.index) >= end) {\n          return resultLen;\n        }\n\n        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n        var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n        var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n        var retEndColumn = retStartColumn + m[0].length;\n        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n        if (offsetInBuffer(m.index) + m[0].length >= end) {\n          return resultLen;\n        }\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  };\n\n  PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0;\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\n    if (startPosition === null) {\n      return [];\n    }\n\n    var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\n    if (endPosition === null) {\n      return [];\n    }\n\n    var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n    if (startPosition.node === endPosition.node) {\n      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n\n    var startLineNumber = searchRange.startLineNumber;\n    var currentNode = startPosition.node;\n\n    while (currentNode !== endPosition.node) {\n      var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n      if (lineBreakCnt >= 1) {\n        // last line break position\n        var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n        var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n        var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n        var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n\n        startLineNumber += lineBreakCnt;\n      }\n\n      var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0; // search for the remaining content\n\n      if (startLineNumber === searchRange.endLineNumber) {\n        var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n\n      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n\n      if (resultLen >= limitResultCount) {\n        return result;\n      }\n\n      startLineNumber++;\n      startPosition = this.nodeAt2(startLineNumber, 1);\n      currentNode = startPosition.node;\n      start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    }\n\n    if (startLineNumber === searchRange.endLineNumber) {\n      var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n      var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    }\n\n    var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n    return result;\n  };\n\n  PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    var m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  }; // #endregion\n  // #region Piece Table\n\n\n  PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\n    if (eolNormalized === void 0) {\n      eolNormalized = false;\n    }\n\n    this._EOLNormalized = this._EOLNormalized && eolNormalized;\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (this.root !== SENTINEL) {\n      var _a = this.nodeAt(offset),\n          node = _a.node,\n          remainder = _a.remainder,\n          nodeStartOffset = _a.nodeStartOffset;\n\n      var piece = node.piece;\n      var bufferIndex = piece.bufferIndex;\n      var insertPosInBuffer = this.positionInBuffer(node, remainder);\n\n      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n        // changed buffer\n        this.appendToNode(node, value);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (nodeStartOffset === offset) {\n        this.insertContentToNodeLeft(value, node);\n\n        this._searchCache.valdiate(offset);\n      } else if (nodeStartOffset + node.piece.length > offset) {\n        // we are inserting into the middle of a node.\n        var nodesToDel = [];\n        var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n          var headOfRight = this.nodeCharCodeAt(node, remainder);\n\n          if (headOfRight === 10\n          /** \\n */\n          ) {\n              var newStart = {\n                line: newRightPiece.start.line + 1,\n                column: 0\n              };\n              newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n              value += '\\n';\n            }\n        } // reuse node for content before insertion point.\n\n\n        if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n          var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\n          if (tailOfLeft === 13\n          /** \\r */\n          ) {\n              var previousPos = this.positionInBuffer(node, remainder - 1);\n              this.deleteNodeTail(node, previousPos);\n              value = '\\r' + value;\n\n              if (node.piece.length === 0) {\n                nodesToDel.push(node);\n              }\n            } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n        } else {\n          this.deleteNodeTail(node, insertPosInBuffer);\n        }\n\n        var newPieces = this.createNewPieces(value);\n\n        if (newRightPiece.length > 0) {\n          this.rbInsertRight(node, newRightPiece);\n        }\n\n        var tmpNode = node;\n\n        for (var k = 0; k < newPieces.length; k++) {\n          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n\n        this.deleteNodes(nodesToDel);\n      } else {\n        this.insertContentToNodeRight(value, node);\n      }\n    } else {\n      // insert new node\n      var pieces = this.createNewPieces(value);\n      var node = this.rbInsertLeft(null, pieces[0]);\n\n      for (var k = 1; k < pieces.length; k++) {\n        node = this.rbInsertRight(node, pieces[k]);\n      }\n    } // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\n\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.delete = function (offset, cnt) {\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (cnt <= 0 || this.root === SENTINEL) {\n      return;\n    }\n\n    var startPosition = this.nodeAt(offset);\n    var endPosition = this.nodeAt(offset + cnt);\n    var startNode = startPosition.node;\n    var endNode = endPosition.node;\n\n    if (startNode === endNode) {\n      var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\n      var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\n\n      if (startPosition.nodeStartOffset === offset) {\n        if (cnt === startNode.piece.length) {\n          // delete node\n          var next = startNode.next();\n          rbDelete(this, startNode);\n          this.validateCRLFWithPrevNode(next);\n          this.computeBufferMetadata();\n          return;\n        }\n\n        this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\n\n        this._searchCache.valdiate(offset);\n\n        this.validateCRLFWithPrevNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n        this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\n        this.validateCRLFWithNextNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      } // delete content in the middle, this node will be splitted to nodes\n\n\n      this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\n      this.computeBufferMetadata();\n      return;\n    }\n\n    var nodesToDel = [];\n    var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n    this.deleteNodeTail(startNode, startSplitPosInBuffer);\n\n    this._searchCache.valdiate(offset);\n\n    if (startNode.piece.length === 0) {\n      nodesToDel.push(startNode);\n    } // update last touched node\n\n\n    var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n    this.deleteNodeHead(endNode, endSplitPosInBuffer);\n\n    if (endNode.piece.length === 0) {\n      nodesToDel.push(endNode);\n    } // delete nodes in between\n\n\n    var secondNode = startNode.next();\n\n    for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n      nodesToDel.push(node);\n    }\n\n    var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n    this.deleteNodes(nodesToDel);\n    this.validateCRLFWithNextNode(prev);\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\n    // we are inserting content to the beginning of node\n    var nodesToDel = [];\n\n    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n      // move `\\n` to new node.\n      var piece = node.piece;\n      var newStart = {\n        line: piece.start.line + 1,\n        column: 0\n      };\n      var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n      node.piece = nPiece;\n      value += '\\n';\n      updateTreeMetadata(this, node, -1, -1);\n\n      if (node.piece.length === 0) {\n        nodesToDel.push(node);\n      }\n    }\n\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\n    for (var k = newPieces.length - 2; k >= 0; k--) {\n      newNode = this.rbInsertLeft(newNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n    this.deleteNodes(nodesToDel);\n  };\n\n  PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\n    // we are inserting to the right of this node.\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      // move \\n to the new node.\n      value += '\\n';\n    }\n\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertRight(node, newPieces[0]);\n    var tmpNode = newNode;\n\n    for (var k = 1; k < newPieces.length; k++) {\n      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n  };\n\n  PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\n    var piece = node.piece;\n    var bufferIndex = node.piece.bufferIndex;\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    var startOffset = lineStarts[piece.start.line] + piece.start.column;\n    var offset = startOffset + remainder; // binary search offset between startOffset and endOffset\n\n    var low = piece.start.line;\n    var high = piece.end.line;\n    var mid = 0;\n    var midStop = 0;\n    var midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStart = lineStarts[mid];\n\n      if (mid === high) {\n        break;\n      }\n\n      midStop = lineStarts[mid + 1];\n\n      if (offset < midStart) {\n        high = mid - 1;\n      } else if (offset >= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n\n    if (ret) {\n      ret.line = mid;\n      ret.column = offset - midStart;\n      return null;\n    }\n\n    return {\n      line: mid,\n      column: offset - midStart\n    };\n  };\n\n  PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\n    // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n    // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n    if (end.column === 0) {\n      return end.line - start.line;\n    }\n\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n\n    if (end.line === lineStarts.length - 1) {\n      // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n      return end.line - start.line;\n    }\n\n    var nextLineStartOffset = lineStarts[end.line + 1];\n    var endOffset = lineStarts[end.line] + end.column;\n\n    if (nextLineStartOffset > endOffset + 1) {\n      // there are more than 1 character after end, which means it can't be \\n\n      return end.line - start.line;\n    } // endOffset + 1 === nextLineStartOffset\n    // character at endOffset is \\n, so we check the character before first\n    // if character at endOffset is \\r, end.column is 0 and we can't get here.\n\n\n    var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\n    var buffer = this._buffers[bufferIndex].buffer;\n\n    if (buffer.charCodeAt(previousCharOffset) === 13) {\n      return end.line - start.line + 1;\n    } else {\n      return end.line - start.line;\n    }\n  };\n\n  PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    return lineStarts[cursor.line] + cursor.column;\n  };\n\n  PieceTreeBase.prototype.deleteNodes = function (nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      rbDelete(this, nodes[i]);\n    }\n  };\n\n  PieceTreeBase.prototype.createNewPieces = function (text) {\n    if (text.length > AverageBufferSize) {\n      // the content is large, operations like substring, charCode becomes slow\n      // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n      var newPieces = [];\n\n      while (text.length > AverageBufferSize) {\n        var lastChar = text.charCodeAt(AverageBufferSize - 1);\n        var splitText = void 0;\n\n        if (lastChar === 13\n        /* CarriageReturn */\n        || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n          // last character is \\r or a high surrogate => keep it back\n          splitText = text.substring(0, AverageBufferSize - 1);\n          text = text.substring(AverageBufferSize - 1);\n        } else {\n          splitText = text.substring(0, AverageBufferSize);\n          text = text.substring(AverageBufferSize);\n        }\n\n        var lineStarts_1 = createLineStartsFast(splitText);\n        newPieces.push(new Piece(this._buffers.length,\n        /* buffer index */\n        {\n          line: 0,\n          column: 0\n        }, {\n          line: lineStarts_1.length - 1,\n          column: splitText.length - lineStarts_1[lineStarts_1.length - 1]\n        }, lineStarts_1.length - 1, splitText.length));\n\n        this._buffers.push(new StringBuffer(splitText, lineStarts_1));\n      }\n\n      var lineStarts_2 = createLineStartsFast(text);\n      newPieces.push(new Piece(this._buffers.length,\n      /* buffer index */\n      {\n        line: 0,\n        column: 0\n      }, {\n        line: lineStarts_2.length - 1,\n        column: text.length - lineStarts_2[lineStarts_2.length - 1]\n      }, lineStarts_2.length - 1, text.length));\n\n      this._buffers.push(new StringBuffer(text, lineStarts_2));\n\n      return newPieces;\n    }\n\n    var startOffset = this._buffers[0].buffer.length;\n    var lineStarts = createLineStartsFast(text, false);\n    var start = this._lastChangeBufferPos;\n\n    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n    ) {\n        this._lastChangeBufferPos = {\n          line: this._lastChangeBufferPos.line,\n          column: this._lastChangeBufferPos.column + 1\n        };\n        start = this._lastChangeBufferPos;\n\n        for (var i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset + 1;\n        }\n\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        this._buffers[0].buffer += '_' + text;\n        startOffset += 1;\n      } else {\n      if (startOffset !== 0) {\n        for (var i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset;\n        }\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += text;\n    }\n\n    var endOffset = this._buffers[0].buffer.length;\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n    var endPos = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newPiece = new Piece(0,\n    /** todo@peng */\n    start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n    this._lastChangeBufferPos = endPos;\n    return [newPiece];\n  };\n\n  PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\n    if (endOffset === void 0) {\n      endOffset = 0;\n    }\n\n    var x = this.root;\n    var ret = '';\n\n    var cache = this._searchCache.get2(lineNumber);\n\n    if (cache) {\n      x = cache.node;\n      var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n        ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n      } else {\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n        return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n      }\n    } else {\n      var nodeStartOffset = 0;\n      var originalLineNumber = lineNumber;\n\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          nodeStartOffset += x.size_left;\n\n          this._searchCache.set({\n            node: x,\n            nodeStartOffset: nodeStartOffset,\n            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n          });\n\n          return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n          break;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n    } // search in order, to find the node contains end column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n        return ret;\n      } else {\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substr(startOffset, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  };\n\n  PieceTreeBase.prototype.computeBufferMetadata = function () {\n    var x = this.root;\n    var lfCnt = 1;\n    var len = 0;\n\n    while (x !== SENTINEL) {\n      lfCnt += x.lf_left + x.piece.lineFeedCnt;\n      len += x.size_left + x.piece.length;\n      x = x.right;\n    }\n\n    this._lineCnt = lfCnt;\n    this._length = len;\n\n    this._searchCache.valdiate(this._length);\n  }; // #region node operations\n\n\n  PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\n    var piece = node.piece;\n    var pos = this.positionInBuffer(node, accumulatedValue);\n    var lineCnt = pos.line - piece.start.line;\n\n    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n      // we are checking the end of this node, so a CRLF check is necessary.\n      var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\n      if (realLineCnt !== lineCnt) {\n        // aha yes, CRLF\n        return {\n          index: realLineCnt,\n          remainder: 0\n        };\n      }\n    }\n\n    return {\n      index: lineCnt,\n      remainder: pos.column\n    };\n  };\n\n  PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\n    if (index < 0) {\n      return 0;\n    }\n\n    var piece = node.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var expectedLineStartIndex = piece.start.line + index + 1;\n\n    if (expectedLineStartIndex > piece.end.line) {\n      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n    } else {\n      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n    }\n  };\n\n  PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    var newEnd = pos;\n    var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = newEndOffset - originalEndOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n\n  PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var newStart = pos;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n    var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = originalStartOffset - newStartOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n\n  PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\n    var piece = node.piece;\n    var originalStartPos = piece.start;\n    var originalEndPos = piece.end; // old piece, originalStartPos, start\n\n    var oldLength = piece.length;\n    var oldLFCnt = piece.lineFeedCnt;\n    var newEnd = start;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt); // new right piece, end, originalEndPos\n\n    var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n    var newNode = this.rbInsertRight(node, newPiece);\n    this.validateCRLFWithPrevNode(newNode);\n  };\n\n  PieceTreeBase.prototype.appendToNode = function (node, value) {\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      value += '\\n';\n    }\n\n    var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n    var startOffset = this._buffers[0].buffer.length;\n    this._buffers[0].buffer += value;\n    var lineStarts = createLineStartsFast(value, false);\n\n    for (var i = 0; i < lineStarts.length; i++) {\n      lineStarts[i] += startOffset;\n    }\n\n    if (hitCRLF) {\n      var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\n      this._buffers[0].lineStarts.pop(); // _lastChangeBufferPos is already wrong\n\n\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line - 1,\n        column: startOffset - prevStartOffset\n      };\n    }\n\n    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n    var newEnd = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newLength = node.piece.length + value.length;\n    var oldLineFeedCnt = node.piece.lineFeedCnt;\n    var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n    this._lastChangeBufferPos = newEnd;\n    updateTreeMetadata(this, node, value.length, lf_delta);\n  };\n\n  PieceTreeBase.prototype.nodeAt = function (offset) {\n    var x = this.root;\n\n    var cache = this._searchCache.get(offset);\n\n    if (cache) {\n      return {\n        node: cache.node,\n        nodeStartOffset: cache.nodeStartOffset,\n        remainder: offset - cache.nodeStartOffset\n      };\n    }\n\n    var nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.size_left > offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        nodeStartOffset += x.size_left;\n        var ret = {\n          node: x,\n          remainder: offset - x.size_left,\n          nodeStartOffset: nodeStartOffset\n        };\n\n        this._searchCache.set(ret);\n\n        return ret;\n      } else {\n        offset -= x.size_left + x.piece.length;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\n    var x = this.root;\n    var nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n        nodeStartOffset += x.size_left;\n        return {\n          node: x,\n          remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset\n        };\n      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n        if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n          return {\n            node: x,\n            remainder: prevAccumualtedValue + column - 1,\n            nodeStartOffset: nodeStartOffset\n          };\n        } else {\n          column -= x.piece.length - prevAccumualtedValue;\n          break;\n        }\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    } // search in order, to find the node contains position.column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var nodeStartOffset_1 = this.offsetOfNode(x);\n        return {\n          node: x,\n          remainder: Math.min(column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset_1\n        };\n      } else {\n        if (x.piece.length >= column - 1) {\n          var nodeStartOffset_2 = this.offsetOfNode(x);\n          return {\n            node: x,\n            remainder: column - 1,\n            nodeStartOffset: nodeStartOffset_2\n          };\n        } else {\n          column -= x.piece.length;\n        }\n      }\n\n      x = x.next();\n    }\n\n    return null;\n  };\n\n  PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\n    if (node.piece.lineFeedCnt < 1) {\n      return -1;\n    }\n\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n    return buffer.buffer.charCodeAt(newOffset);\n  };\n\n  PieceTreeBase.prototype.offsetOfNode = function (node) {\n    if (!node) {\n      return 0;\n    }\n\n    var pos = node.size_left;\n\n    while (node !== this.root) {\n      if (node.parent.right === node) {\n        pos += node.parent.size_left + node.parent.piece.length;\n      }\n\n      node = node.parent;\n    }\n\n    return pos;\n  }; // #endregion\n  // #region CRLF\n\n\n  PieceTreeBase.prototype.shouldCheckCRLF = function () {\n    return !(this._EOLNormalized && this._EOL === '\\n');\n  };\n\n  PieceTreeBase.prototype.startWithLF = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(0) === 10;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    var piece = val.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var line = piece.start.line;\n    var startOffset = lineStarts[line] + piece.start.column;\n\n    if (line === lineStarts.length - 1) {\n      // last line, so there is no line feed at the end of this line\n      return false;\n    }\n\n    var nextLineOffset = lineStarts[line + 1];\n\n    if (nextLineOffset > startOffset + 1) {\n      return false;\n    }\n\n    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n  };\n\n  PieceTreeBase.prototype.endWithCR = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(val.length - 1) === 13;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n  };\n\n  PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\n    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n      var node = nextNode.prev();\n\n      if (this.endWithCR(node)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n\n  PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n      var nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n\n  PieceTreeBase.prototype.fixCRLF = function (prev, next) {\n    var nodesToDel = []; // update node\n\n    var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n    var newEnd;\n\n    if (prev.piece.end.column === 0) {\n      // it means, last line ends with \\r, not \\r\\n\n      newEnd = {\n        line: prev.piece.end.line - 1,\n        column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n      };\n    } else {\n      // \\r\\n\n      newEnd = {\n        line: prev.piece.end.line,\n        column: prev.piece.end.column - 1\n      };\n    }\n\n    var prevNewLength = prev.piece.length - 1;\n    var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n    updateTreeMetadata(this, prev, -1, -1);\n\n    if (prev.piece.length === 0) {\n      nodesToDel.push(prev);\n    } // update nextNode\n\n\n    var newStart = {\n      line: next.piece.start.line + 1,\n      column: 0\n    };\n    var newLength = next.piece.length - 1;\n    var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, next, -1, -1);\n\n    if (next.piece.length === 0) {\n      nodesToDel.push(next);\n    } // create new piece which contains \\r\\n\n\n\n    var pieces = this.createNewPieces('\\r\\n');\n    this.rbInsertRight(prev, pieces[0]); // delete empty nodes\n\n    for (var i = 0; i < nodesToDel.length; i++) {\n      rbDelete(this, nodesToDel[i]);\n    }\n  };\n\n  PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n      var nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        // move `\\n` forward\n        value += '\\n';\n\n        if (nextNode.piece.length === 1) {\n          rbDelete(this, nextNode);\n        } else {\n          var piece = nextNode.piece;\n          var newStart = {\n            line: piece.start.line + 1,\n            column: 0\n          };\n          var newLength = piece.length - 1;\n          var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n          updateTreeMetadata(this, nextNode, -1, -1);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }; // #endregion\n  // #endregion\n  // #region Tree operations\n\n\n  PieceTreeBase.prototype.iterate = function (node, callback) {\n    if (node === SENTINEL) {\n      return callback(SENTINEL);\n    }\n\n    var leftRet = this.iterate(node.left, callback);\n\n    if (!leftRet) {\n      return leftRet;\n    }\n\n    return callback(node) && this.iterate(node.right, callback);\n  };\n\n  PieceTreeBase.prototype.getNodeContent = function (node) {\n    if (node === SENTINEL) {\n      return '';\n    }\n\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var currentContent;\n    var piece = node.piece;\n    var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    currentContent = buffer.buffer.substring(startOffset, endOffset);\n    return currentContent;\n  };\n  /**\r\n   *      node              node\r\n   *     /  \\              /  \\\r\n   *    a   b    <----   a    b\r\n   *                         /\r\n   *                        z\r\n   */\n\n\n  PieceTreeBase.prototype.rbInsertRight = function (node, p) {\n    var z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n    var x = this.root;\n\n    if (x === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.right === SENTINEL) {\n      node.right = z;\n      z.parent = node;\n    } else {\n      var nextNode = leftest(node.right);\n      nextNode.left = z;\n      z.parent = nextNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  };\n  /**\r\n   *      node              node\r\n   *     /  \\              /  \\\r\n   *    a   b     ---->   a    b\r\n   *                       \\\r\n   *                        z\r\n   */\n\n\n  PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\n    var z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n\n    if (this.root === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.left === SENTINEL) {\n      node.left = z;\n      z.parent = node;\n    } else {\n      var prevNode = righttest(node.left); // a\n\n      prevNode.right = z;\n      z.parent = prevNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  };\n\n  return PieceTreeBase;\n}();\n\nexport { PieceTreeBase };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"names":["Position","Range","FindMatch","SENTINEL","TreeNode","fixInsert","leftest","rbDelete","righttest","updateTreeMetadata","Searcher","createFindMatch","isValidMatch","AverageBufferSize","createUintArray","arr","r","length","Uint16Array","Uint32Array","set","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","i","len","chr","charCodeAt","createLineStarts","result","Piece","bufferIndex","start","end","lineFeedCnt","StringBuffer","buffer","PieceTreeSearchCache","limit","_limit","_cache","prototype","get","offset","nodePos","nodeStartOffset","node","piece","get2","lineNumber","nodeStartLineNumber","nodePosition","shift","push","valdiate","hasInvalidVal","tmp","parent","newArr","_i","tmp_1","entry","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","column","root","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","value","computeBufferMetadata","normalizeEOL","_this","averageBufferSize","min","Math","floor","max","tempChunk","tempChunkLen","iterate","getNodeContent","text","replace","getEOL","setEOL","newEOL","getOffsetAt","leftLen","x","left","lf_left","size_left","accumualtedValInCurrentIndex","getAccumulatedValue","right","getPositionAt","lfCnt","originalOffset","out","getIndexOf","index","lineStartOffset","remainder","getValueInRange","range","startLineNumber","endLineNumber","startColumn","endColumn","startPosition","nodeAt2","endPosition","getValueInRange2","buffer_1","startOffset_1","offsetInBuffer","substring","startOffset","ret","next","buffer_2","startOffset_2","substr","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineCount","getLineContent","getLineRawContent","getLineCharCode","matchingNode","targetOffset","getLineLength","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","startColumn_1","startColumn_2","_findMatchesInLine","startColumn_3","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","insert","_a","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","delete","cnt","startNode","endNode","startSplitPosInBuffer_1","endSplitPosInBuffer_1","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","startSplitPosInBuffer","endSplitPosInBuffer","secondNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","lineStarts_1","lineStarts_2","concat","slice","endIndex","endPos","newPiece","cache","prevAccumualtedValue","accumualtedValue","originalLineNumber","accumulatedValue","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","lf_delta","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","nodeStartOffset_1","offsetOfNode","nodeStartOffset_2","newOffset","val","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","currentContent","p","z","color","prevNode"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Position } from '../../core/position.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { FindMatch } from '../../model.js';\r\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\r\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\r\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\r\nexport var AverageBufferSize = 65535;\r\nexport function createUintArray(arr) {\r\n    var r;\r\n    if (arr[arr.length - 1] < 65536) {\r\n        r = new Uint16Array(arr.length);\r\n    }\r\n    else {\r\n        r = new Uint32Array(arr.length);\r\n    }\r\n    r.set(arr, 0);\r\n    return r;\r\n}\r\nvar LineStarts = /** @class */ (function () {\r\n    function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\r\n        this.lineStarts = lineStarts;\r\n        this.cr = cr;\r\n        this.lf = lf;\r\n        this.crlf = crlf;\r\n        this.isBasicASCII = isBasicASCII;\r\n    }\r\n    return LineStarts;\r\n}());\r\nexport { LineStarts };\r\nexport function createLineStartsFast(str, readonly) {\r\n    if (readonly === void 0) { readonly = true; }\r\n    var r = [0], rLength = 1;\r\n    for (var i = 0, len = str.length; i < len; i++) {\r\n        var chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            r[rLength++] = i + 1;\r\n        }\r\n    }\r\n    if (readonly) {\r\n        return createUintArray(r);\r\n    }\r\n    else {\r\n        return r;\r\n    }\r\n}\r\nexport function createLineStarts(r, str) {\r\n    r.length = 0;\r\n    r[0] = 0;\r\n    var rLength = 1;\r\n    var cr = 0, lf = 0, crlf = 0;\r\n    var isBasicASCII = true;\r\n    for (var i = 0, len = str.length; i < len; i++) {\r\n        var chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                crlf++;\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                cr++;\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            lf++;\r\n            r[rLength++] = i + 1;\r\n        }\r\n        else {\r\n            if (isBasicASCII) {\r\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\r\n                    isBasicASCII = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\r\n    r.length = 0;\r\n    return result;\r\n}\r\nvar Piece = /** @class */ (function () {\r\n    function Piece(bufferIndex, start, end, lineFeedCnt, length) {\r\n        this.bufferIndex = bufferIndex;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.lineFeedCnt = lineFeedCnt;\r\n        this.length = length;\r\n    }\r\n    return Piece;\r\n}());\r\nexport { Piece };\r\nvar StringBuffer = /** @class */ (function () {\r\n    function StringBuffer(buffer, lineStarts) {\r\n        this.buffer = buffer;\r\n        this.lineStarts = lineStarts;\r\n    }\r\n    return StringBuffer;\r\n}());\r\nexport { StringBuffer };\r\nvar PieceTreeSearchCache = /** @class */ (function () {\r\n    function PieceTreeSearchCache(limit) {\r\n        this._limit = limit;\r\n        this._cache = [];\r\n    }\r\n    PieceTreeSearchCache.prototype.get = function (offset) {\r\n        for (var i = this._cache.length - 1; i >= 0; i--) {\r\n            var nodePos = this._cache[i];\r\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\r\n        for (var i = this._cache.length - 1; i >= 0; i--) {\r\n            var nodePos = this._cache[i];\r\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeSearchCache.prototype.set = function (nodePosition) {\r\n        if (this._cache.length >= this._limit) {\r\n            this._cache.shift();\r\n        }\r\n        this._cache.push(nodePosition);\r\n    };\r\n    PieceTreeSearchCache.prototype.valdiate = function (offset) {\r\n        var hasInvalidVal = false;\r\n        var tmp = this._cache;\r\n        for (var i = 0; i < tmp.length; i++) {\r\n            var nodePos = tmp[i];\r\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\r\n                tmp[i] = null;\r\n                hasInvalidVal = true;\r\n                continue;\r\n            }\r\n        }\r\n        if (hasInvalidVal) {\r\n            var newArr = [];\r\n            for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\r\n                var entry = tmp_1[_i];\r\n                if (entry !== null) {\r\n                    newArr.push(entry);\r\n                }\r\n            }\r\n            this._cache = newArr;\r\n        }\r\n    };\r\n    return PieceTreeSearchCache;\r\n}());\r\nvar PieceTreeBase = /** @class */ (function () {\r\n    function PieceTreeBase(chunks, eol, eolNormalized) {\r\n        this.create(chunks, eol, eolNormalized);\r\n    }\r\n    PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\r\n        this._buffers = [\r\n            new StringBuffer('', [0])\r\n        ];\r\n        this._lastChangeBufferPos = { line: 0, column: 0 };\r\n        this.root = SENTINEL;\r\n        this._lineCnt = 1;\r\n        this._length = 0;\r\n        this._EOL = eol;\r\n        this._EOLLength = eol.length;\r\n        this._EOLNormalized = eolNormalized;\r\n        var lastNode = null;\r\n        for (var i = 0, len = chunks.length; i < len; i++) {\r\n            if (chunks[i].buffer.length > 0) {\r\n                if (!chunks[i].lineStarts) {\r\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\r\n                }\r\n                var piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\r\n                this._buffers.push(chunks[i]);\r\n                lastNode = this.rbInsertRight(lastNode, piece);\r\n            }\r\n        }\r\n        this._searchCache = new PieceTreeSearchCache(1);\r\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.normalizeEOL = function (eol) {\r\n        var _this = this;\r\n        var averageBufferSize = AverageBufferSize;\r\n        var min = averageBufferSize - Math.floor(averageBufferSize / 3);\r\n        var max = min * 2;\r\n        var tempChunk = '';\r\n        var tempChunkLen = 0;\r\n        var chunks = [];\r\n        this.iterate(this.root, function (node) {\r\n            var str = _this.getNodeContent(node);\r\n            var len = str.length;\r\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\r\n                tempChunk += str;\r\n                tempChunkLen += len;\r\n                return true;\r\n            }\r\n            // flush anyways\r\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n            tempChunk = str;\r\n            tempChunkLen = len;\r\n            return true;\r\n        });\r\n        if (tempChunkLen > 0) {\r\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n        }\r\n        this.create(chunks, eol, true);\r\n    };\r\n    // #region Buffer API\r\n    PieceTreeBase.prototype.getEOL = function () {\r\n        return this._EOL;\r\n    };\r\n    PieceTreeBase.prototype.setEOL = function (newEOL) {\r\n        this._EOL = newEOL;\r\n        this._EOLLength = this._EOL.length;\r\n        this.normalizeEOL(newEOL);\r\n    };\r\n    PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\r\n        var leftLen = 0; // inorder\r\n        var x = this.root;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\r\n                leftLen += x.size_left;\r\n                // lineNumber >= 2\r\n                var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                leftLen += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return leftLen;\r\n    };\r\n    PieceTreeBase.prototype.getPositionAt = function (offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        var x = this.root;\r\n        var lfCnt = 0;\r\n        var originalOffset = offset;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left !== 0 && x.size_left >= offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                var out = this.getIndexOf(x, offset - x.size_left);\r\n                lfCnt += x.lf_left + out.index;\r\n                if (out.index === 0) {\r\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    var column = originalOffset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                return new Position(lfCnt + 1, out.remainder + 1);\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n                if (x.right === SENTINEL) {\r\n                    // last node\r\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    var column = originalOffset - offset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                else {\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        return new Position(1, 1);\r\n    };\r\n    PieceTreeBase.prototype.getValueInRange = function (range, eol) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            return '';\r\n        }\r\n        var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\r\n        var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\r\n        var value = this.getValueInRange2(startPosition, endPosition);\r\n        if (eol) {\r\n            if (eol !== this._EOL || !this._EOLNormalized) {\r\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            }\r\n            if (eol === this.getEOL() && this._EOLNormalized) {\r\n                if (eol === '\\r\\n') {\r\n                }\r\n                return value;\r\n            }\r\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n        }\r\n        return value;\r\n    };\r\n    PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\r\n        if (startPosition.node === endPosition.node) {\r\n            var node = startPosition.node;\r\n            var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\r\n            var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n            return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\r\n        }\r\n        var x = startPosition.node;\r\n        var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n        var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\r\n            var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (x === endPosition.node) {\r\n                ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\r\n                break;\r\n            }\r\n            else {\r\n                ret += buffer_2.substr(startOffset_2, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    };\r\n    PieceTreeBase.prototype.getLinesContent = function () {\r\n        var _this = this;\r\n        var lines = [];\r\n        var linesLength = 0;\r\n        var currentLine = '';\r\n        var danglingCR = false;\r\n        this.iterate(this.root, function (node) {\r\n            if (node === SENTINEL) {\r\n                return true;\r\n            }\r\n            var piece = node.piece;\r\n            var pieceLength = piece.length;\r\n            if (pieceLength === 0) {\r\n                return true;\r\n            }\r\n            var buffer = _this._buffers[piece.bufferIndex].buffer;\r\n            var lineStarts = _this._buffers[piece.bufferIndex].lineStarts;\r\n            var pieceStartLine = piece.start.line;\r\n            var pieceEndLine = piece.end.line;\r\n            var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\r\n            if (danglingCR) {\r\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\r\n                    // pretend the \\n was in the previous piece..\r\n                    pieceStartOffset++;\r\n                    pieceLength--;\r\n                }\r\n                lines[linesLength++] = currentLine;\r\n                currentLine = '';\r\n                danglingCR = false;\r\n                if (pieceLength === 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (pieceStartLine === pieceEndLine) {\r\n                // this piece has no new lines\r\n                if (!_this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\r\n                    danglingCR = true;\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\r\n                }\r\n                else {\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\r\n                }\r\n                return true;\r\n            }\r\n            // add the text before the first line start in this piece\r\n            currentLine += (_this._EOLNormalized\r\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this._EOLLength))\r\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n            lines[linesLength++] = currentLine;\r\n            for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\r\n                currentLine = (_this._EOLNormalized\r\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this._EOLLength)\r\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n                lines[linesLength++] = currentLine;\r\n            }\r\n            if (!_this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\r\n                danglingCR = true;\r\n                if (piece.end.column === 0) {\r\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\r\n                    linesLength--;\r\n                }\r\n                else {\r\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\r\n                }\r\n            }\r\n            else {\r\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\r\n            }\r\n            return true;\r\n        });\r\n        if (danglingCR) {\r\n            lines[linesLength++] = currentLine;\r\n            currentLine = '';\r\n        }\r\n        lines[linesLength++] = currentLine;\r\n        return lines;\r\n    };\r\n    PieceTreeBase.prototype.getLength = function () {\r\n        return this._length;\r\n    };\r\n    PieceTreeBase.prototype.getLineCount = function () {\r\n        return this._lineCnt;\r\n    };\r\n    PieceTreeBase.prototype.getLineContent = function (lineNumber) {\r\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\r\n            return this._lastVisitedLine.value;\r\n        }\r\n        this._lastVisitedLine.lineNumber = lineNumber;\r\n        if (lineNumber === this._lineCnt) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\r\n        }\r\n        else if (this._EOLNormalized) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\r\n        }\r\n        else {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\r\n        }\r\n        return this._lastVisitedLine.value;\r\n    };\r\n    PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\r\n        var nodePos = this.nodeAt2(lineNumber, index + 1);\r\n        if (nodePos.remainder === nodePos.node.piece.length) {\r\n            // the char we want to fetch is at the head of next node.\r\n            var matchingNode = nodePos.node.next();\r\n            if (!matchingNode) {\r\n                return 0;\r\n            }\r\n            var buffer = this._buffers[matchingNode.piece.bufferIndex];\r\n            var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\r\n            return buffer.buffer.charCodeAt(startOffset);\r\n        }\r\n        else {\r\n            var buffer = this._buffers[nodePos.node.piece.bufferIndex];\r\n            var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\r\n            var targetOffset = startOffset + nodePos.remainder;\r\n            return buffer.buffer.charCodeAt(targetOffset);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.getLineLength = function (lineNumber) {\r\n        if (lineNumber === this.getLineCount()) {\r\n            var startOffset = this.getOffsetAt(lineNumber, 1);\r\n            return this.getLength() - startOffset;\r\n        }\r\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\r\n    };\r\n    PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n        var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\r\n        var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        var ret = { line: 0, column: 0 };\r\n        var searchText;\r\n        var offsetInBuffer;\r\n        if (searcher._wordSeparators) {\r\n            searchText = buffer.buffer.substring(start, end);\r\n            offsetInBuffer = function (offset) { return offset + start; };\r\n            searcher.reset(-1);\r\n        }\r\n        else {\r\n            searchText = buffer.buffer;\r\n            offsetInBuffer = function (offset) { return offset; };\r\n            searcher.reset(start);\r\n        }\r\n        do {\r\n            m = searcher.next(searchText);\r\n            if (m) {\r\n                if (offsetInBuffer(m.index) >= end) {\r\n                    return resultLen;\r\n                }\r\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\r\n                var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\r\n                var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\r\n                var retEndColumn = retStartColumn + m[0].length;\r\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\r\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\r\n                    return resultLen;\r\n                }\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\r\n        var result = [];\r\n        var resultLen = 0;\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\r\n        if (startPosition === null) {\r\n            return [];\r\n        }\r\n        var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\r\n        if (endPosition === null) {\r\n            return [];\r\n        }\r\n        var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\r\n        if (startPosition.node === endPosition.node) {\r\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n            return result;\r\n        }\r\n        var startLineNumber = searchRange.startLineNumber;\r\n        var currentNode = startPosition.node;\r\n        while (currentNode !== endPosition.node) {\r\n            var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\r\n            if (lineBreakCnt >= 1) {\r\n                // last line break position\r\n                var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\r\n                var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\r\n                var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\r\n                var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\r\n                if (resultLen >= limitResultCount) {\r\n                    return result;\r\n                }\r\n                startLineNumber += lineBreakCnt;\r\n            }\r\n            var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            // search for the remaining content\r\n            if (startLineNumber === searchRange.endLineNumber) {\r\n                var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\r\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\r\n                return result;\r\n            }\r\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\r\n            if (resultLen >= limitResultCount) {\r\n                return result;\r\n            }\r\n            startLineNumber++;\r\n            startPosition = this.nodeAt2(startLineNumber, 1);\r\n            currentNode = startPosition.node;\r\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        }\r\n        if (startLineNumber === searchRange.endLineNumber) {\r\n            var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n        return result;\r\n    };\r\n    PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        var wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            var searchString = searchData.simpleSearch;\r\n            var searchStringLen = searchString.length;\r\n            var textLength = text.length;\r\n            var lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    // #endregion\r\n    // #region Piece Table\r\n    PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\r\n        if (eolNormalized === void 0) { eolNormalized = false; }\r\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (this.root !== SENTINEL) {\r\n            var _a = this.nodeAt(offset), node = _a.node, remainder = _a.remainder, nodeStartOffset = _a.nodeStartOffset;\r\n            var piece = node.piece;\r\n            var bufferIndex = piece.bufferIndex;\r\n            var insertPosInBuffer = this.positionInBuffer(node, remainder);\r\n            if (node.piece.bufferIndex === 0 &&\r\n                piece.end.line === this._lastChangeBufferPos.line &&\r\n                piece.end.column === this._lastChangeBufferPos.column &&\r\n                (nodeStartOffset + piece.length === offset) &&\r\n                value.length < AverageBufferSize) {\r\n                // changed buffer\r\n                this.appendToNode(node, value);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (nodeStartOffset === offset) {\r\n                this.insertContentToNodeLeft(value, node);\r\n                this._searchCache.valdiate(offset);\r\n            }\r\n            else if (nodeStartOffset + node.piece.length > offset) {\r\n                // we are inserting into the middle of a node.\r\n                var nodesToDel = [];\r\n                var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\r\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n                    var headOfRight = this.nodeCharCodeAt(node, remainder);\r\n                    if (headOfRight === 10 /** \\n */) {\r\n                        var newStart = { line: newRightPiece.start.line + 1, column: 0 };\r\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\r\n                        value += '\\n';\r\n                    }\r\n                }\r\n                // reuse node for content before insertion point.\r\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\r\n                    var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\r\n                    if (tailOfLeft === 13 /** \\r */) {\r\n                        var previousPos = this.positionInBuffer(node, remainder - 1);\r\n                        this.deleteNodeTail(node, previousPos);\r\n                        value = '\\r' + value;\r\n                        if (node.piece.length === 0) {\r\n                            nodesToDel.push(node);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.deleteNodeTail(node, insertPosInBuffer);\r\n                    }\r\n                }\r\n                else {\r\n                    this.deleteNodeTail(node, insertPosInBuffer);\r\n                }\r\n                var newPieces = this.createNewPieces(value);\r\n                if (newRightPiece.length > 0) {\r\n                    this.rbInsertRight(node, newRightPiece);\r\n                }\r\n                var tmpNode = node;\r\n                for (var k = 0; k < newPieces.length; k++) {\r\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n                }\r\n                this.deleteNodes(nodesToDel);\r\n            }\r\n            else {\r\n                this.insertContentToNodeRight(value, node);\r\n            }\r\n        }\r\n        else {\r\n            // insert new node\r\n            var pieces = this.createNewPieces(value);\r\n            var node = this.rbInsertLeft(null, pieces[0]);\r\n            for (var k = 1; k < pieces.length; k++) {\r\n                node = this.rbInsertRight(node, pieces[k]);\r\n            }\r\n        }\r\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.delete = function (offset, cnt) {\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (cnt <= 0 || this.root === SENTINEL) {\r\n            return;\r\n        }\r\n        var startPosition = this.nodeAt(offset);\r\n        var endPosition = this.nodeAt(offset + cnt);\r\n        var startNode = startPosition.node;\r\n        var endNode = endPosition.node;\r\n        if (startNode === endNode) {\r\n            var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\r\n            var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\r\n            if (startPosition.nodeStartOffset === offset) {\r\n                if (cnt === startNode.piece.length) { // delete node\r\n                    var next = startNode.next();\r\n                    rbDelete(this, startNode);\r\n                    this.validateCRLFWithPrevNode(next);\r\n                    this.computeBufferMetadata();\r\n                    return;\r\n                }\r\n                this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\r\n                this._searchCache.valdiate(offset);\r\n                this.validateCRLFWithPrevNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\r\n                this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\r\n                this.validateCRLFWithNextNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            // delete content in the middle, this node will be splitted to nodes\r\n            this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\r\n            this.computeBufferMetadata();\r\n            return;\r\n        }\r\n        var nodesToDel = [];\r\n        var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\r\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\r\n        this._searchCache.valdiate(offset);\r\n        if (startNode.piece.length === 0) {\r\n            nodesToDel.push(startNode);\r\n        }\r\n        // update last touched node\r\n        var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\r\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\r\n        if (endNode.piece.length === 0) {\r\n            nodesToDel.push(endNode);\r\n        }\r\n        // delete nodes in between\r\n        var secondNode = startNode.next();\r\n        for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\r\n            nodesToDel.push(node);\r\n        }\r\n        var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\r\n        this.deleteNodes(nodesToDel);\r\n        this.validateCRLFWithNextNode(prev);\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\r\n        // we are inserting content to the beginning of node\r\n        var nodesToDel = [];\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\r\n            // move `\\n` to new node.\r\n            var piece = node.piece;\r\n            var newStart = { line: piece.start.line + 1, column: 0 };\r\n            var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\r\n            node.piece = nPiece;\r\n            value += '\\n';\r\n            updateTreeMetadata(this, node, -1, -1);\r\n            if (node.piece.length === 0) {\r\n                nodesToDel.push(node);\r\n            }\r\n        }\r\n        var newPieces = this.createNewPieces(value);\r\n        var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\r\n        for (var k = newPieces.length - 2; k >= 0; k--) {\r\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n        this.deleteNodes(nodesToDel);\r\n    };\r\n    PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\r\n        // we are inserting to the right of this node.\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            // move \\n to the new node.\r\n            value += '\\n';\r\n        }\r\n        var newPieces = this.createNewPieces(value);\r\n        var newNode = this.rbInsertRight(node, newPieces[0]);\r\n        var tmpNode = newNode;\r\n        for (var k = 1; k < newPieces.length; k++) {\r\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    };\r\n    PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\r\n        var piece = node.piece;\r\n        var bufferIndex = node.piece.bufferIndex;\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        var startOffset = lineStarts[piece.start.line] + piece.start.column;\r\n        var offset = startOffset + remainder;\r\n        // binary search offset between startOffset and endOffset\r\n        var low = piece.start.line;\r\n        var high = piece.end.line;\r\n        var mid = 0;\r\n        var midStop = 0;\r\n        var midStart = 0;\r\n        while (low <= high) {\r\n            mid = low + ((high - low) / 2) | 0;\r\n            midStart = lineStarts[mid];\r\n            if (mid === high) {\r\n                break;\r\n            }\r\n            midStop = lineStarts[mid + 1];\r\n            if (offset < midStart) {\r\n                high = mid - 1;\r\n            }\r\n            else if (offset >= midStop) {\r\n                low = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (ret) {\r\n            ret.line = mid;\r\n            ret.column = offset - midStart;\r\n            return null;\r\n        }\r\n        return {\r\n            line: mid,\r\n            column: offset - midStart\r\n        };\r\n    };\r\n    PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\r\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\r\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\r\n        if (end.column === 0) {\r\n            return end.line - start.line;\r\n        }\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\r\n            return end.line - start.line;\r\n        }\r\n        var nextLineStartOffset = lineStarts[end.line + 1];\r\n        var endOffset = lineStarts[end.line] + end.column;\r\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\r\n            return end.line - start.line;\r\n        }\r\n        // endOffset + 1 === nextLineStartOffset\r\n        // character at endOffset is \\n, so we check the character before first\r\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\r\n        var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\r\n        var buffer = this._buffers[bufferIndex].buffer;\r\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\r\n            return end.line - start.line + 1;\r\n        }\r\n        else {\r\n            return end.line - start.line;\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        return lineStarts[cursor.line] + cursor.column;\r\n    };\r\n    PieceTreeBase.prototype.deleteNodes = function (nodes) {\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            rbDelete(this, nodes[i]);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.createNewPieces = function (text) {\r\n        if (text.length > AverageBufferSize) {\r\n            // the content is large, operations like substring, charCode becomes slow\r\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\r\n            var newPieces = [];\r\n            while (text.length > AverageBufferSize) {\r\n                var lastChar = text.charCodeAt(AverageBufferSize - 1);\r\n                var splitText = void 0;\r\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n                    // last character is \\r or a high surrogate => keep it back\r\n                    splitText = text.substring(0, AverageBufferSize - 1);\r\n                    text = text.substring(AverageBufferSize - 1);\r\n                }\r\n                else {\r\n                    splitText = text.substring(0, AverageBufferSize);\r\n                    text = text.substring(AverageBufferSize);\r\n                }\r\n                var lineStarts_1 = createLineStartsFast(splitText);\r\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_1.length - 1, column: splitText.length - lineStarts_1[lineStarts_1.length - 1] }, lineStarts_1.length - 1, splitText.length));\r\n                this._buffers.push(new StringBuffer(splitText, lineStarts_1));\r\n            }\r\n            var lineStarts_2 = createLineStartsFast(text);\r\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_2.length - 1, column: text.length - lineStarts_2[lineStarts_2.length - 1] }, lineStarts_2.length - 1, text.length));\r\n            this._buffers.push(new StringBuffer(text, lineStarts_2));\r\n            return newPieces;\r\n        }\r\n        var startOffset = this._buffers[0].buffer.length;\r\n        var lineStarts = createLineStartsFast(text, false);\r\n        var start = this._lastChangeBufferPos;\r\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\r\n            && startOffset !== 0\r\n            && this.startWithLF(text)\r\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\r\n        ) {\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\r\n            start = this._lastChangeBufferPos;\r\n            for (var i = 0; i < lineStarts.length; i++) {\r\n                lineStarts[i] += startOffset + 1;\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += '_' + text;\r\n            startOffset += 1;\r\n        }\r\n        else {\r\n            if (startOffset !== 0) {\r\n                for (var i = 0; i < lineStarts.length; i++) {\r\n                    lineStarts[i] += startOffset;\r\n                }\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += text;\r\n        }\r\n        var endOffset = this._buffers[0].buffer.length;\r\n        var endIndex = this._buffers[0].lineStarts.length - 1;\r\n        var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\r\n        var endPos = { line: endIndex, column: endColumn };\r\n        var newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\r\n        this._lastChangeBufferPos = endPos;\r\n        return [newPiece];\r\n    };\r\n    PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\r\n        if (endOffset === void 0) { endOffset = 0; }\r\n        var x = this.root;\r\n        var ret = '';\r\n        var cache = this._searchCache.get2(lineNumber);\r\n        if (cache) {\r\n            x = cache.node;\r\n            var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\r\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\r\n                ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\r\n            }\r\n            else {\r\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\r\n                return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\r\n            }\r\n        }\r\n        else {\r\n            var nodeStartOffset = 0;\r\n            var originalLineNumber = lineNumber;\r\n            while (x !== SENTINEL) {\r\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                    x = x.left;\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    nodeStartOffset += x.size_left;\r\n                    this._searchCache.set({\r\n                        node: x,\r\n                        nodeStartOffset: nodeStartOffset,\r\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\r\n                    });\r\n                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\r\n                    break;\r\n                }\r\n                else {\r\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                    nodeStartOffset += x.size_left + x.piece.length;\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        // search in order, to find the node contains end column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\r\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\r\n                return ret;\r\n            }\r\n            else {\r\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substr(startOffset, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    };\r\n    PieceTreeBase.prototype.computeBufferMetadata = function () {\r\n        var x = this.root;\r\n        var lfCnt = 1;\r\n        var len = 0;\r\n        while (x !== SENTINEL) {\r\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n            len += x.size_left + x.piece.length;\r\n            x = x.right;\r\n        }\r\n        this._lineCnt = lfCnt;\r\n        this._length = len;\r\n        this._searchCache.valdiate(this._length);\r\n    };\r\n    // #region node operations\r\n    PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\r\n        var piece = node.piece;\r\n        var pos = this.positionInBuffer(node, accumulatedValue);\r\n        var lineCnt = pos.line - piece.start.line;\r\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\r\n            // we are checking the end of this node, so a CRLF check is necessary.\r\n            var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\r\n            if (realLineCnt !== lineCnt) {\r\n                // aha yes, CRLF\r\n                return { index: realLineCnt, remainder: 0 };\r\n            }\r\n        }\r\n        return { index: lineCnt, remainder: pos.column };\r\n    };\r\n    PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\r\n        if (index < 0) {\r\n            return 0;\r\n        }\r\n        var piece = node.piece;\r\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        var expectedLineStartIndex = piece.start.line + index + 1;\r\n        if (expectedLineStartIndex > piece.end.line) {\r\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n        else {\r\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\r\n        var piece = node.piece;\r\n        var originalLFCnt = piece.lineFeedCnt;\r\n        var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        var newEnd = pos;\r\n        var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        var lf_delta = newLineFeedCnt - originalLFCnt;\r\n        var size_delta = newEndOffset - originalEndOffset;\r\n        var newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\r\n        var piece = node.piece;\r\n        var originalLFCnt = piece.lineFeedCnt;\r\n        var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        var newStart = pos;\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n        var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\r\n        var lf_delta = newLineFeedCnt - originalLFCnt;\r\n        var size_delta = originalStartOffset - newStartOffset;\r\n        var newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\r\n        var piece = node.piece;\r\n        var originalStartPos = piece.start;\r\n        var originalEndPos = piece.end;\r\n        // old piece, originalStartPos, start\r\n        var oldLength = piece.length;\r\n        var oldLFCnt = piece.lineFeedCnt;\r\n        var newEnd = start;\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\r\n        // new right piece, end, originalEndPos\r\n        var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\r\n        var newNode = this.rbInsertRight(node, newPiece);\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    };\r\n    PieceTreeBase.prototype.appendToNode = function (node, value) {\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            value += '\\n';\r\n        }\r\n        var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\r\n        var startOffset = this._buffers[0].buffer.length;\r\n        this._buffers[0].buffer += value;\r\n        var lineStarts = createLineStartsFast(value, false);\r\n        for (var i = 0; i < lineStarts.length; i++) {\r\n            lineStarts[i] += startOffset;\r\n        }\r\n        if (hitCRLF) {\r\n            var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\r\n            this._buffers[0].lineStarts.pop();\r\n            // _lastChangeBufferPos is already wrong\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\r\n        }\r\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n        var endIndex = this._buffers[0].lineStarts.length - 1;\r\n        var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\r\n        var newEnd = { line: endIndex, column: endColumn };\r\n        var newLength = node.piece.length + value.length;\r\n        var oldLineFeedCnt = node.piece.lineFeedCnt;\r\n        var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\r\n        var lf_delta = newLineFeedCnt - oldLineFeedCnt;\r\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\r\n        this._lastChangeBufferPos = newEnd;\r\n        updateTreeMetadata(this, node, value.length, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.nodeAt = function (offset) {\r\n        var x = this.root;\r\n        var cache = this._searchCache.get(offset);\r\n        if (cache) {\r\n            return {\r\n                node: cache.node,\r\n                nodeStartOffset: cache.nodeStartOffset,\r\n                remainder: offset - cache.nodeStartOffset\r\n            };\r\n        }\r\n        var nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left > offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                nodeStartOffset += x.size_left;\r\n                var ret = {\r\n                    node: x,\r\n                    remainder: offset - x.size_left,\r\n                    nodeStartOffset: nodeStartOffset\r\n                };\r\n                this._searchCache.set(ret);\r\n                return ret;\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\r\n        var x = this.root;\r\n        var nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                nodeStartOffset += x.size_left;\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\r\n                    nodeStartOffset: nodeStartOffset\r\n                };\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\r\n                    return {\r\n                        node: x,\r\n                        remainder: prevAccumualtedValue + column - 1,\r\n                        nodeStartOffset: nodeStartOffset\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length - prevAccumualtedValue;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        // search in order, to find the node contains position.column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\r\n                var nodeStartOffset_1 = this.offsetOfNode(x);\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(column - 1, accumualtedValue),\r\n                    nodeStartOffset: nodeStartOffset_1\r\n                };\r\n            }\r\n            else {\r\n                if (x.piece.length >= column - 1) {\r\n                    var nodeStartOffset_2 = this.offsetOfNode(x);\r\n                    return {\r\n                        node: x,\r\n                        remainder: column - 1,\r\n                        nodeStartOffset: nodeStartOffset_2\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length;\r\n                }\r\n            }\r\n            x = x.next();\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\r\n        if (node.piece.lineFeedCnt < 1) {\r\n            return -1;\r\n        }\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\r\n        return buffer.buffer.charCodeAt(newOffset);\r\n    };\r\n    PieceTreeBase.prototype.offsetOfNode = function (node) {\r\n        if (!node) {\r\n            return 0;\r\n        }\r\n        var pos = node.size_left;\r\n        while (node !== this.root) {\r\n            if (node.parent.right === node) {\r\n                pos += node.parent.size_left + node.parent.piece.length;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return pos;\r\n    };\r\n    // #endregion\r\n    // #region CRLF\r\n    PieceTreeBase.prototype.shouldCheckCRLF = function () {\r\n        return !(this._EOLNormalized && this._EOL === '\\n');\r\n    };\r\n    PieceTreeBase.prototype.startWithLF = function (val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(0) === 10;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        var piece = val.piece;\r\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        var line = piece.start.line;\r\n        var startOffset = lineStarts[line] + piece.start.column;\r\n        if (line === lineStarts.length - 1) {\r\n            // last line, so there is no line feed at the end of this line\r\n            return false;\r\n        }\r\n        var nextLineOffset = lineStarts[line + 1];\r\n        if (nextLineOffset > startOffset + 1) {\r\n            return false;\r\n        }\r\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\r\n    };\r\n    PieceTreeBase.prototype.endWithCR = function (val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(val.length - 1) === 13;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\r\n    };\r\n    PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\r\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\r\n            var node = nextNode.prev();\r\n            if (this.endWithCR(node)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\r\n            var nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.fixCRLF = function (prev, next) {\r\n        var nodesToDel = [];\r\n        // update node\r\n        var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\r\n        var newEnd;\r\n        if (prev.piece.end.column === 0) {\r\n            // it means, last line ends with \\r, not \\r\\n\r\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\r\n        }\r\n        else {\r\n            // \\r\\n\r\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\r\n        }\r\n        var prevNewLength = prev.piece.length - 1;\r\n        var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\r\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\r\n        updateTreeMetadata(this, prev, -1, -1);\r\n        if (prev.piece.length === 0) {\r\n            nodesToDel.push(prev);\r\n        }\r\n        // update nextNode\r\n        var newStart = { line: next.piece.start.line + 1, column: 0 };\r\n        var newLength = next.piece.length - 1;\r\n        var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\r\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, next, -1, -1);\r\n        if (next.piece.length === 0) {\r\n            nodesToDel.push(next);\r\n        }\r\n        // create new piece which contains \\r\\n\r\n        var pieces = this.createNewPieces('\\r\\n');\r\n        this.rbInsertRight(prev, pieces[0]);\r\n        // delete empty nodes\r\n        for (var i = 0; i < nodesToDel.length; i++) {\r\n            rbDelete(this, nodesToDel[i]);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n            var nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                // move `\\n` forward\r\n                value += '\\n';\r\n                if (nextNode.piece.length === 1) {\r\n                    rbDelete(this, nextNode);\r\n                }\r\n                else {\r\n                    var piece = nextNode.piece;\r\n                    var newStart = { line: piece.start.line + 1, column: 0 };\r\n                    var newLength = piece.length - 1;\r\n                    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n                    updateTreeMetadata(this, nextNode, -1, -1);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    // #endregion\r\n    // #endregion\r\n    // #region Tree operations\r\n    PieceTreeBase.prototype.iterate = function (node, callback) {\r\n        if (node === SENTINEL) {\r\n            return callback(SENTINEL);\r\n        }\r\n        var leftRet = this.iterate(node.left, callback);\r\n        if (!leftRet) {\r\n            return leftRet;\r\n        }\r\n        return callback(node) && this.iterate(node.right, callback);\r\n    };\r\n    PieceTreeBase.prototype.getNodeContent = function (node) {\r\n        if (node === SENTINEL) {\r\n            return '';\r\n        }\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var currentContent;\r\n        var piece = node.piece;\r\n        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\r\n        return currentContent;\r\n    };\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b    <----   a    b\r\n     *                         /\r\n     *                        z\r\n     */\r\n    PieceTreeBase.prototype.rbInsertRight = function (node, p) {\r\n        var z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        var x = this.root;\r\n        if (x === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.right === SENTINEL) {\r\n            node.right = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            var nextNode = leftest(node.right);\r\n            nextNode.left = z;\r\n            z.parent = nextNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    };\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b     ---->   a    b\r\n     *                       \\\r\n     *                        z\r\n     */\r\n    PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\r\n        var z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        if (this.root === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.left === SENTINEL) {\r\n            node.left = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            var prevNode = righttest(node.left); // a\r\n            prevNode.right = z;\r\n            z.parent = prevNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    };\r\n    return PieceTreeBase;\r\n}());\r\nexport { PieceTreeBase };\r\n"]},"metadata":{},"sourceType":"module"}