{"ast":null,"code":"/**\n * Sub-pixel optimize for canvas rendering, prevent from blur\n * when rendering a thin vertical/horizontal line.\n */\nvar round = Math.round;\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x1]\n * @param {number} [inputShape.y1]\n * @param {number} [inputShape.x2]\n * @param {number} [inputShape.y2]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  } else {\n    outputShape.x1 = x1;\n    outputShape.x2 = x2;\n  }\n\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  } else {\n    outputShape.y1 = y1;\n    outputShape.y2 = y2;\n  }\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x]\n * @param {number} [inputShape.y]\n * @param {number} [inputShape.width]\n * @param {number} [inputShape.height]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js"],"names":["round","Math","subPixelOptimizeLine","outputShape","inputShape","style","lineWidth","x1","x2","y1","y2","subPixelOptimize","subPixelOptimizeRect","originX","x","originY","y","originWidth","width","originHeight","height","max","position","positiveOrNegative","doubledPosition","exports"],"mappings":"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","sourcesContent":["/**\n * Sub-pixel optimize for canvas rendering, prevent from blur\n * when rendering a thin vertical/horizontal line.\n */\nvar round = Math.round;\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x1]\n * @param {number} [inputShape.y1]\n * @param {number} [inputShape.x2]\n * @param {number} [inputShape.y2]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  } else {\n    outputShape.x1 = x1;\n    outputShape.x2 = x2;\n  }\n\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  } else {\n    outputShape.y1 = y1;\n    outputShape.y2 = y2;\n  }\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x]\n * @param {number} [inputShape.y]\n * @param {number} [inputShape.width]\n * @param {number} [inputShape.height]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;"]},"metadata":{},"sourceType":"script"}