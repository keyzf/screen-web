{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LineBreakData } from '../../common/viewModel/splitLinesCollection.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\n\nvar DOMLineBreaksComputerFactory =\n/** @class */\nfunction () {\n  function DOMLineBreaksComputerFactory() {}\n\n  DOMLineBreaksComputerFactory.create = function () {\n    return new DOMLineBreaksComputerFactory();\n  };\n\n  DOMLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    tabSize = tabSize | 0; //@perf\n\n    wrappingColumn = +wrappingColumn; //@perf\n\n    var requests = [];\n    return {\n      addRequest: function (lineText, previousLineBreakData) {\n        requests.push(lineText);\n      },\n      finalize: function () {\n        return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\n      }\n    };\n  };\n\n  return DOMLineBreaksComputerFactory;\n}();\n\nexport { DOMLineBreaksComputerFactory };\n\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    var result_1 = [];\n\n    for (var i = 0, len = requests.length; i < len; i++) {\n      result_1[i] = null;\n    }\n\n    return result_1;\n  }\n\n  var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth); // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\n  // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\n\n  if (wrappingIndent === 2\n  /* Indent */\n  || wrappingIndent === 3\n  /* DeepIndent */\n  ) {\n      wrappingIndent = 1\n      /* Same */\n      ;\n    }\n\n  var containerDomNode = document.createElement('div');\n  Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n  var sb = createStringBuilder(10000);\n  var firstNonWhitespaceIndices = [];\n  var wrappedTextIndentLengths = [];\n  var renderLineContents = [];\n  var allCharOffsets = [];\n  var allVisibleColumns = [];\n\n  for (var i = 0; i < requests.length; i++) {\n    var lineContent = requests[i];\n    var firstNonWhitespaceIndex = 0;\n    var wrappedTextIndentLength = 0;\n    var width = overallWidth;\n\n    if (wrappingIndent !== 0\n    /* None */\n    ) {\n        firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // all whitespace line\n          firstNonWhitespaceIndex = 0;\n        } else {\n          // Track existing indent\n          for (var i_1 = 0; i_1 < firstNonWhitespaceIndex; i_1++) {\n            var charWidth = lineContent.charCodeAt(i_1) === 9\n            /* Tab */\n            ? tabSize - wrappedTextIndentLength % tabSize : 1;\n            wrappedTextIndentLength += charWidth;\n          }\n\n          var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength); // Force sticking to beginning of line if no character would fit except for the indentation\n\n          if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n            firstNonWhitespaceIndex = 0;\n            wrappedTextIndentLength = 0;\n          } else {\n            width = overallWidth - indentWidth;\n          }\n        }\n      }\n\n    var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n\n  containerDomNode.innerHTML = sb.build();\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  var range = document.createRange();\n  var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  var result = [];\n\n  for (var i = 0; i < requests.length; i++) {\n    var lineDomNode = lineDomNodes[i];\n    var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n\n    if (breakOffsets === null) {\n      result[i] = null;\n      continue;\n    }\n\n    var firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    var wrappedTextIndentLength = wrappedTextIndentLengths[i];\n    var visibleColumns = allVisibleColumns[i];\n    var breakOffsetsVisibleColumn = [];\n\n    for (var j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (var j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n\n    result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n  }\n\n  document.body.removeChild(containerDomNode);\n  return result;\n}\n\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\n  sb.appendASCIIString('<div style=\"width:');\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">'); // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n\n  var len = lineContent.length;\n  var visibleColumn = initialVisibleColumn;\n  var charOffset = 0;\n  var charOffsets = [];\n  var visibleColumns = [];\n  var nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0\n  /* Null */\n  ;\n\n  for (var charIndex = 0; charIndex < len; charIndex++) {\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    var charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n    /* Null */\n    ;\n    var producedCharacters = 1;\n    var charWidth = 1;\n\n    switch (charCode) {\n      case 9\n      /* Tab */\n      :\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n\n        for (var space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32\n            /* Space */\n            );\n          }\n        }\n\n        break;\n\n      case 32\n      /* Space */\n      :\n        if (nextCharCode === 32\n        /* Space */\n        ) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n          sb.appendASCII(32\n          /* Space */\n          );\n        }\n\n        break;\n\n      case 60\n      /* LessThan */\n      :\n        sb.appendASCIIString('&lt;');\n        break;\n\n      case 62\n      /* GreaterThan */\n      :\n        sb.appendASCIIString('&gt;');\n        break;\n\n      case 38\n      /* Ampersand */\n      :\n        sb.appendASCIIString('&amp;');\n        break;\n\n      case 0\n      /* Null */\n      :\n        sb.appendASCIIString('&#00;');\n        break;\n\n      case 65279\n      /* UTF8_BOM */\n      :\n      case 8232\n      /* LINE_SEPARATOR_2028 */\n      :\n        sb.write1(0xFFFD);\n        break;\n\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        } // if (renderControlCharacters && charCode < 32) {\n        // \tsb.write1(9216 + charCode);\n        // } else {\n\n\n        sb.write1(charCode);\n      // }\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\n\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n\n  var textContentNode = lineDomNode.firstChild;\n  var breakOffsets = [];\n  discoverBreaks(range, textContentNode, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\n\nfunction discoverBreaks(range, textContentNode, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n\n  lowRects = lowRects || readClientRect(range, textContentNode, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, textContentNode, charOffsets[high], charOffsets[high + 1]);\n\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  } // there is at least one line break between these two offsets\n\n\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n\n  var mid = low + (high - low) / 2 | 0;\n  var midRects = readClientRect(range, textContentNode, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, textContentNode, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, textContentNode, charOffsets, mid, midRects, high, highRects, result);\n}\n\nfunction readClientRect(range, textContentNode, startOffset, endOffset) {\n  range.setStart(textContentNode, startOffset);\n  range.setEnd(textContentNode, endOffset);\n  return range.getClientRects();\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"names":["LineBreakData","createStringBuilder","strings","Configuration","DOMLineBreaksComputerFactory","create","prototype","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","addRequest","lineText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","result_1","i","len","length","overallWidth","Math","round","typicalHalfwidthCharacterWidth","containerDomNode","document","createElement","applyFontInfoSlow","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","i_1","charWidth","charCodeAt","indentWidth","ceil","spaceWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","innerHTML","build","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","slice","call","children","result","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","removeChild","initialVisibleColumn","appendASCIIString","String","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","textContentNode","firstChild","discoverBreaks","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","setEnd","getClientRects"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LineBreakData } from '../../common/viewModel/splitLinesCollection.js';\r\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Configuration } from '../config/configuration.js';\r\nvar DOMLineBreaksComputerFactory = /** @class */ (function () {\r\n    function DOMLineBreaksComputerFactory() {\r\n    }\r\n    DOMLineBreaksComputerFactory.create = function () {\r\n        return new DOMLineBreaksComputerFactory();\r\n    };\r\n    DOMLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        var requests = [];\r\n        return {\r\n            addRequest: function (lineText, previousLineBreakData) {\r\n                requests.push(lineText);\r\n            },\r\n            finalize: function () {\r\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\r\n            }\r\n        };\r\n    };\r\n    return DOMLineBreaksComputerFactory;\r\n}());\r\nexport { DOMLineBreaksComputerFactory };\r\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        var result_1 = [];\r\n        for (var i = 0, len = requests.length; i < len; i++) {\r\n            result_1[i] = null;\r\n        }\r\n        return result_1;\r\n    }\r\n    var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\r\n    // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\r\n    // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\r\n    if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\r\n        wrappingIndent = 1 /* Same */;\r\n    }\r\n    var containerDomNode = document.createElement('div');\r\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\r\n    var sb = createStringBuilder(10000);\r\n    var firstNonWhitespaceIndices = [];\r\n    var wrappedTextIndentLengths = [];\r\n    var renderLineContents = [];\r\n    var allCharOffsets = [];\r\n    var allVisibleColumns = [];\r\n    for (var i = 0; i < requests.length; i++) {\r\n        var lineContent = requests[i];\r\n        var firstNonWhitespaceIndex = 0;\r\n        var wrappedTextIndentLength = 0;\r\n        var width = overallWidth;\r\n        if (wrappingIndent !== 0 /* None */) {\r\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (firstNonWhitespaceIndex === -1) {\r\n                // all whitespace line\r\n                firstNonWhitespaceIndex = 0;\r\n            }\r\n            else {\r\n                // Track existing indent\r\n                for (var i_1 = 0; i_1 < firstNonWhitespaceIndex; i_1++) {\r\n                    var charWidth = (lineContent.charCodeAt(i_1) === 9 /* Tab */\r\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\r\n                        : 1);\r\n                    wrappedTextIndentLength += charWidth;\r\n                }\r\n                var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\r\n                // Force sticking to beginning of line if no character would fit except for the indentation\r\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\r\n                    firstNonWhitespaceIndex = 0;\r\n                    wrappedTextIndentLength = 0;\r\n                }\r\n                else {\r\n                    width = overallWidth - indentWidth;\r\n                }\r\n            }\r\n        }\r\n        var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\r\n        var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\r\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\r\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\r\n        renderLineContents[i] = renderLineContent;\r\n        allCharOffsets[i] = tmp[0];\r\n        allVisibleColumns[i] = tmp[1];\r\n    }\r\n    containerDomNode.innerHTML = sb.build();\r\n    containerDomNode.style.position = 'absolute';\r\n    containerDomNode.style.top = '10000';\r\n    containerDomNode.style.wordWrap = 'break-word';\r\n    document.body.appendChild(containerDomNode);\r\n    var range = document.createRange();\r\n    var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\r\n    var result = [];\r\n    for (var i = 0; i < requests.length; i++) {\r\n        var lineDomNode = lineDomNodes[i];\r\n        var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\r\n        if (breakOffsets === null) {\r\n            result[i] = null;\r\n            continue;\r\n        }\r\n        var firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\r\n        var wrappedTextIndentLength = wrappedTextIndentLengths[i];\r\n        var visibleColumns = allVisibleColumns[i];\r\n        var breakOffsetsVisibleColumn = [];\r\n        for (var j = 0, len = breakOffsets.length; j < len; j++) {\r\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\r\n        }\r\n        if (firstNonWhitespaceIndex !== 0) {\r\n            // All break offsets are relative to the renderLineContent, make them absolute again\r\n            for (var j = 0, len = breakOffsets.length; j < len; j++) {\r\n                breakOffsets[j] += firstNonWhitespaceIndex;\r\n            }\r\n        }\r\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\r\n    }\r\n    document.body.removeChild(containerDomNode);\r\n    return result;\r\n}\r\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\r\n    sb.appendASCIIString('<div style=\"width:');\r\n    sb.appendASCIIString(String(width));\r\n    sb.appendASCIIString('px;\">');\r\n    // if (containsRTL) {\r\n    // \tsb.appendASCIIString('\" dir=\"ltr');\r\n    // }\r\n    var len = lineContent.length;\r\n    var visibleColumn = initialVisibleColumn;\r\n    var charOffset = 0;\r\n    var charOffsets = [];\r\n    var visibleColumns = [];\r\n    var nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\r\n    for (var charIndex = 0; charIndex < len; charIndex++) {\r\n        charOffsets[charIndex] = charOffset;\r\n        visibleColumns[charIndex] = visibleColumn;\r\n        var charCode = nextCharCode;\r\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n        var producedCharacters = 1;\r\n        var charWidth = 1;\r\n        switch (charCode) {\r\n            case 9 /* Tab */:\r\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                charWidth = producedCharacters;\r\n                for (var space = 1; space <= producedCharacters; space++) {\r\n                    if (space < producedCharacters) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                    else {\r\n                        sb.appendASCII(32 /* Space */);\r\n                    }\r\n                }\r\n                break;\r\n            case 32 /* Space */:\r\n                if (nextCharCode === 32 /* Space */) {\r\n                    sb.write1(0xA0); // &nbsp;\r\n                }\r\n                else {\r\n                    sb.appendASCII(32 /* Space */);\r\n                }\r\n                break;\r\n            case 60 /* LessThan */:\r\n                sb.appendASCIIString('&lt;');\r\n                break;\r\n            case 62 /* GreaterThan */:\r\n                sb.appendASCIIString('&gt;');\r\n                break;\r\n            case 38 /* Ampersand */:\r\n                sb.appendASCIIString('&amp;');\r\n                break;\r\n            case 0 /* Null */:\r\n                sb.appendASCIIString('&#00;');\r\n                break;\r\n            case 65279 /* UTF8_BOM */:\r\n            case 8232 /* LINE_SEPARATOR_2028 */:\r\n                sb.write1(0xFFFD);\r\n                break;\r\n            default:\r\n                if (strings.isFullWidthCharacter(charCode)) {\r\n                    charWidth++;\r\n                }\r\n                // if (renderControlCharacters && charCode < 32) {\r\n                // \tsb.write1(9216 + charCode);\r\n                // } else {\r\n                sb.write1(charCode);\r\n            // }\r\n        }\r\n        charOffset += producedCharacters;\r\n        visibleColumn += charWidth;\r\n    }\r\n    charOffsets[lineContent.length] = charOffset;\r\n    visibleColumns[lineContent.length] = visibleColumn;\r\n    sb.appendASCIIString('</div>');\r\n    return [charOffsets, visibleColumns];\r\n}\r\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\r\n    if (lineContent.length <= 1) {\r\n        return null;\r\n    }\r\n    var textContentNode = lineDomNode.firstChild;\r\n    var breakOffsets = [];\r\n    discoverBreaks(range, textContentNode, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\r\n    if (breakOffsets.length === 0) {\r\n        return null;\r\n    }\r\n    breakOffsets.push(lineContent.length);\r\n    return breakOffsets;\r\n}\r\nfunction discoverBreaks(range, textContentNode, charOffsets, low, lowRects, high, highRects, result) {\r\n    if (low === high) {\r\n        return;\r\n    }\r\n    lowRects = lowRects || readClientRect(range, textContentNode, charOffsets[low], charOffsets[low + 1]);\r\n    highRects = highRects || readClientRect(range, textContentNode, charOffsets[high], charOffsets[high + 1]);\r\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\r\n        // same line\r\n        return;\r\n    }\r\n    // there is at least one line break between these two offsets\r\n    if (low + 1 === high) {\r\n        // the two characters are adjacent, so the line break must be exactly between them\r\n        result.push(high);\r\n        return;\r\n    }\r\n    var mid = low + ((high - low) / 2) | 0;\r\n    var midRects = readClientRect(range, textContentNode, charOffsets[mid], charOffsets[mid + 1]);\r\n    discoverBreaks(range, textContentNode, charOffsets, low, lowRects, mid, midRects, result);\r\n    discoverBreaks(range, textContentNode, charOffsets, mid, midRects, high, highRects, result);\r\n}\r\nfunction readClientRect(range, textContentNode, startOffset, endOffset) {\r\n    range.setStart(textContentNode, startOffset);\r\n    range.setEnd(textContentNode, endOffset);\r\n    return range.getClientRects();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}