{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { URI } from './uri.js';\nimport { equalsIgnoreCase } from './strings.js';\nimport { Schemas } from './network.js';\nimport { isLinux, isWindows } from './platform.js';\nexport function hasToIgnoreCase(resource) {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\nexport function basenameOrAuthority(resource) {\n  return basename(resource) || resource.authority;\n}\n/**\r\n * Tests wheter the two authorities are the same\r\n */\n\nexport function isEqualAuthority(a1, a2) {\n  return a1 === a2 || equalsIgnoreCase(a1, a2);\n}\nexport function isEqual(first, second, ignoreCase) {\n  if (ignoreCase === void 0) {\n    ignoreCase = hasToIgnoreCase(first);\n  }\n\n  if (first === second) {\n    return true;\n  }\n\n  if (!first || !second) {\n    return false;\n  }\n\n  if (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n    return false;\n  }\n\n  var p1 = first.path || '/',\n      p2 = second.path || '/';\n  return p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\nexport function basename(resource) {\n  return paths.posix.basename(resource.path);\n}\n/**\r\n * Return a URI representing the directory of a URI path.\r\n *\r\n * @param resource The input URI.\r\n * @returns The URI representing the directory of the input URI.\r\n */\n\nexport function dirname(resource) {\n  if (resource.path.length === 0) {\n    return resource;\n  }\n\n  if (resource.scheme === Schemas.file) {\n    return URI.file(paths.dirname(originalFSPath(resource)));\n  }\n\n  var dirname = paths.posix.dirname(resource.path);\n\n  if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47\n  /* Slash */\n  ) {\n      console.error(\"dirname(\\\"\" + resource.toString + \")) resulted in a relative path\");\n      dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n    }\n\n  return resource.with({\n    path: dirname\n  });\n}\n/**\r\n * Join a URI path with path fragments and normalizes the resulting path.\r\n *\r\n * @param resource The input URI.\r\n * @param pathFragment The path fragment to add to the URI path.\r\n * @returns The resulting URI.\r\n */\n\nexport function joinPath(resource) {\n  var _a;\n\n  var pathFragment = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    pathFragment[_i - 1] = arguments[_i];\n  }\n\n  var joinedPath;\n\n  if (resource.scheme === Schemas.file) {\n    joinedPath = URI.file(paths.join.apply(paths, __spreadArrays([originalFSPath(resource)], pathFragment))).path;\n  } else {\n    joinedPath = (_a = paths.posix).join.apply(_a, __spreadArrays([resource.path || '/'], pathFragment));\n  }\n\n  return resource.with({\n    path: joinedPath\n  });\n}\n/**\r\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\r\n *\r\n * @param resource The URI to normalize the path.\r\n * @returns The URI with the normalized path.\r\n */\n\nexport function normalizePath(resource) {\n  if (!resource.path.length) {\n    return resource;\n  }\n\n  var normalizedPath;\n\n  if (resource.scheme === Schemas.file) {\n    normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n  } else {\n    normalizedPath = paths.posix.normalize(resource.path);\n  }\n\n  return resource.with({\n    path: normalizedPath\n  });\n}\n/**\r\n * Returns the fsPath of an URI where the drive letter is not normalized.\r\n * See #56403.\r\n */\n\nexport function originalFSPath(uri) {\n  var value;\n  var uriPath = uri.path;\n\n  if (uri.authority && uriPath.length > 1 && uri.scheme === Schemas.file) {\n    // unc path: file://shares/c$/far/boo\n    value = \"//\" + uri.authority + uriPath;\n  } else if (isWindows && uriPath.charCodeAt(0) === 47\n  /* Slash */\n  && extpath.isWindowsDriveLetter(uriPath.charCodeAt(1)) && uriPath.charCodeAt(2) === 58\n  /* Colon */\n  ) {\n      value = uriPath.substr(1);\n    } else {\n    // other path\n    value = uriPath;\n  }\n\n  if (isWindows) {\n    value = value.replace(/\\//g, '\\\\');\n  }\n\n  return value;\n}\n/**\r\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\r\n * The returned relative path always uses forward slashes.\r\n */\n\nexport function relativePath(from, to, ignoreCase) {\n  if (ignoreCase === void 0) {\n    ignoreCase = hasToIgnoreCase(from);\n  }\n\n  if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n    return undefined;\n  }\n\n  if (from.scheme === Schemas.file) {\n    var relativePath_1 = paths.relative(from.path, to.path);\n    return isWindows ? extpath.toSlashes(relativePath_1) : relativePath_1;\n  }\n\n  var fromPath = from.path || '/',\n      toPath = to.path || '/';\n\n  if (ignoreCase) {\n    // make casing of fromPath match toPath\n    var i = 0;\n\n    for (var len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n      if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n        if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n          break;\n        }\n      }\n    }\n\n    fromPath = toPath.substr(0, i) + fromPath.substr(i);\n  }\n\n  return paths.posix.relative(fromPath, toPath);\n}\n/**\r\n * Data URI related helpers.\r\n */\n\nexport var DataUri;\n\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n\n  function parseMetaData(dataUri) {\n    var metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\n    var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(function (property) {\n      var _a = property.split(':'),\n          key = _a[0],\n          value = _a[1];\n\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n\n    var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n\n    return metadata;\n  }\n\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","extpath","paths","URI","equalsIgnoreCase","Schemas","isLinux","isWindows","hasToIgnoreCase","resource","scheme","file","basenameOrAuthority","basename","authority","isEqualAuthority","a1","a2","isEqual","first","second","ignoreCase","p1","path","p2","posix","dirname","originalFSPath","charCodeAt","console","error","toString","with","joinPath","_a","pathFragment","_i","joinedPath","join","apply","normalizePath","normalizedPath","normalize","uri","value","uriPath","isWindowsDriveLetter","substr","replace","relativePath","from","to","undefined","relativePath_1","relative","toSlashes","fromPath","toPath","len","Math","min","charAt","toLowerCase","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","set","mime"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { URI } from './uri.js';\r\nimport { equalsIgnoreCase } from './strings.js';\r\nimport { Schemas } from './network.js';\r\nimport { isLinux, isWindows } from './platform.js';\r\nexport function hasToIgnoreCase(resource) {\r\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\r\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\r\n    return resource && resource.scheme === Schemas.file ? !isLinux : true;\r\n}\r\nexport function basenameOrAuthority(resource) {\r\n    return basename(resource) || resource.authority;\r\n}\r\n/**\r\n * Tests wheter the two authorities are the same\r\n */\r\nexport function isEqualAuthority(a1, a2) {\r\n    return a1 === a2 || equalsIgnoreCase(a1, a2);\r\n}\r\nexport function isEqual(first, second, ignoreCase) {\r\n    if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(first); }\r\n    if (first === second) {\r\n        return true;\r\n    }\r\n    if (!first || !second) {\r\n        return false;\r\n    }\r\n    if (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\r\n        return false;\r\n    }\r\n    var p1 = first.path || '/', p2 = second.path || '/';\r\n    return p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\r\n}\r\nexport function basename(resource) {\r\n    return paths.posix.basename(resource.path);\r\n}\r\n/**\r\n * Return a URI representing the directory of a URI path.\r\n *\r\n * @param resource The input URI.\r\n * @returns The URI representing the directory of the input URI.\r\n */\r\nexport function dirname(resource) {\r\n    if (resource.path.length === 0) {\r\n        return resource;\r\n    }\r\n    if (resource.scheme === Schemas.file) {\r\n        return URI.file(paths.dirname(originalFSPath(resource)));\r\n    }\r\n    var dirname = paths.posix.dirname(resource.path);\r\n    if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\r\n        console.error(\"dirname(\\\"\" + resource.toString + \")) resulted in a relative path\");\r\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\r\n    }\r\n    return resource.with({\r\n        path: dirname\r\n    });\r\n}\r\n/**\r\n * Join a URI path with path fragments and normalizes the resulting path.\r\n *\r\n * @param resource The input URI.\r\n * @param pathFragment The path fragment to add to the URI path.\r\n * @returns The resulting URI.\r\n */\r\nexport function joinPath(resource) {\r\n    var _a;\r\n    var pathFragment = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        pathFragment[_i - 1] = arguments[_i];\r\n    }\r\n    var joinedPath;\r\n    if (resource.scheme === Schemas.file) {\r\n        joinedPath = URI.file(paths.join.apply(paths, __spreadArrays([originalFSPath(resource)], pathFragment))).path;\r\n    }\r\n    else {\r\n        joinedPath = (_a = paths.posix).join.apply(_a, __spreadArrays([resource.path || '/'], pathFragment));\r\n    }\r\n    return resource.with({\r\n        path: joinedPath\r\n    });\r\n}\r\n/**\r\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\r\n *\r\n * @param resource The URI to normalize the path.\r\n * @returns The URI with the normalized path.\r\n */\r\nexport function normalizePath(resource) {\r\n    if (!resource.path.length) {\r\n        return resource;\r\n    }\r\n    var normalizedPath;\r\n    if (resource.scheme === Schemas.file) {\r\n        normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\r\n    }\r\n    else {\r\n        normalizedPath = paths.posix.normalize(resource.path);\r\n    }\r\n    return resource.with({\r\n        path: normalizedPath\r\n    });\r\n}\r\n/**\r\n * Returns the fsPath of an URI where the drive letter is not normalized.\r\n * See #56403.\r\n */\r\nexport function originalFSPath(uri) {\r\n    var value;\r\n    var uriPath = uri.path;\r\n    if (uri.authority && uriPath.length > 1 && uri.scheme === Schemas.file) {\r\n        // unc path: file://shares/c$/far/boo\r\n        value = \"//\" + uri.authority + uriPath;\r\n    }\r\n    else if (isWindows\r\n        && uriPath.charCodeAt(0) === 47 /* Slash */\r\n        && extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\r\n        && uriPath.charCodeAt(2) === 58 /* Colon */) {\r\n        value = uriPath.substr(1);\r\n    }\r\n    else {\r\n        // other path\r\n        value = uriPath;\r\n    }\r\n    if (isWindows) {\r\n        value = value.replace(/\\//g, '\\\\');\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\r\n * The returned relative path always uses forward slashes.\r\n */\r\nexport function relativePath(from, to, ignoreCase) {\r\n    if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(from); }\r\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\r\n        return undefined;\r\n    }\r\n    if (from.scheme === Schemas.file) {\r\n        var relativePath_1 = paths.relative(from.path, to.path);\r\n        return isWindows ? extpath.toSlashes(relativePath_1) : relativePath_1;\r\n    }\r\n    var fromPath = from.path || '/', toPath = to.path || '/';\r\n    if (ignoreCase) {\r\n        // make casing of fromPath match toPath\r\n        var i = 0;\r\n        for (var len = Math.min(fromPath.length, toPath.length); i < len; i++) {\r\n            if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\r\n                if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        fromPath = toPath.substr(0, i) + fromPath.substr(i);\r\n    }\r\n    return paths.posix.relative(fromPath, toPath);\r\n}\r\n/**\r\n * Data URI related helpers.\r\n */\r\nexport var DataUri;\r\n(function (DataUri) {\r\n    DataUri.META_DATA_LABEL = 'label';\r\n    DataUri.META_DATA_DESCRIPTION = 'description';\r\n    DataUri.META_DATA_SIZE = 'size';\r\n    DataUri.META_DATA_MIME = 'mime';\r\n    function parseMetaData(dataUri) {\r\n        var metadata = new Map();\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\r\n        var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\r\n        meta.split(';').forEach(function (property) {\r\n            var _a = property.split(':'), key = _a[0], value = _a[1];\r\n            if (key && value) {\r\n                metadata.set(key, value);\r\n            }\r\n        });\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the mime is: image/png\r\n        var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\r\n        if (mime) {\r\n            metadata.set(DataUri.META_DATA_MIME, mime);\r\n        }\r\n        return metadata;\r\n    }\r\n    DataUri.parseMetaData = parseMetaData;\r\n})(DataUri || (DataUri = {}));\r\n"]},"metadata":{},"sourceType":"module"}