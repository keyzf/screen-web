{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n\nvar LineDecoration =\n/** @class */\nfunction () {\n  function LineDecoration(startColumn, endColumn, className, type) {\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n  }\n\n  LineDecoration._equals = function (a, b) {\n    return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n  };\n\n  LineDecoration.equalsArr = function (a, b) {\n    var aLen = a.length;\n    var bLen = b.length;\n\n    if (aLen !== bLen) {\n      return false;\n    }\n\n    for (var i = 0; i < aLen; i++) {\n      if (!LineDecoration._equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  LineDecoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    var result = [],\n        resultLen = 0;\n\n    for (var i = 0, len = lineDecorations.length; i < len; i++) {\n      var d = lineDecorations[i];\n      var range = d.range;\n\n      if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n        // Ignore decorations that sit outside this line\n        continue;\n      }\n\n      if (range.isEmpty() && (d.type === 0\n      /* Regular */\n      || d.type === 3\n      /* RegularAffectingLetterSpacing */\n      )) {\n        // Ignore empty range decorations\n        continue;\n      }\n\n      var startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n      var endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n      result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n    }\n\n    return result;\n  };\n\n  LineDecoration.compare = function (a, b) {\n    if (a.startColumn === b.startColumn) {\n      if (a.endColumn === b.endColumn) {\n        if (a.className < b.className) {\n          return -1;\n        }\n\n        if (a.className > b.className) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      return a.endColumn - b.endColumn;\n    }\n\n    return a.startColumn - b.startColumn;\n  };\n\n  return LineDecoration;\n}();\n\nexport { LineDecoration };\n\nvar DecorationSegment =\n/** @class */\nfunction () {\n  function DecorationSegment(startOffset, endOffset, className) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.className = className;\n  }\n\n  return DecorationSegment;\n}();\n\nexport { DecorationSegment };\n\nvar Stack =\n/** @class */\nfunction () {\n  function Stack() {\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.count = 0;\n  }\n\n  Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {\n    while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n      var i = 0; // Take all equal stopping offsets\n\n      while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n        i++;\n      } // Basically we are consuming the first i + 1 elements of the stack\n\n\n      result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\n      nextStartOffset = this.stopOffsets[i] + 1; // Consume them\n\n      this.stopOffsets.splice(0, i + 1);\n      this.classNames.splice(0, i + 1);\n      this.count -= i + 1;\n    }\n\n    if (this.count > 0 && nextStartOffset < maxStopOffset) {\n      result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\n      nextStartOffset = maxStopOffset;\n    }\n\n    return nextStartOffset;\n  };\n\n  Stack.prototype.insert = function (stopOffset, className) {\n    if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n      // Insert at the end\n      this.stopOffsets.push(stopOffset);\n      this.classNames.push(className);\n    } else {\n      // Find the insertion position for `stopOffset`\n      for (var i = 0; i < this.count; i++) {\n        if (this.stopOffsets[i] >= stopOffset) {\n          this.stopOffsets.splice(i, 0, stopOffset);\n          this.classNames.splice(i, 0, className);\n          break;\n        }\n      }\n    }\n\n    this.count++;\n    return;\n  };\n\n  return Stack;\n}();\n\nvar LineDecorationsNormalizer =\n/** @class */\nfunction () {\n  function LineDecorationsNormalizer() {}\n  /**\r\n   * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n   */\n\n\n  LineDecorationsNormalizer.normalize = function (lineContent, lineDecorations) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    var result = [];\n    var stack = new Stack();\n    var nextStartOffset = 0;\n\n    for (var i = 0, len = lineDecorations.length; i < len; i++) {\n      var d = lineDecorations[i];\n      var startColumn = d.startColumn;\n      var endColumn = d.endColumn;\n      var className = d.className; // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\n      if (startColumn > 1) {\n        var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          startColumn--;\n        }\n      }\n\n      if (endColumn > 1) {\n        var charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          endColumn--;\n        }\n      }\n\n      var currentStartOffset = startColumn - 1;\n      var currentEndOffset = endColumn - 2;\n      nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n      if (stack.count === 0) {\n        nextStartOffset = currentStartOffset;\n      }\n\n      stack.insert(currentEndOffset, className);\n    }\n\n    stack.consumeLowerThan(1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    , nextStartOffset, result);\n    return result;\n  };\n\n  return LineDecorationsNormalizer;\n}();\n\nexport { LineDecorationsNormalizer };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"names":["strings","LineDecoration","startColumn","endColumn","className","type","_equals","a","b","equalsArr","aLen","length","bLen","i","filter","lineDecorations","lineNumber","minLineColumn","maxLineColumn","result","resultLen","len","d","range","endLineNumber","startLineNumber","isEmpty","inlineClassName","compare","DecorationSegment","startOffset","endOffset","Stack","stopOffsets","classNames","count","prototype","consumeLowerThan","maxStopOffset","nextStartOffset","push","join","splice","insert","stopOffset","LineDecorationsNormalizer","normalize","lineContent","stack","charCodeBefore","charCodeAt","isHighSurrogate","currentStartOffset","currentEndOffset"],"mappings":"AAAA;;;;AAIA,OAAO,KAAKA,OAAZ,MAAyB,iCAAzB;;AACA,IAAIC,cAAc;AAAG;AAAe,YAAY;AAC5C,WAASA,cAAT,CAAwBC,WAAxB,EAAqCC,SAArC,EAAgDC,SAAhD,EAA2DC,IAA3D,EAAiE;AAC7D,SAAKH,WAAL,GAAmBA,WAAnB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AACDJ,EAAAA,cAAc,CAACK,OAAf,GAAyB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACrC,WAAQD,CAAC,CAACL,WAAF,KAAkBM,CAAC,CAACN,WAApB,IACDK,CAAC,CAACJ,SAAF,KAAgBK,CAAC,CAACL,SADjB,IAEDI,CAAC,CAACH,SAAF,KAAgBI,CAAC,CAACJ,SAFjB,IAGDG,CAAC,CAACF,IAAF,KAAWG,CAAC,CAACH,IAHpB;AAIH,GALD;;AAMAJ,EAAAA,cAAc,CAACQ,SAAf,GAA2B,UAAUF,CAAV,EAAaC,CAAb,EAAgB;AACvC,QAAIE,IAAI,GAAGH,CAAC,CAACI,MAAb;AACA,QAAIC,IAAI,GAAGJ,CAAC,CAACG,MAAb;;AACA,QAAID,IAAI,KAAKE,IAAb,EAAmB;AACf,aAAO,KAAP;AACH;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAApB,EAA0BG,CAAC,EAA3B,EAA+B;AAC3B,UAAI,CAACZ,cAAc,CAACK,OAAf,CAAuBC,CAAC,CAACM,CAAD,CAAxB,EAA6BL,CAAC,CAACK,CAAD,CAA9B,CAAL,EAAyC;AACrC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH,GAZD;;AAaAZ,EAAAA,cAAc,CAACa,MAAf,GAAwB,UAAUC,eAAV,EAA2BC,UAA3B,EAAuCC,aAAvC,EAAsDC,aAAtD,EAAqE;AACzF,QAAIH,eAAe,CAACJ,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B,aAAO,EAAP;AACH;;AACD,QAAIQ,MAAM,GAAG,EAAb;AAAA,QAAiBC,SAAS,GAAG,CAA7B;;AACA,SAAK,IAAIP,CAAC,GAAG,CAAR,EAAWQ,GAAG,GAAGN,eAAe,CAACJ,MAAtC,EAA8CE,CAAC,GAAGQ,GAAlD,EAAuDR,CAAC,EAAxD,EAA4D;AACxD,UAAIS,CAAC,GAAGP,eAAe,CAACF,CAAD,CAAvB;AACA,UAAIU,KAAK,GAAGD,CAAC,CAACC,KAAd;;AACA,UAAIA,KAAK,CAACC,aAAN,GAAsBR,UAAtB,IAAoCO,KAAK,CAACE,eAAN,GAAwBT,UAAhE,EAA4E;AACxE;AACA;AACH;;AACD,UAAIO,KAAK,CAACG,OAAN,OAAoBJ,CAAC,CAACjB,IAAF,KAAW;AAAE;AAAb,SAA8BiB,CAAC,CAACjB,IAAF,KAAW;AAAE;AAA/D,OAAJ,EAAyG;AACrG;AACA;AACH;;AACD,UAAIH,WAAW,GAAIqB,KAAK,CAACE,eAAN,KAA0BT,UAA1B,GAAuCO,KAAK,CAACrB,WAA7C,GAA2De,aAA9E;AACA,UAAId,SAAS,GAAIoB,KAAK,CAACC,aAAN,KAAwBR,UAAxB,GAAqCO,KAAK,CAACpB,SAA3C,GAAuDe,aAAxE;AACAC,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAInB,cAAJ,CAAmBC,WAAnB,EAAgCC,SAAhC,EAA2CmB,CAAC,CAACK,eAA7C,EAA8DL,CAAC,CAACjB,IAAhE,CAAtB;AACH;;AACD,WAAOc,MAAP;AACH,GArBD;;AAsBAlB,EAAAA,cAAc,CAAC2B,OAAf,GAAyB,UAAUrB,CAAV,EAAaC,CAAb,EAAgB;AACrC,QAAID,CAAC,CAACL,WAAF,KAAkBM,CAAC,CAACN,WAAxB,EAAqC;AACjC,UAAIK,CAAC,CAACJ,SAAF,KAAgBK,CAAC,CAACL,SAAtB,EAAiC;AAC7B,YAAII,CAAC,CAACH,SAAF,GAAcI,CAAC,CAACJ,SAApB,EAA+B;AAC3B,iBAAO,CAAC,CAAR;AACH;;AACD,YAAIG,CAAC,CAACH,SAAF,GAAcI,CAAC,CAACJ,SAApB,EAA+B;AAC3B,iBAAO,CAAP;AACH;;AACD,eAAO,CAAP;AACH;;AACD,aAAOG,CAAC,CAACJ,SAAF,GAAcK,CAAC,CAACL,SAAvB;AACH;;AACD,WAAOI,CAAC,CAACL,WAAF,GAAgBM,CAAC,CAACN,WAAzB;AACH,GAdD;;AAeA,SAAOD,cAAP;AACH,CAhEmC,EAApC;;AAiEA,SAASA,cAAT;;AACA,IAAI4B,iBAAiB;AAAG;AAAe,YAAY;AAC/C,WAASA,iBAAT,CAA2BC,WAA3B,EAAwCC,SAAxC,EAAmD3B,SAAnD,EAA8D;AAC1D,SAAK0B,WAAL,GAAmBA,WAAnB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAK3B,SAAL,GAAiBA,SAAjB;AACH;;AACD,SAAOyB,iBAAP;AACH,CAPsC,EAAvC;;AAQA,SAASA,iBAAT;;AACA,IAAIG,KAAK;AAAG;AAAe,YAAY;AACnC,WAASA,KAAT,GAAiB;AACb,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,KAAL,GAAa,CAAb;AACH;;AACDH,EAAAA,KAAK,CAACI,SAAN,CAAgBC,gBAAhB,GAAmC,UAAUC,aAAV,EAAyBC,eAAzB,EAA0CpB,MAA1C,EAAkD;AACjF,WAAO,KAAKgB,KAAL,GAAa,CAAb,IAAkB,KAAKF,WAAL,CAAiB,CAAjB,IAAsBK,aAA/C,EAA8D;AAC1D,UAAIzB,CAAC,GAAG,CAAR,CAD0D,CAE1D;;AACA,aAAOA,CAAC,GAAG,CAAJ,GAAQ,KAAKsB,KAAb,IAAsB,KAAKF,WAAL,CAAiBpB,CAAjB,MAAwB,KAAKoB,WAAL,CAAiBpB,CAAC,GAAG,CAArB,CAArD,EAA8E;AAC1EA,QAAAA,CAAC;AACJ,OALyD,CAM1D;;;AACAM,MAAAA,MAAM,CAACqB,IAAP,CAAY,IAAIX,iBAAJ,CAAsBU,eAAtB,EAAuC,KAAKN,WAAL,CAAiBpB,CAAjB,CAAvC,EAA4D,KAAKqB,UAAL,CAAgBO,IAAhB,CAAqB,GAArB,CAA5D,CAAZ;AACAF,MAAAA,eAAe,GAAG,KAAKN,WAAL,CAAiBpB,CAAjB,IAAsB,CAAxC,CAR0D,CAS1D;;AACA,WAAKoB,WAAL,CAAiBS,MAAjB,CAAwB,CAAxB,EAA2B7B,CAAC,GAAG,CAA/B;AACA,WAAKqB,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,EAA0B7B,CAAC,GAAG,CAA9B;AACA,WAAKsB,KAAL,IAAetB,CAAC,GAAG,CAAnB;AACH;;AACD,QAAI,KAAKsB,KAAL,GAAa,CAAb,IAAkBI,eAAe,GAAGD,aAAxC,EAAuD;AACnDnB,MAAAA,MAAM,CAACqB,IAAP,CAAY,IAAIX,iBAAJ,CAAsBU,eAAtB,EAAuCD,aAAa,GAAG,CAAvD,EAA0D,KAAKJ,UAAL,CAAgBO,IAAhB,CAAqB,GAArB,CAA1D,CAAZ;AACAF,MAAAA,eAAe,GAAGD,aAAlB;AACH;;AACD,WAAOC,eAAP;AACH,GApBD;;AAqBAP,EAAAA,KAAK,CAACI,SAAN,CAAgBO,MAAhB,GAAyB,UAAUC,UAAV,EAAsBxC,SAAtB,EAAiC;AACtD,QAAI,KAAK+B,KAAL,KAAe,CAAf,IAAoB,KAAKF,WAAL,CAAiB,KAAKE,KAAL,GAAa,CAA9B,KAAoCS,UAA5D,EAAwE;AACpE;AACA,WAAKX,WAAL,CAAiBO,IAAjB,CAAsBI,UAAtB;AACA,WAAKV,UAAL,CAAgBM,IAAhB,CAAqBpC,SAArB;AACH,KAJD,MAKK;AACD;AACA,WAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKsB,KAAzB,EAAgCtB,CAAC,EAAjC,EAAqC;AACjC,YAAI,KAAKoB,WAAL,CAAiBpB,CAAjB,KAAuB+B,UAA3B,EAAuC;AACnC,eAAKX,WAAL,CAAiBS,MAAjB,CAAwB7B,CAAxB,EAA2B,CAA3B,EAA8B+B,UAA9B;AACA,eAAKV,UAAL,CAAgBQ,MAAhB,CAAuB7B,CAAvB,EAA0B,CAA1B,EAA6BT,SAA7B;AACA;AACH;AACJ;AACJ;;AACD,SAAK+B,KAAL;AACA;AACH,GAlBD;;AAmBA,SAAOH,KAAP;AACH,CA/C0B,EAA3B;;AAgDA,IAAIa,yBAAyB;AAAG;AAAe,YAAY;AACvD,WAASA,yBAAT,GAAqC,CACpC;AACD;;;;;AAGAA,EAAAA,yBAAyB,CAACC,SAA1B,GAAsC,UAAUC,WAAV,EAAuBhC,eAAvB,EAAwC;AAC1E,QAAIA,eAAe,CAACJ,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B,aAAO,EAAP;AACH;;AACD,QAAIQ,MAAM,GAAG,EAAb;AACA,QAAI6B,KAAK,GAAG,IAAIhB,KAAJ,EAAZ;AACA,QAAIO,eAAe,GAAG,CAAtB;;AACA,SAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWQ,GAAG,GAAGN,eAAe,CAACJ,MAAtC,EAA8CE,CAAC,GAAGQ,GAAlD,EAAuDR,CAAC,EAAxD,EAA4D;AACxD,UAAIS,CAAC,GAAGP,eAAe,CAACF,CAAD,CAAvB;AACA,UAAIX,WAAW,GAAGoB,CAAC,CAACpB,WAApB;AACA,UAAIC,SAAS,GAAGmB,CAAC,CAACnB,SAAlB;AACA,UAAIC,SAAS,GAAGkB,CAAC,CAAClB,SAAlB,CAJwD,CAKxD;;AACA,UAAIF,WAAW,GAAG,CAAlB,EAAqB;AACjB,YAAI+C,cAAc,GAAGF,WAAW,CAACG,UAAZ,CAAuBhD,WAAW,GAAG,CAArC,CAArB;;AACA,YAAIF,OAAO,CAACmD,eAAR,CAAwBF,cAAxB,CAAJ,EAA6C;AACzC/C,UAAAA,WAAW;AACd;AACJ;;AACD,UAAIC,SAAS,GAAG,CAAhB,EAAmB;AACf,YAAI8C,cAAc,GAAGF,WAAW,CAACG,UAAZ,CAAuB/C,SAAS,GAAG,CAAnC,CAArB;;AACA,YAAIH,OAAO,CAACmD,eAAR,CAAwBF,cAAxB,CAAJ,EAA6C;AACzC9C,UAAAA,SAAS;AACZ;AACJ;;AACD,UAAIiD,kBAAkB,GAAGlD,WAAW,GAAG,CAAvC;AACA,UAAImD,gBAAgB,GAAGlD,SAAS,GAAG,CAAnC;AACAoC,MAAAA,eAAe,GAAGS,KAAK,CAACX,gBAAN,CAAuBe,kBAAvB,EAA2Cb,eAA3C,EAA4DpB,MAA5D,CAAlB;;AACA,UAAI6B,KAAK,CAACb,KAAN,KAAgB,CAApB,EAAuB;AACnBI,QAAAA,eAAe,GAAGa,kBAAlB;AACH;;AACDJ,MAAAA,KAAK,CAACL,MAAN,CAAaU,gBAAb,EAA+BjD,SAA/B;AACH;;AACD4C,IAAAA,KAAK,CAACX,gBAAN,CAAuB;AAAW;AAAlC,MAAgEE,eAAhE,EAAiFpB,MAAjF;AACA,WAAOA,MAAP;AACH,GAnCD;;AAoCA,SAAO0B,yBAAP;AACH,CA3C8C,EAA/C;;AA4CA,SAASA,yBAAT","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nvar LineDecoration = /** @class */ (function () {\r\n    function LineDecoration(startColumn, endColumn, className, type) {\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.className = className;\r\n        this.type = type;\r\n    }\r\n    LineDecoration._equals = function (a, b) {\r\n        return (a.startColumn === b.startColumn\r\n            && a.endColumn === b.endColumn\r\n            && a.className === b.className\r\n            && a.type === b.type);\r\n    };\r\n    LineDecoration.equalsArr = function (a, b) {\r\n        var aLen = a.length;\r\n        var bLen = b.length;\r\n        if (aLen !== bLen) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < aLen; i++) {\r\n            if (!LineDecoration._equals(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    LineDecoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        var result = [], resultLen = 0;\r\n        for (var i = 0, len = lineDecorations.length; i < len; i++) {\r\n            var d = lineDecorations[i];\r\n            var range = d.range;\r\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\r\n                // Ignore decorations that sit outside this line\r\n                continue;\r\n            }\r\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\r\n                // Ignore empty range decorations\r\n                continue;\r\n            }\r\n            var startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\r\n            var endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\r\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\r\n        }\r\n        return result;\r\n    };\r\n    LineDecoration.compare = function (a, b) {\r\n        if (a.startColumn === b.startColumn) {\r\n            if (a.endColumn === b.endColumn) {\r\n                if (a.className < b.className) {\r\n                    return -1;\r\n                }\r\n                if (a.className > b.className) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.startColumn - b.startColumn;\r\n    };\r\n    return LineDecoration;\r\n}());\r\nexport { LineDecoration };\r\nvar DecorationSegment = /** @class */ (function () {\r\n    function DecorationSegment(startOffset, endOffset, className) {\r\n        this.startOffset = startOffset;\r\n        this.endOffset = endOffset;\r\n        this.className = className;\r\n    }\r\n    return DecorationSegment;\r\n}());\r\nexport { DecorationSegment };\r\nvar Stack = /** @class */ (function () {\r\n    function Stack() {\r\n        this.stopOffsets = [];\r\n        this.classNames = [];\r\n        this.count = 0;\r\n    }\r\n    Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {\r\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\r\n            var i = 0;\r\n            // Take all equal stopping offsets\r\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\r\n                i++;\r\n            }\r\n            // Basically we are consuming the first i + 1 elements of the stack\r\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\r\n            nextStartOffset = this.stopOffsets[i] + 1;\r\n            // Consume them\r\n            this.stopOffsets.splice(0, i + 1);\r\n            this.classNames.splice(0, i + 1);\r\n            this.count -= (i + 1);\r\n        }\r\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\r\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\r\n            nextStartOffset = maxStopOffset;\r\n        }\r\n        return nextStartOffset;\r\n    };\r\n    Stack.prototype.insert = function (stopOffset, className) {\r\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\r\n            // Insert at the end\r\n            this.stopOffsets.push(stopOffset);\r\n            this.classNames.push(className);\r\n        }\r\n        else {\r\n            // Find the insertion position for `stopOffset`\r\n            for (var i = 0; i < this.count; i++) {\r\n                if (this.stopOffsets[i] >= stopOffset) {\r\n                    this.stopOffsets.splice(i, 0, stopOffset);\r\n                    this.classNames.splice(i, 0, className);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.count++;\r\n        return;\r\n    };\r\n    return Stack;\r\n}());\r\nvar LineDecorationsNormalizer = /** @class */ (function () {\r\n    function LineDecorationsNormalizer() {\r\n    }\r\n    /**\r\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n     */\r\n    LineDecorationsNormalizer.normalize = function (lineContent, lineDecorations) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        var result = [];\r\n        var stack = new Stack();\r\n        var nextStartOffset = 0;\r\n        for (var i = 0, len = lineDecorations.length; i < len; i++) {\r\n            var d = lineDecorations[i];\r\n            var startColumn = d.startColumn;\r\n            var endColumn = d.endColumn;\r\n            var className = d.className;\r\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\r\n            if (startColumn > 1) {\r\n                var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    startColumn--;\r\n                }\r\n            }\r\n            if (endColumn > 1) {\r\n                var charCodeBefore = lineContent.charCodeAt(endColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    endColumn--;\r\n                }\r\n            }\r\n            var currentStartOffset = startColumn - 1;\r\n            var currentEndOffset = endColumn - 2;\r\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\r\n            if (stack.count === 0) {\r\n                nextStartOffset = currentStartOffset;\r\n            }\r\n            stack.insert(currentEndOffset, className);\r\n        }\r\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\r\n        return result;\r\n    };\r\n    return LineDecorationsNormalizer;\r\n}());\r\nexport { LineDecorationsNormalizer };\r\n"]},"metadata":{},"sourceType":"module"}