{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineBreakData } from './splitLinesCollection.js';\n\nvar WrappingCharacterClassifier =\n/** @class */\nfunction (_super) {\n  __extends(WrappingCharacterClassifier, _super);\n\n  function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER) {\n    var _this = _super.call(this, 0\n    /* NONE */\n    ) || this;\n\n    for (var i = 0; i < BREAK_BEFORE.length; i++) {\n      _this.set(BREAK_BEFORE.charCodeAt(i), 1\n      /* BREAK_BEFORE */\n      );\n    }\n\n    for (var i = 0; i < BREAK_AFTER.length; i++) {\n      _this.set(BREAK_AFTER.charCodeAt(i), 2\n      /* BREAK_AFTER */\n      );\n    }\n\n    return _this;\n  }\n\n  WrappingCharacterClassifier.prototype.get = function (charCode) {\n    if (charCode >= 0 && charCode < 256) {\n      return this._asciiMap[charCode];\n    } else {\n      // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n      // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n      // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n      // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n      if (charCode >= 0x3040 && charCode <= 0x30FF || charCode >= 0x3400 && charCode <= 0x4DBF || charCode >= 0x4E00 && charCode <= 0x9FFF) {\n        return 3\n        /* BREAK_IDEOGRAPHIC */\n        ;\n      }\n\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  };\n\n  return WrappingCharacterClassifier;\n}(CharacterClassifier);\n\nvar arrPool1 = [];\nvar arrPool2 = [];\n\nvar MonospaceLineBreaksComputerFactory =\n/** @class */\nfunction () {\n  function MonospaceLineBreaksComputerFactory(breakBeforeChars, breakAfterChars) {\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n  }\n\n  MonospaceLineBreaksComputerFactory.create = function (options) {\n    return new MonospaceLineBreaksComputerFactory(options.get(99\n    /* wordWrapBreakBeforeCharacters */\n    ), options.get(98\n    /* wordWrapBreakAfterCharacters */\n    ));\n  };\n\n  MonospaceLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    var _this = this;\n\n    tabSize = tabSize | 0; //@perf\n\n    wrappingColumn = +wrappingColumn; //@perf\n\n    var requests = [];\n    var previousBreakingData = [];\n    return {\n      addRequest: function (lineText, previousLineBreakData) {\n        requests.push(lineText);\n        previousBreakingData.push(previousLineBreakData);\n      },\n      finalize: function () {\n        var columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth; //@perf\n\n        var result = [];\n\n        for (var i = 0, len = requests.length; i < len; i++) {\n          var previousLineBreakData = previousBreakingData[i];\n\n          if (previousLineBreakData) {\n            result[i] = createLineBreaksFromPreviousLineBreaks(_this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          } else {\n            result[i] = createLineBreaks(_this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          }\n        }\n\n        arrPool1.length = 0;\n        arrPool2.length = 0;\n        return result;\n      }\n    };\n  };\n\n  return MonospaceLineBreaksComputerFactory;\n}();\n\nexport { MonospaceLineBreaksComputerFactory };\n\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n\n  var len = lineText.length;\n\n  if (len <= 1) {\n    return null;\n  }\n\n  var prevBreakingOffsets = previousBreakingData.breakOffsets;\n  var prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = arrPool1;\n  var breakingOffsetsVisibleColumn = arrPool2;\n  var breakingOffsetsCount = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevLen = prevBreakingOffsets.length;\n  var prevIndex = 0;\n\n  if (prevIndex >= 0) {\n    var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\n    while (prevIndex + 1 < prevLen) {\n      var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\n      if (distance >= bestDistance) {\n        break;\n      }\n\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n\n  while (prevIndex < prevLen) {\n    // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n    var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n    var prevBreakoffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n    var breakOffset = 0;\n    var breakOffsetVisibleColumn = 0;\n    var forcedBreakOffset = 0;\n    var forcedBreakOffsetVisibleColumn = 0; // initially, we search as much as possible to the right (if it fits)\n\n    if (prevBreakoffsetVisibleColumn <= breakingColumn) {\n      var visibleColumn = prevBreakoffsetVisibleColumn;\n      var prevCharCode = lineText.charCodeAt(prevBreakOffset - 1);\n      var prevCharCodeClass = classifier.get(prevCharCode);\n      var entireLineFits = true;\n\n      for (var i = prevBreakOffset; i < len; i++) {\n        var charStartOffset = i;\n        var charCode = lineText.charCodeAt(i);\n        var charCodeClass = void 0;\n        var charWidth = void 0;\n\n        if (strings.isHighSurrogate(charCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i++;\n          charCodeClass = 0\n          /* NONE */\n          ;\n          charWidth = 2;\n        } else {\n          charCodeClass = classifier.get(charCode);\n          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n          breakOffset = charStartOffset;\n          breakOffsetVisibleColumn = visibleColumn;\n        }\n\n        visibleColumn += charWidth; // check if adding character at `i` will go over the breaking column\n\n        if (visibleColumn > breakingColumn) {\n          // We need to break at least before character at `i`:\n          forcedBreakOffset = charStartOffset;\n          forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n\n          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n            // Cannot break at `breakOffset` => reset it if it was set\n            breakOffset = 0;\n          }\n\n          entireLineFits = false;\n          break;\n        }\n\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n      }\n\n      if (entireLineFits) {\n        // there is no more need to break => stop the outer loop!\n        if (breakingOffsetsCount > 0) {\n          // Add last segment\n          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n          breakingOffsetsCount++;\n        }\n\n        break;\n      }\n    }\n\n    if (breakOffset === 0) {\n      // must search left\n      var visibleColumn = prevBreakoffsetVisibleColumn;\n      var charCode = lineText.charCodeAt(prevBreakOffset);\n      var charCodeClass = classifier.get(charCode);\n      var hitATabCharacter = false;\n\n      for (var i = prevBreakOffset - 1; i >= 0; i--) {\n        var charStartOffset = i + 1;\n        var prevCharCode = lineText.charCodeAt(i);\n\n        if (prevCharCode === 9\n        /* Tab */\n        ) {\n            // cannot determine the width of a tab when going backwards, so we must go forwards\n            hitATabCharacter = true;\n            break;\n          }\n\n        var prevCharCodeClass = void 0;\n        var prevCharWidth = void 0;\n\n        if (strings.isLowSurrogate(prevCharCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i--;\n          prevCharCodeClass = 0\n          /* NONE */\n          ;\n          prevCharWidth = 2;\n        } else {\n          prevCharCodeClass = classifier.get(prevCharCode);\n          prevCharWidth = strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1;\n        }\n\n        if (visibleColumn <= breakingColumn) {\n          if (forcedBreakOffset === 0) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n\n          if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n            // went too far!\n            break;\n          }\n\n          if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n            break;\n          }\n        }\n\n        visibleColumn -= prevCharWidth;\n        charCode = prevCharCode;\n        charCodeClass = prevCharCodeClass;\n      }\n\n      if (breakOffset !== 0) {\n        var remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n\n        if (remainingWidthOfNextLine <= tabSize) {\n          var charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n          var charWidth = void 0;\n\n          if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            charWidth = 2;\n          } else {\n            charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n          }\n\n          if (remainingWidthOfNextLine - charWidth < 0) {\n            // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n            breakOffset = 0;\n          }\n        }\n      }\n\n      if (hitATabCharacter) {\n        // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n        prevIndex--;\n        continue;\n      }\n    }\n\n    if (breakOffset === 0) {\n      // Could not find a good breaking point\n      breakOffset = forcedBreakOffset;\n      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n    }\n\n    breakingOffsets[breakingOffsetsCount] = breakOffset;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n    breakingOffsetsCount++;\n    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\n    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {\n      prevIndex++;\n    }\n\n    var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\n    while (prevIndex + 1 < prevLen) {\n      var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\n      if (distance >= bestDistance) {\n        break;\n      }\n\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n\n  if (breakingOffsetsCount === 0) {\n    return null;\n  } // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n\n\n  breakingOffsets.length = breakingOffsetsCount;\n  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n  arrPool1 = previousBreakingData.breakOffsets;\n  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n  previousBreakingData.breakOffsets = breakingOffsets;\n  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n  return previousBreakingData;\n}\n\nfunction createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n\n  var len = lineText.length;\n\n  if (len <= 1) {\n    return null;\n  }\n\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = [];\n  var breakingOffsetsVisibleColumn = [];\n  var breakingOffsetsCount = 0;\n  var breakOffset = 0;\n  var breakOffsetVisibleColumn = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevCharCode = lineText.charCodeAt(0);\n  var prevCharCodeClass = classifier.get(prevCharCode);\n  var visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n  var startOffset = 1;\n\n  if (strings.isHighSurrogate(prevCharCode)) {\n    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n    visibleColumn += 1;\n    prevCharCode = lineText.charCodeAt(1);\n    prevCharCodeClass = classifier.get(prevCharCode);\n    startOffset++;\n  }\n\n  for (var i = startOffset; i < len; i++) {\n    var charStartOffset = i;\n    var charCode = lineText.charCodeAt(i);\n    var charCodeClass = void 0;\n    var charWidth = void 0;\n\n    if (strings.isHighSurrogate(charCode)) {\n      // A surrogate pair must always be considered as a single unit, so it is never to be broken\n      i++;\n      charCodeClass = 0\n      /* NONE */\n      ;\n      charWidth = 2;\n    } else {\n      charCodeClass = classifier.get(charCode);\n      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n    }\n\n    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n      breakOffset = charStartOffset;\n      breakOffsetVisibleColumn = visibleColumn;\n    }\n\n    visibleColumn += charWidth; // check if adding character at `i` will go over the breaking column\n\n    if (visibleColumn > breakingColumn) {\n      // We need to break at least before character at `i`:\n      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n        // Cannot break at `breakOffset`, must break at `i`\n        breakOffset = charStartOffset;\n        breakOffsetVisibleColumn = visibleColumn - charWidth;\n      }\n\n      breakingOffsets[breakingOffsetsCount] = breakOffset;\n      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n      breakingOffsetsCount++;\n      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n      breakOffset = 0;\n    }\n\n    prevCharCode = charCode;\n    prevCharCodeClass = charCodeClass;\n  }\n\n  if (breakingOffsetsCount === 0) {\n    return null;\n  } // Add last segment\n\n\n  breakingOffsets[breakingOffsetsCount] = len;\n  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n  return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\n\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n  if (charCode === 9\n  /* Tab */\n  ) {\n      return tabSize - visibleColumn % tabSize;\n    }\n\n  if (strings.isFullWidthCharacter(charCode)) {\n    return columnsForFullWidthChar;\n  }\n\n  return 1;\n}\n\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n  return tabSize - visibleColumn % tabSize;\n}\n/**\r\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\r\n * Kinsoku Shori : Don't break before a trailing character, like a period\r\n */\n\n\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n  return charCode !== 32\n  /* Space */\n  && (prevCharCodeClass === 2\n  /* BREAK_AFTER */\n  || prevCharCodeClass === 3\n  /* BREAK_IDEOGRAPHIC */\n  && charCodeClass !== 2\n  /* BREAK_AFTER */\n  || charCodeClass === 1\n  /* BREAK_BEFORE */\n  || charCodeClass === 3\n  /* BREAK_IDEOGRAPHIC */\n  && prevCharCodeClass !== 1\n  /* BREAK_BEFORE */\n  );\n}\n\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  var wrappedTextIndentLength = 0;\n\n  if (wrappingIndent !== 0\n  /* None */\n  ) {\n      var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\n      if (firstNonWhitespaceIndex !== -1) {\n        // Track existing indent\n        for (var i = 0; i < firstNonWhitespaceIndex; i++) {\n          var charWidth = lineText.charCodeAt(i) === 9\n          /* Tab */\n          ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;\n          wrappedTextIndentLength += charWidth;\n        } // Increase indent of continuation lines, if desired\n\n\n        var numberOfAdditionalTabs = wrappingIndent === 3\n        /* DeepIndent */\n        ? 2 : wrappingIndent === 2\n        /* Indent */\n        ? 1 : 0;\n\n        for (var i = 0; i < numberOfAdditionalTabs; i++) {\n          var charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n          wrappedTextIndentLength += charWidth;\n        } // Force sticking to beginning of line if no character would fit except for the indentation\n\n\n        if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n          wrappedTextIndentLength = 0;\n        }\n      }\n    }\n\n  return wrappedTextIndentLength;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","strings","CharacterClassifier","LineBreakData","WrappingCharacterClassifier","_super","BREAK_BEFORE","BREAK_AFTER","_this","call","i","length","set","charCodeAt","get","charCode","_asciiMap","_map","_defaultValue","arrPool1","arrPool2","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","options","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","previousBreakingData","addRequest","lineText","previousLineBreakData","push","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","len","createLineBreaksFromPreviousLineBreaks","createLineBreaks","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","breakingColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakoffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","visibleColumn","prevCharCode","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","charWidth","isHighSurrogate","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","isLowSurrogate","isFullWidthCharacter","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","startOffset","tabCharacterWidth","firstNonWhitespaceIndex","numberOfAdditionalTabs"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CharacterClassifier } from '../core/characterClassifier.js';\r\nimport { LineBreakData } from './splitLinesCollection.js';\r\nvar WrappingCharacterClassifier = /** @class */ (function (_super) {\r\n    __extends(WrappingCharacterClassifier, _super);\r\n    function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER) {\r\n        var _this = _super.call(this, 0 /* NONE */) || this;\r\n        for (var i = 0; i < BREAK_BEFORE.length; i++) {\r\n            _this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\r\n        }\r\n        for (var i = 0; i < BREAK_AFTER.length; i++) {\r\n            _this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\r\n        }\r\n        return _this;\r\n    }\r\n    WrappingCharacterClassifier.prototype.get = function (charCode) {\r\n        if (charCode >= 0 && charCode < 256) {\r\n            return this._asciiMap[charCode];\r\n        }\r\n        else {\r\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\r\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\r\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\r\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\r\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\r\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\r\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\r\n                return 3 /* BREAK_IDEOGRAPHIC */;\r\n            }\r\n            return (this._map.get(charCode) || this._defaultValue);\r\n        }\r\n    };\r\n    return WrappingCharacterClassifier;\r\n}(CharacterClassifier));\r\nvar arrPool1 = [];\r\nvar arrPool2 = [];\r\nvar MonospaceLineBreaksComputerFactory = /** @class */ (function () {\r\n    function MonospaceLineBreaksComputerFactory(breakBeforeChars, breakAfterChars) {\r\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\r\n    }\r\n    MonospaceLineBreaksComputerFactory.create = function (options) {\r\n        return new MonospaceLineBreaksComputerFactory(options.get(99 /* wordWrapBreakBeforeCharacters */), options.get(98 /* wordWrapBreakAfterCharacters */));\r\n    };\r\n    MonospaceLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        var _this = this;\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        var requests = [];\r\n        var previousBreakingData = [];\r\n        return {\r\n            addRequest: function (lineText, previousLineBreakData) {\r\n                requests.push(lineText);\r\n                previousBreakingData.push(previousLineBreakData);\r\n            },\r\n            finalize: function () {\r\n                var columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth; //@perf\r\n                var result = [];\r\n                for (var i = 0, len = requests.length; i < len; i++) {\r\n                    var previousLineBreakData = previousBreakingData[i];\r\n                    if (previousLineBreakData) {\r\n                        result[i] = createLineBreaksFromPreviousLineBreaks(_this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\r\n                    }\r\n                    else {\r\n                        result[i] = createLineBreaks(_this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\r\n                    }\r\n                }\r\n                arrPool1.length = 0;\r\n                arrPool2.length = 0;\r\n                return result;\r\n            }\r\n        };\r\n    };\r\n    return MonospaceLineBreaksComputerFactory;\r\n}());\r\nexport { MonospaceLineBreaksComputerFactory };\r\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        return null;\r\n    }\r\n    var len = lineText.length;\r\n    if (len <= 1) {\r\n        return null;\r\n    }\r\n    var prevBreakingOffsets = previousBreakingData.breakOffsets;\r\n    var prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\r\n    var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\r\n    var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\r\n    var breakingOffsets = arrPool1;\r\n    var breakingOffsetsVisibleColumn = arrPool2;\r\n    var breakingOffsetsCount = 0;\r\n    var breakingColumn = firstLineBreakColumn;\r\n    var prevLen = prevBreakingOffsets.length;\r\n    var prevIndex = 0;\r\n    if (prevIndex >= 0) {\r\n        var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\r\n        while (prevIndex + 1 < prevLen) {\r\n            var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\r\n            if (distance >= bestDistance) {\r\n                break;\r\n            }\r\n            bestDistance = distance;\r\n            prevIndex++;\r\n        }\r\n    }\r\n    while (prevIndex < prevLen) {\r\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\r\n        var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\r\n        var prevBreakoffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\r\n        var breakOffset = 0;\r\n        var breakOffsetVisibleColumn = 0;\r\n        var forcedBreakOffset = 0;\r\n        var forcedBreakOffsetVisibleColumn = 0;\r\n        // initially, we search as much as possible to the right (if it fits)\r\n        if (prevBreakoffsetVisibleColumn <= breakingColumn) {\r\n            var visibleColumn = prevBreakoffsetVisibleColumn;\r\n            var prevCharCode = lineText.charCodeAt(prevBreakOffset - 1);\r\n            var prevCharCodeClass = classifier.get(prevCharCode);\r\n            var entireLineFits = true;\r\n            for (var i = prevBreakOffset; i < len; i++) {\r\n                var charStartOffset = i;\r\n                var charCode = lineText.charCodeAt(i);\r\n                var charCodeClass = void 0;\r\n                var charWidth = void 0;\r\n                if (strings.isHighSurrogate(charCode)) {\r\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                    i++;\r\n                    charCodeClass = 0 /* NONE */;\r\n                    charWidth = 2;\r\n                }\r\n                else {\r\n                    charCodeClass = classifier.get(charCode);\r\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\r\n                }\r\n                if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n                    breakOffset = charStartOffset;\r\n                    breakOffsetVisibleColumn = visibleColumn;\r\n                }\r\n                visibleColumn += charWidth;\r\n                // check if adding character at `i` will go over the breaking column\r\n                if (visibleColumn > breakingColumn) {\r\n                    // We need to break at least before character at `i`:\r\n                    forcedBreakOffset = charStartOffset;\r\n                    forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\r\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\r\n                        // Cannot break at `breakOffset` => reset it if it was set\r\n                        breakOffset = 0;\r\n                    }\r\n                    entireLineFits = false;\r\n                    break;\r\n                }\r\n                prevCharCode = charCode;\r\n                prevCharCodeClass = charCodeClass;\r\n            }\r\n            if (entireLineFits) {\r\n                // there is no more need to break => stop the outer loop!\r\n                if (breakingOffsetsCount > 0) {\r\n                    // Add last segment\r\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\r\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\r\n                    breakingOffsetsCount++;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (breakOffset === 0) {\r\n            // must search left\r\n            var visibleColumn = prevBreakoffsetVisibleColumn;\r\n            var charCode = lineText.charCodeAt(prevBreakOffset);\r\n            var charCodeClass = classifier.get(charCode);\r\n            var hitATabCharacter = false;\r\n            for (var i = prevBreakOffset - 1; i >= 0; i--) {\r\n                var charStartOffset = i + 1;\r\n                var prevCharCode = lineText.charCodeAt(i);\r\n                if (prevCharCode === 9 /* Tab */) {\r\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\r\n                    hitATabCharacter = true;\r\n                    break;\r\n                }\r\n                var prevCharCodeClass = void 0;\r\n                var prevCharWidth = void 0;\r\n                if (strings.isLowSurrogate(prevCharCode)) {\r\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                    i--;\r\n                    prevCharCodeClass = 0 /* NONE */;\r\n                    prevCharWidth = 2;\r\n                }\r\n                else {\r\n                    prevCharCodeClass = classifier.get(prevCharCode);\r\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\r\n                }\r\n                if (visibleColumn <= breakingColumn) {\r\n                    if (forcedBreakOffset === 0) {\r\n                        forcedBreakOffset = charStartOffset;\r\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\r\n                    }\r\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\r\n                        // went too far!\r\n                        break;\r\n                    }\r\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n                        breakOffset = charStartOffset;\r\n                        breakOffsetVisibleColumn = visibleColumn;\r\n                        break;\r\n                    }\r\n                }\r\n                visibleColumn -= prevCharWidth;\r\n                charCode = prevCharCode;\r\n                charCodeClass = prevCharCodeClass;\r\n            }\r\n            if (breakOffset !== 0) {\r\n                var remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\r\n                if (remainingWidthOfNextLine <= tabSize) {\r\n                    var charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\r\n                    var charWidth = void 0;\r\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\r\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                        charWidth = 2;\r\n                    }\r\n                    else {\r\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\r\n                    }\r\n                    if (remainingWidthOfNextLine - charWidth < 0) {\r\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\r\n                        breakOffset = 0;\r\n                    }\r\n                }\r\n            }\r\n            if (hitATabCharacter) {\r\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\r\n                prevIndex--;\r\n                continue;\r\n            }\r\n        }\r\n        if (breakOffset === 0) {\r\n            // Could not find a good breaking point\r\n            breakOffset = forcedBreakOffset;\r\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\r\n        }\r\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\r\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\r\n        breakingOffsetsCount++;\r\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\r\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\r\n            prevIndex++;\r\n        }\r\n        var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\r\n        while (prevIndex + 1 < prevLen) {\r\n            var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\r\n            if (distance >= bestDistance) {\r\n                break;\r\n            }\r\n            bestDistance = distance;\r\n            prevIndex++;\r\n        }\r\n    }\r\n    if (breakingOffsetsCount === 0) {\r\n        return null;\r\n    }\r\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\r\n    breakingOffsets.length = breakingOffsetsCount;\r\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\r\n    arrPool1 = previousBreakingData.breakOffsets;\r\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\r\n    previousBreakingData.breakOffsets = breakingOffsets;\r\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\r\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\r\n    return previousBreakingData;\r\n}\r\nfunction createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        return null;\r\n    }\r\n    var len = lineText.length;\r\n    if (len <= 1) {\r\n        return null;\r\n    }\r\n    var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\r\n    var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\r\n    var breakingOffsets = [];\r\n    var breakingOffsetsVisibleColumn = [];\r\n    var breakingOffsetsCount = 0;\r\n    var breakOffset = 0;\r\n    var breakOffsetVisibleColumn = 0;\r\n    var breakingColumn = firstLineBreakColumn;\r\n    var prevCharCode = lineText.charCodeAt(0);\r\n    var prevCharCodeClass = classifier.get(prevCharCode);\r\n    var visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\r\n    var startOffset = 1;\r\n    if (strings.isHighSurrogate(prevCharCode)) {\r\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n        visibleColumn += 1;\r\n        prevCharCode = lineText.charCodeAt(1);\r\n        prevCharCodeClass = classifier.get(prevCharCode);\r\n        startOffset++;\r\n    }\r\n    for (var i = startOffset; i < len; i++) {\r\n        var charStartOffset = i;\r\n        var charCode = lineText.charCodeAt(i);\r\n        var charCodeClass = void 0;\r\n        var charWidth = void 0;\r\n        if (strings.isHighSurrogate(charCode)) {\r\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n            i++;\r\n            charCodeClass = 0 /* NONE */;\r\n            charWidth = 2;\r\n        }\r\n        else {\r\n            charCodeClass = classifier.get(charCode);\r\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\r\n        }\r\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n            breakOffset = charStartOffset;\r\n            breakOffsetVisibleColumn = visibleColumn;\r\n        }\r\n        visibleColumn += charWidth;\r\n        // check if adding character at `i` will go over the breaking column\r\n        if (visibleColumn > breakingColumn) {\r\n            // We need to break at least before character at `i`:\r\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\r\n                // Cannot break at `breakOffset`, must break at `i`\r\n                breakOffset = charStartOffset;\r\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\r\n            }\r\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\r\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\r\n            breakingOffsetsCount++;\r\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\r\n            breakOffset = 0;\r\n        }\r\n        prevCharCode = charCode;\r\n        prevCharCodeClass = charCodeClass;\r\n    }\r\n    if (breakingOffsetsCount === 0) {\r\n        return null;\r\n    }\r\n    // Add last segment\r\n    breakingOffsets[breakingOffsetsCount] = len;\r\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\r\n    return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\r\n}\r\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\r\n    if (charCode === 9 /* Tab */) {\r\n        return (tabSize - (visibleColumn % tabSize));\r\n    }\r\n    if (strings.isFullWidthCharacter(charCode)) {\r\n        return columnsForFullWidthChar;\r\n    }\r\n    return 1;\r\n}\r\nfunction tabCharacterWidth(visibleColumn, tabSize) {\r\n    return (tabSize - (visibleColumn % tabSize));\r\n}\r\n/**\r\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\r\n * Kinsoku Shori : Don't break before a trailing character, like a period\r\n */\r\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\r\n    return (charCode !== 32 /* Space */\r\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\r\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\r\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\r\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\r\n}\r\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    var wrappedTextIndentLength = 0;\r\n    if (wrappingIndent !== 0 /* None */) {\r\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\r\n        if (firstNonWhitespaceIndex !== -1) {\r\n            // Track existing indent\r\n            for (var i = 0; i < firstNonWhitespaceIndex; i++) {\r\n                var charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\r\n                wrappedTextIndentLength += charWidth;\r\n            }\r\n            // Increase indent of continuation lines, if desired\r\n            var numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\r\n            for (var i = 0; i < numberOfAdditionalTabs; i++) {\r\n                var charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\r\n                wrappedTextIndentLength += charWidth;\r\n            }\r\n            // Force sticking to beginning of line if no character would fit except for the indentation\r\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\r\n                wrappedTextIndentLength = 0;\r\n            }\r\n        }\r\n    }\r\n    return wrappedTextIndentLength;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}