{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n\nvar FullTextDocument =\n/** @class */\nfunction () {\n  function FullTextDocument(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = undefined;\n  }\n\n  Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n    get: function () {\n      return this._uri;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n    get: function () {\n      return this._languageId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"version\", {\n    get: function () {\n      return this._version;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FullTextDocument.prototype.getText = function (range) {\n    if (range) {\n      var start = this.offsetAt(range.start);\n      var end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n\n    return this._content;\n  };\n\n  FullTextDocument.prototype.update = function (changes, version) {\n    for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n      var change = changes_1[_i];\n\n      if (FullTextDocument.isIncremental(change)) {\n        // makes sure start is before end\n        var range = getWellformedRange(change.range); // update content\n\n        var startOffset = this.offsetAt(range.start);\n        var endOffset = this.offsetAt(range.end);\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length); // update the offsets\n\n        var startLine = Math.max(range.start.line, 0);\n        var endLine = Math.max(range.end.line, 0);\n        var lineOffsets = this._lineOffsets;\n        var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n\n        if (endLine - startLine === addedLineOffsets.length) {\n          for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n          }\n        } else {\n          if (addedLineOffsets.length < 10000) {\n            lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\n          } else {\n            // avoid too many arguments for splice\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n          }\n        }\n\n        var diff = change.text.length - (endOffset - startOffset);\n\n        if (diff !== 0) {\n          for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n            lineOffsets[i] = lineOffsets[i] + diff;\n          }\n        }\n      } else if (FullTextDocument.isFull(change)) {\n        this._content = change.text;\n        this._lineOffsets = undefined;\n      } else {\n        throw new Error('Unknown change event received');\n      }\n    }\n\n    this._version = version;\n  };\n\n  FullTextDocument.prototype.getLineOffsets = function () {\n    if (this._lineOffsets === undefined) {\n      this._lineOffsets = computeLineOffsets(this._content, true);\n    }\n\n    return this._lineOffsets;\n  };\n\n  FullTextDocument.prototype.positionAt = function (offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    var lineOffsets = this.getLineOffsets();\n    var low = 0,\n        high = lineOffsets.length;\n\n    if (high === 0) {\n      return {\n        line: 0,\n        character: offset\n      };\n    }\n\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    } // low is the least x for which the line offset is larger than the current offset\n    // or array.length if no line offset is larger than the current offset\n\n\n    var line = low - 1;\n    return {\n      line: line,\n      character: offset - lineOffsets[line]\n    };\n  };\n\n  FullTextDocument.prototype.offsetAt = function (position) {\n    var lineOffsets = this.getLineOffsets();\n\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n\n    var lineOffset = lineOffsets[position.line];\n    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  };\n\n  Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n    get: function () {\n      return this.getLineOffsets().length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FullTextDocument.isIncremental = function (event) {\n    var candidate = event;\n    return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n  };\n\n  FullTextDocument.isFull = function (event) {\n    var candidate = event;\n    return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n  };\n\n  return FullTextDocument;\n}();\n\nexport var TextDocument;\n\n(function (TextDocument) {\n  /**\r\n   * Creates a new text document.\r\n   *\r\n   * @param uri The document's uri.\r\n   * @param languageId  The document's language Id.\r\n   * @param version The document's initial version number.\r\n   * @param content The document's content.\r\n   */\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument(uri, languageId, version, content);\n  }\n\n  TextDocument.create = create;\n  /**\r\n   * Updates a TextDocument by modifing its content.\r\n   *\r\n   * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n   * @param changes the changes to apply to the document.\r\n   * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n   *\r\n   */\n\n  function update(document, changes, version) {\n    if (document instanceof FullTextDocument) {\n      document.update(changes, version);\n      return document;\n    } else {\n      throw new Error('TextDocument.update: document must be created by TextDocument.create');\n    }\n  }\n\n  TextDocument.update = update;\n\n  function applyEdits(document, edits) {\n    var text = document.getText();\n    var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n      var diff = a.range.start.line - b.range.start.line;\n\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n\n      return diff;\n    });\n    var lastModifiedOffset = text.length;\n\n    for (var i = sortedEdits.length - 1; i >= 0; i--) {\n      var e = sortedEdits[i];\n      var startOffset = document.offsetAt(e.range.start);\n      var endOffset = document.offsetAt(e.range.end);\n\n      if (endOffset <= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error('Overlapping edit');\n      }\n\n      lastModifiedOffset = startOffset;\n    }\n\n    return text;\n  }\n\n  TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\n\nfunction mergeSort(data, compare) {\n  if (data.length <= 1) {\n    // sorted\n    return data;\n  }\n\n  var p = data.length / 2 | 0;\n  var left = data.slice(0, p);\n  var right = data.slice(p);\n  mergeSort(left, compare);\n  mergeSort(right, compare);\n  var leftIdx = 0;\n  var rightIdx = 0;\n  var i = 0;\n\n  while (leftIdx < left.length && rightIdx < right.length) {\n    var ret = compare(left[leftIdx], right[rightIdx]);\n\n    if (ret <= 0) {\n      // smaller_equal -> take left to preserve order\n      data[i++] = left[leftIdx++];\n    } else {\n      // greater -> take right\n      data[i++] = right[rightIdx++];\n    }\n  }\n\n  while (leftIdx < left.length) {\n    data[i++] = left[leftIdx++];\n  }\n\n  while (rightIdx < right.length) {\n    data[i++] = right[rightIdx++];\n  }\n\n  return data;\n}\n\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n  if (textOffset === void 0) {\n    textOffset = 0;\n  }\n\n  var result = isAtLineStart ? [textOffset] : [];\n\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charCodeAt(i);\n\n    if (ch === 13\n    /* CarriageReturn */\n    || ch === 10\n    /* LineFeed */\n    ) {\n        if (ch === 13\n        /* CarriageReturn */\n        && i + 1 < text.length && text.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            i++;\n          }\n\n        result.push(textOffset + i + 1);\n      }\n  }\n\n  return result;\n}\n\nfunction getWellformedRange(range) {\n  var start = range.start;\n  var end = range.end;\n\n  if (start.line > end.line || start.line === end.line && start.character > end.character) {\n    return {\n      start: end,\n      end: start\n    };\n  }\n\n  return range;\n}\n\nfunction getWellformedEdit(textEdit) {\n  var range = getWellformedRange(textEdit.range);\n\n  if (range !== textEdit.range) {\n    return {\n      newText: textEdit.newText,\n      range: range\n    };\n  }\n\n  return textEdit;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-textdocument/lib/esm/main.js"],"names":["FullTextDocument","uri","languageId","version","content","_uri","_languageId","_version","_content","_lineOffsets","undefined","Object","defineProperty","prototype","get","enumerable","configurable","getText","range","start","offsetAt","end","substring","update","changes","_i","changes_1","length","change","isIncremental","getWellformedRange","startOffset","endOffset","text","startLine","Math","max","line","endLine","lineOffsets","addedLineOffsets","computeLineOffsets","i","len","splice","apply","concat","slice","diff","isFull","Error","getLineOffsets","positionAt","offset","min","low","high","character","mid","floor","position","lineOffset","nextLineOffset","event","candidate","rangeLength","TextDocument","create","document","applyEdits","edits","sortedEdits","mergeSort","map","getWellformedEdit","a","b","lastModifiedOffset","e","newText","data","compare","p","left","right","leftIdx","rightIdx","ret","isAtLineStart","textOffset","result","ch","charCodeAt","push","textEdit"],"mappings":"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","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (changes, version) {\r\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\r\n            var change = changes_1[_i];\r\n            if (FullTextDocument.isIncremental(change)) {\r\n                // makes sure start is before end\r\n                var range = getWellformedRange(change.range);\r\n                // update content\r\n                var startOffset = this.offsetAt(range.start);\r\n                var endOffset = this.offsetAt(range.end);\r\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\r\n                // update the offsets\r\n                var startLine = Math.max(range.start.line, 0);\r\n                var endLine = Math.max(range.end.line, 0);\r\n                var lineOffsets = this._lineOffsets;\r\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\r\n                if (endLine - startLine === addedLineOffsets.length) {\r\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\r\n                    }\r\n                }\r\n                else {\r\n                    if (addedLineOffsets.length < 10000) {\r\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\r\n                    }\r\n                    else { // avoid too many arguments for splice\r\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\r\n                    }\r\n                }\r\n                var diff = change.text.length - (endOffset - startOffset);\r\n                if (diff !== 0) {\r\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i] = lineOffsets[i] + diff;\r\n                    }\r\n                }\r\n            }\r\n            else if (FullTextDocument.isFull(change)) {\r\n                this._content = change.text;\r\n                this._lineOffsets = undefined;\r\n            }\r\n            else {\r\n                throw new Error('Unknown change event received');\r\n            }\r\n        }\r\n        this._version = version;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === undefined) {\r\n            this._lineOffsets = computeLineOffsets(this._content, true);\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return { line: 0, character: offset };\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return { line: line, character: offset - lineOffsets[line] };\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.isIncremental = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\r\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\r\n    };\r\n    FullTextDocument.isFull = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\r\n    };\r\n    return FullTextDocument;\r\n}());\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new text document.\r\n     *\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param version The document's initial version number.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Updates a TextDocument by modifing its content.\r\n     *\r\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n     * @param changes the changes to apply to the document.\r\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n     *\r\n     */\r\n    function update(document, changes, version) {\r\n        if (document instanceof FullTextDocument) {\r\n            document.update(changes, version);\r\n            return document;\r\n        }\r\n        else {\r\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\r\n        }\r\n    }\r\n    TextDocument.update = update;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n})(TextDocument || (TextDocument = {}));\r\nfunction mergeSort(data, compare) {\r\n    if (data.length <= 1) {\r\n        // sorted\r\n        return data;\r\n    }\r\n    var p = (data.length / 2) | 0;\r\n    var left = data.slice(0, p);\r\n    var right = data.slice(p);\r\n    mergeSort(left, compare);\r\n    mergeSort(right, compare);\r\n    var leftIdx = 0;\r\n    var rightIdx = 0;\r\n    var i = 0;\r\n    while (leftIdx < left.length && rightIdx < right.length) {\r\n        var ret = compare(left[leftIdx], right[rightIdx]);\r\n        if (ret <= 0) {\r\n            // smaller_equal -> take left to preserve order\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        else {\r\n            // greater -> take right\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n    }\r\n    while (leftIdx < left.length) {\r\n        data[i++] = left[leftIdx++];\r\n    }\r\n    while (rightIdx < right.length) {\r\n        data[i++] = right[rightIdx++];\r\n    }\r\n    return data;\r\n}\r\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\r\n    if (textOffset === void 0) { textOffset = 0; }\r\n    var result = isAtLineStart ? [textOffset] : [];\r\n    for (var i = 0; i < text.length; i++) {\r\n        var ch = text.charCodeAt(i);\r\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\r\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                i++;\r\n            }\r\n            result.push(textOffset + i + 1);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getWellformedRange(range) {\r\n    var start = range.start;\r\n    var end = range.end;\r\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\r\n        return { start: end, end: start };\r\n    }\r\n    return range;\r\n}\r\nfunction getWellformedEdit(textEdit) {\r\n    var range = getWellformedRange(textEdit.range);\r\n    if (range !== textEdit.range) {\r\n        return { newText: textEdit.newText, range: range };\r\n    }\r\n    return textEdit;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}