{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from './uri.js';\nimport { posix, normalize } from './path.js';\nimport { startsWithIgnoreCase, rtrim, startsWith } from './strings.js';\nimport { Schemas } from './network.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { isEqual, basename, relativePath } from './resources.js';\n/**\r\n * @deprecated use LabelService instead\r\n */\n\nexport function getPathLabel(resource, userHomeProvider, rootProvider) {\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  } // return early if we can resolve a relative path label from the root\n\n\n  if (rootProvider) {\n    var baseResource = rootProvider.getWorkspaceFolder(resource);\n\n    if (baseResource) {\n      var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n      var pathLabel = void 0;\n\n      if (isEqual(baseResource.uri, resource)) {\n        pathLabel = ''; // no label if paths are identical\n      } else {\n        pathLabel = relativePath(baseResource.uri, resource);\n      }\n\n      if (hasMultipleRoots) {\n        var rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\n        pathLabel = pathLabel ? rootName + ' • ' + pathLabel : rootName; // always show root basename if there are multiple\n      }\n\n      return pathLabel;\n    }\n  } // return if the resource is neither file:// nor untitled:// and no baseResource was provided\n\n\n  if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n    return resource.with({\n      query: null,\n      fragment: null\n    }).toString(true);\n  } // convert c:\\something => C:\\something\n\n\n  if (hasDriveLetter(resource.fsPath)) {\n    return normalize(normalizeDriveLetter(resource.fsPath));\n  } // normalize and tildify (macOS, Linux only)\n\n\n  var res = normalize(resource.fsPath);\n\n  if (!isWindows && userHomeProvider) {\n    res = tildify(res, userHomeProvider.userHome);\n  }\n\n  return res;\n}\nexport function getBaseLabel(resource) {\n  if (!resource) {\n    return undefined;\n  }\n\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  }\n\n  var base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path)\n  /* can be empty string if '/' is passed in */\n  ; // convert c: => C:\n\n  if (hasDriveLetter(base)) {\n    return normalizeDriveLetter(base);\n  }\n\n  return base;\n}\n\nfunction hasDriveLetter(path) {\n  return !!(isWindows && path && path[1] === ':');\n}\n\nexport function normalizeDriveLetter(path) {\n  if (hasDriveLetter(path)) {\n    return path.charAt(0).toUpperCase() + path.slice(1);\n  }\n\n  return path;\n}\nvar normalizedUserHomeCached = Object.create(null);\nexport function tildify(path, userHome) {\n  if (isWindows || !path || !userHome) {\n    return path; // unsupported\n  } // Keep a normalized user home path as cache to prevent accumulated string creation\n\n\n  var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\n  if (!normalizedUserHome) {\n    normalizedUserHome = \"\" + rtrim(userHome, posix.sep) + posix.sep;\n    normalizedUserHomeCached = {\n      original: userHome,\n      normalized: normalizedUserHome\n    };\n  } // Linux: case sensitive, macOS: case insensitive\n\n\n  if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n    path = \"~/\" + path.substr(normalizedUserHome.length);\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/labels.js"],"names":["URI","posix","normalize","startsWithIgnoreCase","rtrim","startsWith","Schemas","isLinux","isWindows","isEqual","basename","relativePath","getPathLabel","resource","userHomeProvider","rootProvider","file","baseResource","getWorkspaceFolder","hasMultipleRoots","getWorkspace","folders","length","pathLabel","uri","rootName","name","scheme","untitled","with","query","fragment","toString","hasDriveLetter","fsPath","normalizeDriveLetter","res","tildify","userHome","getBaseLabel","undefined","base","path","charAt","toUpperCase","slice","normalizedUserHomeCached","Object","create","normalizedUserHome","original","normalized","sep","substr"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { URI } from './uri.js';\r\nimport { posix, normalize } from './path.js';\r\nimport { startsWithIgnoreCase, rtrim, startsWith } from './strings.js';\r\nimport { Schemas } from './network.js';\r\nimport { isLinux, isWindows } from './platform.js';\r\nimport { isEqual, basename, relativePath } from './resources.js';\r\n/**\r\n * @deprecated use LabelService instead\r\n */\r\nexport function getPathLabel(resource, userHomeProvider, rootProvider) {\r\n    if (typeof resource === 'string') {\r\n        resource = URI.file(resource);\r\n    }\r\n    // return early if we can resolve a relative path label from the root\r\n    if (rootProvider) {\r\n        var baseResource = rootProvider.getWorkspaceFolder(resource);\r\n        if (baseResource) {\r\n            var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\r\n            var pathLabel = void 0;\r\n            if (isEqual(baseResource.uri, resource)) {\r\n                pathLabel = ''; // no label if paths are identical\r\n            }\r\n            else {\r\n                pathLabel = relativePath(baseResource.uri, resource);\r\n            }\r\n            if (hasMultipleRoots) {\r\n                var rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\r\n                pathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple\r\n            }\r\n            return pathLabel;\r\n        }\r\n    }\r\n    // return if the resource is neither file:// nor untitled:// and no baseResource was provided\r\n    if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\r\n        return resource.with({ query: null, fragment: null }).toString(true);\r\n    }\r\n    // convert c:\\something => C:\\something\r\n    if (hasDriveLetter(resource.fsPath)) {\r\n        return normalize(normalizeDriveLetter(resource.fsPath));\r\n    }\r\n    // normalize and tildify (macOS, Linux only)\r\n    var res = normalize(resource.fsPath);\r\n    if (!isWindows && userHomeProvider) {\r\n        res = tildify(res, userHomeProvider.userHome);\r\n    }\r\n    return res;\r\n}\r\nexport function getBaseLabel(resource) {\r\n    if (!resource) {\r\n        return undefined;\r\n    }\r\n    if (typeof resource === 'string') {\r\n        resource = URI.file(resource);\r\n    }\r\n    var base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\r\n    // convert c: => C:\r\n    if (hasDriveLetter(base)) {\r\n        return normalizeDriveLetter(base);\r\n    }\r\n    return base;\r\n}\r\nfunction hasDriveLetter(path) {\r\n    return !!(isWindows && path && path[1] === ':');\r\n}\r\nexport function normalizeDriveLetter(path) {\r\n    if (hasDriveLetter(path)) {\r\n        return path.charAt(0).toUpperCase() + path.slice(1);\r\n    }\r\n    return path;\r\n}\r\nvar normalizedUserHomeCached = Object.create(null);\r\nexport function tildify(path, userHome) {\r\n    if (isWindows || !path || !userHome) {\r\n        return path; // unsupported\r\n    }\r\n    // Keep a normalized user home path as cache to prevent accumulated string creation\r\n    var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\r\n    if (!normalizedUserHome) {\r\n        normalizedUserHome = \"\" + rtrim(userHome, posix.sep) + posix.sep;\r\n        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\r\n    }\r\n    // Linux: case sensitive, macOS: case insensitive\r\n    if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\r\n        path = \"~/\" + path.substr(normalizedUserHome.length);\r\n    }\r\n    return path;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}