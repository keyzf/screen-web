{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nvar MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\nexport var ID_INDENT_PROVIDER = 'indent';\n\nvar IndentRangeProvider =\n/** @class */\nfunction () {\n  function IndentRangeProvider(editorModel) {\n    this.editorModel = editorModel;\n    this.id = ID_INDENT_PROVIDER;\n  }\n\n  IndentRangeProvider.prototype.dispose = function () {};\n\n  IndentRangeProvider.prototype.compute = function (cancelationToken) {\n    var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\n    var offSide = foldingRules && !!foldingRules.offSide;\n    var markers = foldingRules && foldingRules.markers;\n    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n  };\n\n  return IndentRangeProvider;\n}();\n\nexport { IndentRangeProvider }; // public only for testing\n\nvar RangesCollector =\n/** @class */\nfunction () {\n  function RangesCollector(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  RangesCollector.prototype.insertFirst = function (startLineNumber, endLineNumber, indent) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    var index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._length++;\n\n    if (indent < 1000) {\n      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n    }\n  };\n\n  RangesCollector.prototype.toIndentRanges = function (model) {\n    if (this._length <= this._foldingRangesLimit) {\n      // reverse and create arrays of the exact length\n      var startIndexes = new Uint32Array(this._length);\n      var endIndexes = new Uint32Array(this._length);\n\n      for (var i = this._length - 1, k = 0; i >= 0; i--, k++) {\n        startIndexes[k] = this._startIndexes[i];\n        endIndexes[k] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    } else {\n      var entries = 0;\n      var maxIndent = this._indentOccurrences.length;\n\n      for (var i = 0; i < this._indentOccurrences.length; i++) {\n        var n = this._indentOccurrences[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxIndent = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      var tabSize = model.getOptions().tabSize; // reverse and create arrays of the exact length\n\n      var startIndexes = new Uint32Array(this._foldingRangesLimit);\n      var endIndexes = new Uint32Array(this._foldingRangesLimit);\n\n      for (var i = this._length - 1, k = 0; i >= 0; i--) {\n        var startIndex = this._startIndexes[i];\n        var lineContent = model.getLineContent(startIndex);\n        var indent = TextModel.computeIndentLevel(lineContent, tabSize);\n\n        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = startIndex;\n          endIndexes[k] = this._endIndexes[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    }\n  };\n\n  return RangesCollector;\n}();\n\nexport { RangesCollector };\nexport function computeRanges(model, offSide, markers, foldingRangesLimit) {\n  if (foldingRangesLimit === void 0) {\n    foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT;\n  }\n\n  var tabSize = model.getOptions().tabSize;\n  var result = new RangesCollector(foldingRangesLimit);\n  var pattern = undefined;\n\n  if (markers) {\n    pattern = new RegExp(\"(\" + markers.start.source + \")|(?:\" + markers.end.source + \")\");\n  }\n\n  var previousRegions = [];\n  var line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line: line\n  }); // sentinel, to make sure there's at least one entry\n\n  for (var line_1 = model.getLineCount(); line_1 > 0; line_1--) {\n    var lineContent = model.getLineContent(line_1);\n    var indent = TextModel.computeIndentLevel(lineContent, tabSize);\n    var previous = previousRegions[previousRegions.length - 1];\n\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = line_1;\n      }\n\n      continue; // only whitespace\n    }\n\n    var m = void 0;\n\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        var i = previousRegions.length - 1;\n\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i]; // new folding range from pattern, includes the end line\n\n          result.insertFirst(line_1, previous.line, indent);\n          previous.line = line_1;\n          previous.indent = indent;\n          previous.endAbove = line_1;\n          continue;\n        } else {// no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: line_1,\n          line: line_1\n        });\n        continue;\n      }\n    }\n\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent); // new folding range\n\n\n      var endLineNumber = previous.endAbove - 1;\n\n      if (endLineNumber - line_1 >= 1) {\n        // needs at east size 1\n        result.insertFirst(line_1, endLineNumber, indent);\n      }\n    }\n\n    if (previous.indent === indent) {\n      previous.endAbove = line_1;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent: indent,\n        endAbove: line_1,\n        line: line_1\n      });\n    }\n  }\n\n  return result.toIndentRanges(model);\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js"],"names":["FoldingRegions","MAX_LINE_NUMBER","TextModel","LanguageConfigurationRegistry","MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT","ID_INDENT_PROVIDER","IndentRangeProvider","editorModel","id","prototype","dispose","compute","cancelationToken","foldingRules","getFoldingRules","getLanguageIdentifier","offSide","markers","Promise","resolve","computeRanges","RangesCollector","foldingRangesLimit","_startIndexes","_endIndexes","_indentOccurrences","_length","_foldingRangesLimit","insertFirst","startLineNumber","endLineNumber","indent","index","toIndentRanges","model","startIndexes","Uint32Array","endIndexes","i","k","entries","maxIndent","length","n","tabSize","getOptions","startIndex","lineContent","getLineContent","computeIndentLevel","result","pattern","undefined","RegExp","start","source","end","previousRegions","line","getLineCount","push","endAbove","line_1","previous","m","match","pop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\r\nimport { TextModel } from '../../common/model/textModel.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nvar MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\r\nexport var ID_INDENT_PROVIDER = 'indent';\r\nvar IndentRangeProvider = /** @class */ (function () {\r\n    function IndentRangeProvider(editorModel) {\r\n        this.editorModel = editorModel;\r\n        this.id = ID_INDENT_PROVIDER;\r\n    }\r\n    IndentRangeProvider.prototype.dispose = function () {\r\n    };\r\n    IndentRangeProvider.prototype.compute = function (cancelationToken) {\r\n        var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\r\n        var offSide = foldingRules && !!foldingRules.offSide;\r\n        var markers = foldingRules && foldingRules.markers;\r\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\r\n    };\r\n    return IndentRangeProvider;\r\n}());\r\nexport { IndentRangeProvider };\r\n// public only for testing\r\nvar RangesCollector = /** @class */ (function () {\r\n    function RangesCollector(foldingRangesLimit) {\r\n        this._startIndexes = [];\r\n        this._endIndexes = [];\r\n        this._indentOccurrences = [];\r\n        this._length = 0;\r\n        this._foldingRangesLimit = foldingRangesLimit;\r\n    }\r\n    RangesCollector.prototype.insertFirst = function (startLineNumber, endLineNumber, indent) {\r\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\r\n            return;\r\n        }\r\n        var index = this._length;\r\n        this._startIndexes[index] = startLineNumber;\r\n        this._endIndexes[index] = endLineNumber;\r\n        this._length++;\r\n        if (indent < 1000) {\r\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\r\n        }\r\n    };\r\n    RangesCollector.prototype.toIndentRanges = function (model) {\r\n        if (this._length <= this._foldingRangesLimit) {\r\n            // reverse and create arrays of the exact length\r\n            var startIndexes = new Uint32Array(this._length);\r\n            var endIndexes = new Uint32Array(this._length);\r\n            for (var i = this._length - 1, k = 0; i >= 0; i--, k++) {\r\n                startIndexes[k] = this._startIndexes[i];\r\n                endIndexes[k] = this._endIndexes[i];\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes);\r\n        }\r\n        else {\r\n            var entries = 0;\r\n            var maxIndent = this._indentOccurrences.length;\r\n            for (var i = 0; i < this._indentOccurrences.length; i++) {\r\n                var n = this._indentOccurrences[i];\r\n                if (n) {\r\n                    if (n + entries > this._foldingRangesLimit) {\r\n                        maxIndent = i;\r\n                        break;\r\n                    }\r\n                    entries += n;\r\n                }\r\n            }\r\n            var tabSize = model.getOptions().tabSize;\r\n            // reverse and create arrays of the exact length\r\n            var startIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            var endIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            for (var i = this._length - 1, k = 0; i >= 0; i--) {\r\n                var startIndex = this._startIndexes[i];\r\n                var lineContent = model.getLineContent(startIndex);\r\n                var indent = TextModel.computeIndentLevel(lineContent, tabSize);\r\n                if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\r\n                    startIndexes[k] = startIndex;\r\n                    endIndexes[k] = this._endIndexes[i];\r\n                    k++;\r\n                }\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes);\r\n        }\r\n    };\r\n    return RangesCollector;\r\n}());\r\nexport { RangesCollector };\r\nexport function computeRanges(model, offSide, markers, foldingRangesLimit) {\r\n    if (foldingRangesLimit === void 0) { foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT; }\r\n    var tabSize = model.getOptions().tabSize;\r\n    var result = new RangesCollector(foldingRangesLimit);\r\n    var pattern = undefined;\r\n    if (markers) {\r\n        pattern = new RegExp(\"(\" + markers.start.source + \")|(?:\" + markers.end.source + \")\");\r\n    }\r\n    var previousRegions = [];\r\n    var line = model.getLineCount() + 1;\r\n    previousRegions.push({ indent: -1, endAbove: line, line: line }); // sentinel, to make sure there's at least one entry\r\n    for (var line_1 = model.getLineCount(); line_1 > 0; line_1--) {\r\n        var lineContent = model.getLineContent(line_1);\r\n        var indent = TextModel.computeIndentLevel(lineContent, tabSize);\r\n        var previous = previousRegions[previousRegions.length - 1];\r\n        if (indent === -1) {\r\n            if (offSide) {\r\n                // for offSide languages, empty lines are associated to the previous block\r\n                // note: the next block is already written to the results, so this only\r\n                // impacts the end position of the block before\r\n                previous.endAbove = line_1;\r\n            }\r\n            continue; // only whitespace\r\n        }\r\n        var m = void 0;\r\n        if (pattern && (m = lineContent.match(pattern))) {\r\n            // folding pattern match\r\n            if (m[1]) { // start pattern match\r\n                // discard all regions until the folding pattern\r\n                var i = previousRegions.length - 1;\r\n                while (i > 0 && previousRegions[i].indent !== -2) {\r\n                    i--;\r\n                }\r\n                if (i > 0) {\r\n                    previousRegions.length = i + 1;\r\n                    previous = previousRegions[i];\r\n                    // new folding range from pattern, includes the end line\r\n                    result.insertFirst(line_1, previous.line, indent);\r\n                    previous.line = line_1;\r\n                    previous.indent = indent;\r\n                    previous.endAbove = line_1;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // no end marker found, treat line as a regular line\r\n                }\r\n            }\r\n            else { // end pattern match\r\n                previousRegions.push({ indent: -2, endAbove: line_1, line: line_1 });\r\n                continue;\r\n            }\r\n        }\r\n        if (previous.indent > indent) {\r\n            // discard all regions with larger indent\r\n            do {\r\n                previousRegions.pop();\r\n                previous = previousRegions[previousRegions.length - 1];\r\n            } while (previous.indent > indent);\r\n            // new folding range\r\n            var endLineNumber = previous.endAbove - 1;\r\n            if (endLineNumber - line_1 >= 1) { // needs at east size 1\r\n                result.insertFirst(line_1, endLineNumber, indent);\r\n            }\r\n        }\r\n        if (previous.indent === indent) {\r\n            previous.endAbove = line_1;\r\n        }\r\n        else { // previous.indent < indent\r\n            // new region with a bigger indent\r\n            previousRegions.push({ indent: indent, endAbove: line_1, line: line_1 });\r\n        }\r\n    }\r\n    return result.toIndentRanges(model);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}