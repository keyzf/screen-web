{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\n\nvar LineCommentCommand =\n/** @class */\nfunction () {\n  function LineCommentCommand(selection, tabSize, type, insertSpace) {\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n  }\n  /**\r\n   * Do an initial pass over the lines and gather info about the line comment string.\r\n   * Returns null if any of the lines doesn't support a line comment string.\r\n   */\n\n\n  LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\n    model.tokenizeIfCheap(startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n    var commentStr = config ? config.lineCommentToken : null;\n\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n\n    var lines = [];\n\n    for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n\n    return lines;\n  };\n  /**\r\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n   */\n\n\n  LineCommentCommand._analyzeLines = function (type, insertSpace, model, lines, startLineNumber) {\n    var onlyWhitespaceLines = true;\n    var shouldRemoveComments;\n\n    if (type === 0\n    /* Toggle */\n    ) {\n        shouldRemoveComments = true;\n      } else if (type === 1\n    /* ForceAdd */\n    ) {\n        shouldRemoveComments = false;\n      } else {\n      shouldRemoveComments = true;\n    }\n\n    for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n      var lineData = lines[i];\n      var lineNumber = startLineNumber + i;\n      var lineContent = model.getLineContent(lineNumber);\n      var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        if (type === 0\n        /* Toggle */\n        ) {\n            lineData.ignore = true;\n          } else if (type === 1\n        /* ForceAdd */\n        ) {\n            lineData.ignore = true;\n          } else {\n          lineData.ignore = true;\n        }\n\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0\n        /* Toggle */\n        ) {\n            // Every line so far has been a line comment, but this one is not\n            shouldRemoveComments = false;\n          } else if (type === 1\n        /* ForceAdd */\n        ) {// Will not happen\n          } else {\n          lineData.ignore = true;\n        }\n      }\n\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32\n        /* Space */\n        ) {\n            lineData.commentStrLength += 1;\n          }\n      }\n    }\n\n    if (type === 0\n    /* Toggle */\n    && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false; // Also, no longer ignore them\n\n      for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  };\n  /**\r\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n   */\n\n\n  LineCommentCommand._gatherPreflightData = function (type, insertSpace, model, startLineNumber, endLineNumber) {\n    var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber);\n  };\n  /**\r\n   * Given a successful analysis, execute either insert line comments, either remove line comments\r\n   */\n\n\n  LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\n    var ops;\n\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n\n    var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n    for (var i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n\n      if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n        var lineContent = model.getLineContent(cursorPosition.lineNumber);\n\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  };\n\n  LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\n    var startLineNumber = s.startLineNumber;\n    var endLineNumber = s.endLineNumber;\n    var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    } // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n\n\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32\n    /* Space */\n    ) {\n        startToken += ' ';\n      } // For Space before endToken, add Space before endToken and shift index one left.\n\n\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32\n    /* Space */\n    ) {\n        endToken = ' ' + endToken;\n        endTokenIndex -= 1;\n      }\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n\n    return null;\n  };\n  /**\r\n   * Given an unsuccessful analysis, delegate to the block comment command\r\n   */\n\n\n  LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    var startToken = config.blockCommentStartToken;\n    var endToken = config.blockCommentEndToken;\n\n    var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\n    if (!ops) {\n      if (s.isEmpty()) {\n        var lineContent = model.getLineContent(s.startLineNumber);\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n\n    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n      var op = ops_1[_i];\n      builder.addEditOperation(op.range, op.text);\n    }\n  };\n\n  LineCommentCommand.prototype.getEditOperations = function (model, builder) {\n    var s = this._selection;\n    this._moveEndPositionDown = false;\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    var data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber);\n\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n\n    return this._executeBlockComment(model, builder, s);\n  };\n\n  LineCommentCommand.prototype.computeCursorState = function (model, helper) {\n    var result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  };\n  /**\r\n   * Generate edit operations in the remove line comment case\r\n   */\n\n\n  LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n\n    return res;\n  };\n  /**\r\n   * Generate edit operations in the add line comment case\r\n   */\n\n\n  LineCommentCommand.prototype._createAddLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n    var afterCommentStr = this._insertSpace ? ' ' : '';\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n\n    return res;\n  };\n\n  LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n\n    return currentVisibleColumn + columnSize;\n  };\n  /**\r\n   * Adjust insertion points to have them vertically aligned in the add line comment case\r\n   */\n\n\n  LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\n    var minVisibleColumn = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    var j;\n    var lenJ;\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n\n      for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  };\n\n  return LineCommentCommand;\n}();\n\nexport { LineCommentCommand };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js"],"names":["strings","EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","LineCommentCommand","selection","tabSize","type","insertSpace","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getComments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","prototype","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","_i","ops_1","op","getEditOperations","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","j_1","lenJ_1","floor"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nimport { BlockCommentCommand } from './blockCommentCommand.js';\r\nvar LineCommentCommand = /** @class */ (function () {\r\n    function LineCommentCommand(selection, tabSize, type, insertSpace) {\r\n        this._selection = selection;\r\n        this._tabSize = tabSize;\r\n        this._type = type;\r\n        this._insertSpace = insertSpace;\r\n        this._selectionId = null;\r\n        this._deltaColumn = 0;\r\n        this._moveEndPositionDown = false;\r\n    }\r\n    /**\r\n     * Do an initial pass over the lines and gather info about the line comment string.\r\n     * Returns null if any of the lines doesn't support a line comment string.\r\n     */\r\n    LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\r\n        model.tokenizeIfCheap(startLineNumber);\r\n        var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\r\n        var config = LanguageConfigurationRegistry.getComments(languageId);\r\n        var commentStr = (config ? config.lineCommentToken : null);\r\n        if (!commentStr) {\r\n            // Mode does not support line comments\r\n            return null;\r\n        }\r\n        var lines = [];\r\n        for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\r\n            lines[i] = {\r\n                ignore: false,\r\n                commentStr: commentStr,\r\n                commentStrOffset: 0,\r\n                commentStrLength: commentStr.length\r\n            };\r\n        }\r\n        return lines;\r\n    };\r\n    /**\r\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n     */\r\n    LineCommentCommand._analyzeLines = function (type, insertSpace, model, lines, startLineNumber) {\r\n        var onlyWhitespaceLines = true;\r\n        var shouldRemoveComments;\r\n        if (type === 0 /* Toggle */) {\r\n            shouldRemoveComments = true;\r\n        }\r\n        else if (type === 1 /* ForceAdd */) {\r\n            shouldRemoveComments = false;\r\n        }\r\n        else {\r\n            shouldRemoveComments = true;\r\n        }\r\n        for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n            var lineData = lines[i];\r\n            var lineNumber = startLineNumber + i;\r\n            var lineContent = model.getLineContent(lineNumber);\r\n            var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (lineContentStartOffset === -1) {\r\n                // Empty or whitespace only line\r\n                if (type === 0 /* Toggle */) {\r\n                    lineData.ignore = true;\r\n                }\r\n                else if (type === 1 /* ForceAdd */) {\r\n                    lineData.ignore = true;\r\n                }\r\n                else {\r\n                    lineData.ignore = true;\r\n                }\r\n                lineData.commentStrOffset = lineContent.length;\r\n                continue;\r\n            }\r\n            onlyWhitespaceLines = false;\r\n            lineData.ignore = false;\r\n            lineData.commentStrOffset = lineContentStartOffset;\r\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\r\n                if (type === 0 /* Toggle */) {\r\n                    // Every line so far has been a line comment, but this one is not\r\n                    shouldRemoveComments = false;\r\n                }\r\n                else if (type === 1 /* ForceAdd */) {\r\n                    // Will not happen\r\n                }\r\n                else {\r\n                    lineData.ignore = true;\r\n                }\r\n            }\r\n            if (shouldRemoveComments && insertSpace) {\r\n                // Remove a following space if present\r\n                var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\r\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\r\n                    lineData.commentStrLength += 1;\r\n                }\r\n            }\r\n        }\r\n        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\r\n            // For only whitespace lines, we insert comments\r\n            shouldRemoveComments = false;\r\n            // Also, no longer ignore them\r\n            for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n                lines[i].ignore = false;\r\n            }\r\n        }\r\n        return {\r\n            supported: true,\r\n            shouldRemoveComments: shouldRemoveComments,\r\n            lines: lines\r\n        };\r\n    };\r\n    /**\r\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n     */\r\n    LineCommentCommand._gatherPreflightData = function (type, insertSpace, model, startLineNumber, endLineNumber) {\r\n        var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\r\n        if (lines === null) {\r\n            return {\r\n                supported: false\r\n            };\r\n        }\r\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber);\r\n    };\r\n    /**\r\n     * Given a successful analysis, execute either insert line comments, either remove line comments\r\n     */\r\n    LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\r\n        var ops;\r\n        if (data.shouldRemoveComments) {\r\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        else {\r\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\r\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\r\n        for (var i = 0, len = ops.length; i < len; i++) {\r\n            builder.addEditOperation(ops[i].range, ops[i].text);\r\n            if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\r\n                var lineContent = model.getLineContent(cursorPosition.lineNumber);\r\n                if (lineContent.length + 1 === cursorPosition.column) {\r\n                    this._deltaColumn = (ops[i].text || '').length;\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n    };\r\n    LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\r\n        var startLineNumber = s.startLineNumber;\r\n        var endLineNumber = s.endLineNumber;\r\n        var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\r\n        var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\r\n        var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\r\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\r\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            endLineNumber = startLineNumber;\r\n        }\r\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\r\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\r\n            startLineNumber = endLineNumber;\r\n        }\r\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\r\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\r\n            if (startTokenIndex !== -1) {\r\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            }\r\n        }\r\n        // We have to adjust to possible inner white space.\r\n        // For Space after startToken, add Space to startToken - range math will work out.\r\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\r\n            startToken += ' ';\r\n        }\r\n        // For Space before endToken, add Space before endToken and shift index one left.\r\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\r\n            endToken = ' ' + endToken;\r\n            endTokenIndex -= 1;\r\n        }\r\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\r\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Given an unsuccessful analysis, delegate to the block comment command\r\n     */\r\n    LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\r\n        model.tokenizeIfCheap(s.startLineNumber);\r\n        var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\r\n        var config = LanguageConfigurationRegistry.getComments(languageId);\r\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\r\n            // Mode does not support block comments\r\n            return;\r\n        }\r\n        var startToken = config.blockCommentStartToken;\r\n        var endToken = config.blockCommentEndToken;\r\n        var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\r\n        if (!ops) {\r\n            if (s.isEmpty()) {\r\n                var lineContent = model.getLineContent(s.startLineNumber);\r\n                var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n                if (firstNonWhitespaceIndex === -1) {\r\n                    // Line is empty or contains only whitespace\r\n                    firstNonWhitespaceIndex = lineContent.length;\r\n                }\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\r\n            }\r\n            else {\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\r\n            }\r\n            if (ops.length === 1) {\r\n                // Leave cursor after token and Space\r\n                this._deltaColumn = startToken.length + 1;\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n        for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\r\n            var op = ops_1[_i];\r\n            builder.addEditOperation(op.range, op.text);\r\n        }\r\n    };\r\n    LineCommentCommand.prototype.getEditOperations = function (model, builder) {\r\n        var s = this._selection;\r\n        this._moveEndPositionDown = false;\r\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\r\n            this._moveEndPositionDown = true;\r\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\r\n        }\r\n        var data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber);\r\n        if (data.supported) {\r\n            return this._executeLineComments(model, builder, data, s);\r\n        }\r\n        return this._executeBlockComment(model, builder, s);\r\n    };\r\n    LineCommentCommand.prototype.computeCursorState = function (model, helper) {\r\n        var result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._moveEndPositionDown) {\r\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\r\n        }\r\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\r\n    };\r\n    /**\r\n     * Generate edit operations in the remove line comment case\r\n     */\r\n    LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\r\n        var res = [];\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            var lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Generate edit operations in the add line comment case\r\n     */\r\n    LineCommentCommand.prototype._createAddLineCommentsOperations = function (lines, startLineNumber) {\r\n        var res = [];\r\n        var afterCommentStr = this._insertSpace ? ' ' : '';\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            var lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\r\n        }\r\n        return res;\r\n    };\r\n    LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\r\n        if (isTab) {\r\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\r\n        }\r\n        return currentVisibleColumn + columnSize;\r\n    };\r\n    /**\r\n     * Adjust insertion points to have them vertically aligned in the add line comment case\r\n     */\r\n    LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\r\n        var minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        var j;\r\n        var lenJ;\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            var lineContent = model.getLineContent(startLineNumber + i);\r\n            var currentVisibleColumn = 0;\r\n            for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn < minVisibleColumn) {\r\n                minVisibleColumn = currentVisibleColumn;\r\n            }\r\n        }\r\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            var lineContent = model.getLineContent(startLineNumber + i);\r\n            var currentVisibleColumn = 0;\r\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn > minVisibleColumn) {\r\n                lines[i].commentStrOffset = j - 1;\r\n            }\r\n            else {\r\n                lines[i].commentStrOffset = j;\r\n            }\r\n        }\r\n    };\r\n    return LineCommentCommand;\r\n}());\r\nexport { LineCommentCommand };\r\n"]},"metadata":{},"sourceType":"module"}