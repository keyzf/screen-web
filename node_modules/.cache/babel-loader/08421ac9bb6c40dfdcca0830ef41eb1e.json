{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nvar GLOBSTAR = '**';\nvar GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\n\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\n\nvar ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n\n    case 1:\n      return NO_PATH_REGEX + \"*?\";\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\n  }\n}\n\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n\n  var segments = [];\n  var inBraces = false;\n  var inBrackets = false;\n  var curVal = '';\n\n  for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n    var char = pattern_1[_i];\n\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n\n        break;\n\n      case '{':\n        inBraces = true;\n        break;\n\n      case '}':\n        inBraces = false;\n        break;\n\n      case '[':\n        inBrackets = true;\n        break;\n\n      case ']':\n        inBrackets = false;\n        break;\n    }\n\n    curVal += char;\n  } // Tail\n\n\n  if (curVal) {\n    segments.push(curVal);\n  }\n\n  return segments;\n}\n\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n\n  var regEx = ''; // Split up into segments for each slash found\n\n  var segments = splitGlobAware(pattern, GLOB_SPLIT); // Special case where we only have globstars\n\n  if (segments.every(function (s) {\n    return s === GLOBSTAR;\n  })) {\n    regEx = '.*';\n  } // Build regex over segments\n  else {\n      var previousSegmentWasGlobStar_1 = false;\n      segments.forEach(function (segment, index) {\n        // Globstar is special\n        if (segment === GLOBSTAR) {\n          // if we have more than one globstar after another, just ignore it\n          if (!previousSegmentWasGlobStar_1) {\n            regEx += starsToRegExp(2);\n            previousSegmentWasGlobStar_1 = true;\n          }\n\n          return;\n        } // States\n\n\n        var inBraces = false;\n        var braceVal = '';\n        var inBrackets = false;\n        var bracketVal = '';\n\n        for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\n          var char = segment_1[_i]; // Support brace expansion\n\n          if (char !== '}' && inBraces) {\n            braceVal += char;\n            continue;\n          } // Support brackets\n\n\n          if (inBrackets && (char !== ']' || !bracketVal)\n          /* ] is literally only allowed as first character in brackets to match it */\n          ) {\n              var res = void 0; // range operator\n\n              if (char === '-') {\n                res = char;\n              } // negation operator (only valid on first index in bracket)\n              else if ((char === '^' || char === '!') && !bracketVal) {\n                  res = '^';\n                } // glob split matching is not allowed within character ranges\n                // see http://man7.org/linux/man-pages/man7/glob.7.html\n                else if (char === GLOB_SPLIT) {\n                    res = '';\n                  } // anything else gets escaped\n                  else {\n                      res = strings.escapeRegExpCharacters(char);\n                    }\n\n              bracketVal += res;\n              continue;\n            }\n\n          switch (char) {\n            case '{':\n              inBraces = true;\n              continue;\n\n            case '[':\n              inBrackets = true;\n              continue;\n\n            case '}':\n              var choices = splitGlobAware(braceVal, ','); // Converts {foo,bar} => [foo|bar]\n\n              var braceRegExp = \"(?:\" + choices.map(function (c) {\n                return parseRegExp(c);\n              }).join('|') + \")\";\n              regEx += braceRegExp;\n              inBraces = false;\n              braceVal = '';\n              break;\n\n            case ']':\n              regEx += '[' + bracketVal + ']';\n              inBrackets = false;\n              bracketVal = '';\n              break;\n\n            case '?':\n              regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\n              continue;\n\n            case '*':\n              regEx += starsToRegExp(1);\n              continue;\n\n            default:\n              regEx += strings.escapeRegExpCharacters(char);\n          }\n        } // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n        // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n        // a folder called \"something\" to match as well.\n        // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n        // is to match 0-N segments.\n\n\n        if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n          regEx += PATH_REGEX;\n        } // reset state\n\n\n        previousSegmentWasGlobStar_1 = false;\n      });\n    }\n\n  return regEx;\n} // regexes to check for trival glob patterns that just check for String#endsWith\n\n\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\n\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\n\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\n\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\n\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\n\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\n\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\n\nvar FALSE = function () {\n  return false;\n};\n\nvar NULL = function () {\n  return null;\n};\n\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  } // Handle IRelativePattern\n\n\n  var pattern;\n\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  } // Whitespace trimming\n\n\n  pattern = pattern.trim(); // Check cache\n\n  var patternKey = pattern + \"_\" + !!options.trimForExclusions;\n  var parsedPattern = CACHE.get(patternKey);\n\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  } // Check for Trivias\n\n\n  var match;\n\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    var base_1 = pattern.substr(4); // '**/*'.length === 4\n\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } // Otherwise convert to pattern\n  else {\n      parsedPattern = toRegExp(pattern);\n    } // Cache\n\n\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\n\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n} // common pattern: **/some.txt just need basename check\n\n\nfunction trivia2(base, originalPattern) {\n  var slashBase = \"/\" + base;\n  var backslashBase = \"\\\\\" + base;\n\n  var parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n\n    return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n  };\n\n  var basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n} // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\n\nfunction trivia3(pattern, options) {\n  var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(function (pattern) {\n    return parsePattern(pattern, options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }), pattern);\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n\n  var parsedPattern = function (path, basename) {\n    for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n\n  return parsedPattern;\n} // common patterns: **/something/else just need endsWith check, something/else just needs and equals check\n\n\nfunction trivia4and5(path, pattern, matchPathEnds) {\n  var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n  var nativePathEnd = paths.sep + nativePath;\n  var parsedPattern = matchPathEnds ? function (path, basename) {\n    return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n  } : function (path, basename) {\n    return typeof path === 'string' && path === nativePath ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n  return parsedPattern;\n}\n\nfunction toRegExp(pattern) {\n  try {\n    var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\n    return function (path, basename) {\n      regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n      return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\n\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!arg1) {\n    return FALSE;\n  } // Glob with String\n\n\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    var parsedPattern_1 = parsePattern(arg1, options);\n\n    if (parsedPattern_1 === NULL) {\n      return FALSE;\n    }\n\n    var resultPattern = function (path, basename) {\n      return !!parsedPattern_1(path, basename);\n    };\n\n    if (parsedPattern_1.allBasenames) {\n      resultPattern.allBasenames = parsedPattern_1.allBasenames;\n    }\n\n    if (parsedPattern_1.allPaths) {\n      resultPattern.allPaths = parsedPattern_1.allPaths;\n    }\n\n    return resultPattern;\n  } // Glob with Expression\n\n\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  var rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nfunction parsedExpression(expression, options) {\n  var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(function (pattern) {\n    return parseExpressionPattern(pattern, expression[pattern], options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }));\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (!parsedPatterns.some(function (parsedPattern) {\n    return !!parsedPattern.requiresSiblings;\n  })) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n\n    var resultExpression_1 = function (path, basename) {\n      for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\n        // Pattern matches path\n        var result = parsedPatterns[i](path, basename);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    };\n\n    var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) {\n      return !!pattern.allBasenames;\n    });\n\n    if (withBasenames_1) {\n      resultExpression_1.allBasenames = withBasenames_1.allBasenames;\n    }\n\n    var allPaths_1 = parsedPatterns.reduce(function (all, current) {\n      return current.allPaths ? all.concat(current.allPaths) : all;\n    }, []);\n\n    if (allPaths_1.length) {\n      resultExpression_1.allPaths = allPaths_1;\n    }\n\n    return resultExpression_1;\n  }\n\n  var resultExpression = function (path, basename, hasSibling) {\n    var name = undefined;\n\n    for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\n      // Pattern matches path\n      var parsedPattern = parsedPatterns[i];\n\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n\n      var result = parsedPattern(path, basename, name, hasSibling);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n\n  return resultExpression;\n}\n\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  var parsedPattern = parsePattern(pattern, options);\n\n  if (parsedPattern === NULL) {\n    return NULL;\n  } // Expression Pattern is <boolean>\n\n\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  } // Expression Pattern is <SiblingClause>\n\n\n  if (value) {\n    var when_1 = value.when;\n\n    if (typeof when_1 === 'string') {\n      var result = function (path, basename, name, hasSibling) {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n\n        var clausePattern = when_1.replace('$(basename)', name);\n        var matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(function (m) {\n          return m ? pattern : null;\n        }) : matched ? pattern : null;\n      };\n\n      result.requiresSiblings = true;\n      return result;\n    }\n  } // Expression is Anything\n\n\n  return parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  var basenamePatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !!parsedPattern.basenames;\n  });\n\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n\n  var basenames = basenamePatterns.reduce(function (all, current) {\n    var basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  var patterns;\n\n  if (result) {\n    patterns = [];\n\n    for (var i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce(function (all, current) {\n      var patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n\n  var aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (!basename) {\n      var i = void 0;\n\n      for (i = path.length; i > 0; i--) {\n        var ch = path.charCodeAt(i - 1);\n\n        if (ch === 47\n        /* Slash */\n        || ch === 92\n        /* Backslash */\n        ) {\n            break;\n          }\n      }\n\n      basename = path.substr(i);\n    }\n\n    var index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !parsedPattern.basenames;\n  });\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"names":["arrays","strings","extpath","paths","LRUCache","isThenable","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","_i","pattern_1","length","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar_1","forEach","segment","index","braceVal","bracketVal","segment_1","res","escapeRegExpCharacters","choices","braceRegExp","map","c","join","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base_1","substr","path","basename","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","isEqualOrParent","base","relative","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","n_1","withBasenames","first","allPaths","reduce","all","current","concat","matchPathEnds","nativePath","sep","posix","replace","nativePathEnd","regExp_1","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","parsedPattern_1","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression_1","n_2","result","withBasenames_1","allPaths_1","resultExpression","name","n_3","extname","value","when_1","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from './arrays.js';\r\nimport * as strings from './strings.js';\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { LRUCache } from './map.js';\r\nimport { isThenable } from './async.js';\r\nvar GLOBSTAR = '**';\r\nvar GLOB_SPLIT = '/';\r\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\r\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\r\nvar ALL_FORWARD_SLASHES = /\\//g;\r\nfunction starsToRegExp(starCount) {\r\n    switch (starCount) {\r\n        case 0:\r\n            return '';\r\n        case 1:\r\n            return NO_PATH_REGEX + \"*?\"; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\r\n        default:\r\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\r\n            // Group is non capturing because we don't need to capture at all (?:...)\r\n            // Overall we use non-greedy matching because it could be that we match too much\r\n            return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\r\n    }\r\n}\r\nexport function splitGlobAware(pattern, splitChar) {\r\n    if (!pattern) {\r\n        return [];\r\n    }\r\n    var segments = [];\r\n    var inBraces = false;\r\n    var inBrackets = false;\r\n    var curVal = '';\r\n    for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\r\n        var char = pattern_1[_i];\r\n        switch (char) {\r\n            case splitChar:\r\n                if (!inBraces && !inBrackets) {\r\n                    segments.push(curVal);\r\n                    curVal = '';\r\n                    continue;\r\n                }\r\n                break;\r\n            case '{':\r\n                inBraces = true;\r\n                break;\r\n            case '}':\r\n                inBraces = false;\r\n                break;\r\n            case '[':\r\n                inBrackets = true;\r\n                break;\r\n            case ']':\r\n                inBrackets = false;\r\n                break;\r\n        }\r\n        curVal += char;\r\n    }\r\n    // Tail\r\n    if (curVal) {\r\n        segments.push(curVal);\r\n    }\r\n    return segments;\r\n}\r\nfunction parseRegExp(pattern) {\r\n    if (!pattern) {\r\n        return '';\r\n    }\r\n    var regEx = '';\r\n    // Split up into segments for each slash found\r\n    var segments = splitGlobAware(pattern, GLOB_SPLIT);\r\n    // Special case where we only have globstars\r\n    if (segments.every(function (s) { return s === GLOBSTAR; })) {\r\n        regEx = '.*';\r\n    }\r\n    // Build regex over segments\r\n    else {\r\n        var previousSegmentWasGlobStar_1 = false;\r\n        segments.forEach(function (segment, index) {\r\n            // Globstar is special\r\n            if (segment === GLOBSTAR) {\r\n                // if we have more than one globstar after another, just ignore it\r\n                if (!previousSegmentWasGlobStar_1) {\r\n                    regEx += starsToRegExp(2);\r\n                    previousSegmentWasGlobStar_1 = true;\r\n                }\r\n                return;\r\n            }\r\n            // States\r\n            var inBraces = false;\r\n            var braceVal = '';\r\n            var inBrackets = false;\r\n            var bracketVal = '';\r\n            for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\r\n                var char = segment_1[_i];\r\n                // Support brace expansion\r\n                if (char !== '}' && inBraces) {\r\n                    braceVal += char;\r\n                    continue;\r\n                }\r\n                // Support brackets\r\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\r\n                    var res = void 0;\r\n                    // range operator\r\n                    if (char === '-') {\r\n                        res = char;\r\n                    }\r\n                    // negation operator (only valid on first index in bracket)\r\n                    else if ((char === '^' || char === '!') && !bracketVal) {\r\n                        res = '^';\r\n                    }\r\n                    // glob split matching is not allowed within character ranges\r\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\r\n                    else if (char === GLOB_SPLIT) {\r\n                        res = '';\r\n                    }\r\n                    // anything else gets escaped\r\n                    else {\r\n                        res = strings.escapeRegExpCharacters(char);\r\n                    }\r\n                    bracketVal += res;\r\n                    continue;\r\n                }\r\n                switch (char) {\r\n                    case '{':\r\n                        inBraces = true;\r\n                        continue;\r\n                    case '[':\r\n                        inBrackets = true;\r\n                        continue;\r\n                    case '}':\r\n                        var choices = splitGlobAware(braceVal, ',');\r\n                        // Converts {foo,bar} => [foo|bar]\r\n                        var braceRegExp = \"(?:\" + choices.map(function (c) { return parseRegExp(c); }).join('|') + \")\";\r\n                        regEx += braceRegExp;\r\n                        inBraces = false;\r\n                        braceVal = '';\r\n                        break;\r\n                    case ']':\r\n                        regEx += ('[' + bracketVal + ']');\r\n                        inBrackets = false;\r\n                        bracketVal = '';\r\n                        break;\r\n                    case '?':\r\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\r\n                        continue;\r\n                    case '*':\r\n                        regEx += starsToRegExp(1);\r\n                        continue;\r\n                    default:\r\n                        regEx += strings.escapeRegExpCharacters(char);\r\n                }\r\n            }\r\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\r\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\r\n            // a folder called \"something\" to match as well.\r\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\r\n            // is to match 0-N segments.\r\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\r\n                regEx += PATH_REGEX;\r\n            }\r\n            // reset state\r\n            previousSegmentWasGlobStar_1 = false;\r\n        });\r\n    }\r\n    return regEx;\r\n}\r\n// regexes to check for trival glob patterns that just check for String#endsWith\r\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\r\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\r\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\r\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\r\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\r\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\r\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\r\nvar FALSE = function () {\r\n    return false;\r\n};\r\nvar NULL = function () {\r\n    return null;\r\n};\r\nfunction parsePattern(arg1, options) {\r\n    if (!arg1) {\r\n        return NULL;\r\n    }\r\n    // Handle IRelativePattern\r\n    var pattern;\r\n    if (typeof arg1 !== 'string') {\r\n        pattern = arg1.pattern;\r\n    }\r\n    else {\r\n        pattern = arg1;\r\n    }\r\n    // Whitespace trimming\r\n    pattern = pattern.trim();\r\n    // Check cache\r\n    var patternKey = pattern + \"_\" + !!options.trimForExclusions;\r\n    var parsedPattern = CACHE.get(patternKey);\r\n    if (parsedPattern) {\r\n        return wrapRelativePattern(parsedPattern, arg1);\r\n    }\r\n    // Check for Trivias\r\n    var match;\r\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\r\n        var base_1 = pattern.substr(4); // '**/*'.length === 4\r\n        parsedPattern = function (path, basename) {\r\n            return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\r\n        };\r\n    }\r\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\r\n        parsedPattern = trivia2(match[1], pattern);\r\n    }\r\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\r\n        parsedPattern = trivia3(pattern, options);\r\n    }\r\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\r\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\r\n    }\r\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\r\n        parsedPattern = trivia4and5(match[1], pattern, false);\r\n    }\r\n    // Otherwise convert to pattern\r\n    else {\r\n        parsedPattern = toRegExp(pattern);\r\n    }\r\n    // Cache\r\n    CACHE.set(patternKey, parsedPattern);\r\n    return wrapRelativePattern(parsedPattern, arg1);\r\n}\r\nfunction wrapRelativePattern(parsedPattern, arg2) {\r\n    if (typeof arg2 === 'string') {\r\n        return parsedPattern;\r\n    }\r\n    return function (path, basename) {\r\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\r\n            return null;\r\n        }\r\n        return parsedPattern(paths.relative(arg2.base, path), basename);\r\n    };\r\n}\r\nfunction trimForExclusions(pattern, options) {\r\n    return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\r\n}\r\n// common pattern: **/some.txt just need basename check\r\nfunction trivia2(base, originalPattern) {\r\n    var slashBase = \"/\" + base;\r\n    var backslashBase = \"\\\\\" + base;\r\n    var parsedPattern = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (basename) {\r\n            return basename === base ? originalPattern : null;\r\n        }\r\n        return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\r\n    };\r\n    var basenames = [base];\r\n    parsedPattern.basenames = basenames;\r\n    parsedPattern.patterns = [originalPattern];\r\n    parsedPattern.allBasenames = basenames;\r\n    return parsedPattern;\r\n}\r\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\r\nfunction trivia3(pattern, options) {\r\n    var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\r\n        .map(function (pattern) { return parsePattern(pattern, options); })\r\n        .filter(function (pattern) { return pattern !== NULL; }), pattern);\r\n    var n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (n === 1) {\r\n        return parsedPatterns[0];\r\n    }\r\n    var parsedPattern = function (path, basename) {\r\n        for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\r\n            if (parsedPatterns[i](path, basename)) {\r\n                return pattern;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n    if (withBasenames) {\r\n        parsedPattern.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n    if (allPaths.length) {\r\n        parsedPattern.allPaths = allPaths;\r\n    }\r\n    return parsedPattern;\r\n}\r\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\r\nfunction trivia4and5(path, pattern, matchPathEnds) {\r\n    var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\r\n    var nativePathEnd = paths.sep + nativePath;\r\n    var parsedPattern = matchPathEnds ? function (path, basename) {\r\n        return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\r\n    } : function (path, basename) {\r\n        return typeof path === 'string' && path === nativePath ? pattern : null;\r\n    };\r\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\r\n    return parsedPattern;\r\n}\r\nfunction toRegExp(pattern) {\r\n    try {\r\n        var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\r\n        return function (path, basename) {\r\n            regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\r\n            return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\r\n        };\r\n    }\r\n    catch (error) {\r\n        return NULL;\r\n    }\r\n}\r\nexport function match(arg1, path, hasSibling) {\r\n    if (!arg1 || typeof path !== 'string') {\r\n        return false;\r\n    }\r\n    return parse(arg1)(path, undefined, hasSibling);\r\n}\r\nexport function parse(arg1, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (!arg1) {\r\n        return FALSE;\r\n    }\r\n    // Glob with String\r\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\r\n        var parsedPattern_1 = parsePattern(arg1, options);\r\n        if (parsedPattern_1 === NULL) {\r\n            return FALSE;\r\n        }\r\n        var resultPattern = function (path, basename) {\r\n            return !!parsedPattern_1(path, basename);\r\n        };\r\n        if (parsedPattern_1.allBasenames) {\r\n            resultPattern.allBasenames = parsedPattern_1.allBasenames;\r\n        }\r\n        if (parsedPattern_1.allPaths) {\r\n            resultPattern.allPaths = parsedPattern_1.allPaths;\r\n        }\r\n        return resultPattern;\r\n    }\r\n    // Glob with Expression\r\n    return parsedExpression(arg1, options);\r\n}\r\nexport function isRelativePattern(obj) {\r\n    var rp = obj;\r\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\r\n}\r\nfunction parsedExpression(expression, options) {\r\n    var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\r\n        .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })\r\n        .filter(function (pattern) { return pattern !== NULL; }));\r\n    var n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (!parsedPatterns.some(function (parsedPattern) { return !!parsedPattern.requiresSiblings; })) {\r\n        if (n === 1) {\r\n            return parsedPatterns[0];\r\n        }\r\n        var resultExpression_1 = function (path, basename) {\r\n            for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\r\n                // Pattern matches path\r\n                var result = parsedPatterns[i](path, basename);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n        if (withBasenames_1) {\r\n            resultExpression_1.allBasenames = withBasenames_1.allBasenames;\r\n        }\r\n        var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n        if (allPaths_1.length) {\r\n            resultExpression_1.allPaths = allPaths_1;\r\n        }\r\n        return resultExpression_1;\r\n    }\r\n    var resultExpression = function (path, basename, hasSibling) {\r\n        var name = undefined;\r\n        for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\r\n            // Pattern matches path\r\n            var parsedPattern = parsedPatterns[i];\r\n            if (parsedPattern.requiresSiblings && hasSibling) {\r\n                if (!basename) {\r\n                    basename = paths.basename(path);\r\n                }\r\n                if (!name) {\r\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\r\n                }\r\n            }\r\n            var result = parsedPattern(path, basename, name, hasSibling);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n    if (withBasenames) {\r\n        resultExpression.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n    if (allPaths.length) {\r\n        resultExpression.allPaths = allPaths;\r\n    }\r\n    return resultExpression;\r\n}\r\nfunction parseExpressionPattern(pattern, value, options) {\r\n    if (value === false) {\r\n        return NULL; // pattern is disabled\r\n    }\r\n    var parsedPattern = parsePattern(pattern, options);\r\n    if (parsedPattern === NULL) {\r\n        return NULL;\r\n    }\r\n    // Expression Pattern is <boolean>\r\n    if (typeof value === 'boolean') {\r\n        return parsedPattern;\r\n    }\r\n    // Expression Pattern is <SiblingClause>\r\n    if (value) {\r\n        var when_1 = value.when;\r\n        if (typeof when_1 === 'string') {\r\n            var result = function (path, basename, name, hasSibling) {\r\n                if (!hasSibling || !parsedPattern(path, basename)) {\r\n                    return null;\r\n                }\r\n                var clausePattern = when_1.replace('$(basename)', name);\r\n                var matched = hasSibling(clausePattern);\r\n                return isThenable(matched) ?\r\n                    matched.then(function (m) { return m ? pattern : null; }) :\r\n                    matched ? pattern : null;\r\n            };\r\n            result.requiresSiblings = true;\r\n            return result;\r\n        }\r\n    }\r\n    // Expression is Anything\r\n    return parsedPattern;\r\n}\r\nfunction aggregateBasenameMatches(parsedPatterns, result) {\r\n    var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });\r\n    if (basenamePatterns.length < 2) {\r\n        return parsedPatterns;\r\n    }\r\n    var basenames = basenamePatterns.reduce(function (all, current) {\r\n        var basenames = current.basenames;\r\n        return basenames ? all.concat(basenames) : all;\r\n    }, []);\r\n    var patterns;\r\n    if (result) {\r\n        patterns = [];\r\n        for (var i = 0, n = basenames.length; i < n; i++) {\r\n            patterns.push(result);\r\n        }\r\n    }\r\n    else {\r\n        patterns = basenamePatterns.reduce(function (all, current) {\r\n            var patterns = current.patterns;\r\n            return patterns ? all.concat(patterns) : all;\r\n        }, []);\r\n    }\r\n    var aggregate = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (!basename) {\r\n            var i = void 0;\r\n            for (i = path.length; i > 0; i--) {\r\n                var ch = path.charCodeAt(i - 1);\r\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\r\n                    break;\r\n                }\r\n            }\r\n            basename = path.substr(i);\r\n        }\r\n        var index = basenames.indexOf(basename);\r\n        return index !== -1 ? patterns[index] : null;\r\n    };\r\n    aggregate.basenames = basenames;\r\n    aggregate.patterns = patterns;\r\n    aggregate.allBasenames = basenames;\r\n    var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });\r\n    aggregatedPatterns.push(aggregate);\r\n    return aggregatedPatterns;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}