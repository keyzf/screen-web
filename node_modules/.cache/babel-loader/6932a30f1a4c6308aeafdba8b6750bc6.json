{"ast":null,"code":"/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\nvar TRACK_DISPOSABLES = false;\nvar __is_disposable_tracked__ = '__is_disposable_tracked__';\n\nfunction markTracked(x) {\n  if (!TRACK_DISPOSABLES) {\n    return;\n  }\n\n  if (x && x !== Disposable.None) {\n    try {\n      x[__is_disposable_tracked__] = true;\n    } catch (_a) {// noop\n    }\n  }\n}\n\nfunction trackDisposable(x) {\n  if (!TRACK_DISPOSABLES) {\n    return x;\n  }\n\n  var stack = new Error('Potentially leaked disposable').stack;\n  setTimeout(function () {\n    if (!x[__is_disposable_tracked__]) {\n      console.log(stack);\n    }\n  }, 3000);\n  return x;\n}\n\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(disposables) {\n  if (Array.isArray(disposables)) {\n    disposables.forEach(function (d) {\n      if (d) {\n        markTracked(d);\n        d.dispose();\n      }\n    });\n    return [];\n  } else if (disposables) {\n    markTracked(disposables);\n    disposables.dispose();\n    return disposables;\n  } else {\n    return undefined;\n  }\n}\nexport function combinedDisposable() {\n  var disposables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    disposables[_i] = arguments[_i];\n  }\n\n  disposables.forEach(markTracked);\n  return trackDisposable({\n    dispose: function () {\n      return dispose(disposables);\n    }\n  });\n}\nexport function toDisposable(fn) {\n  var self = trackDisposable({\n    dispose: function () {\n      markTracked(self);\n      fn();\n    }\n  });\n  return self;\n}\n\nvar DisposableStore =\n/** @class */\nfunction () {\n  function DisposableStore() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n  }\n  /**\r\n   * Dispose of all registered disposables and mark this object as disposed.\r\n   *\r\n   * Any future disposables added to this object will be disposed of on `add`.\r\n   */\n\n\n  DisposableStore.prototype.dispose = function () {\n    if (this._isDisposed) {\n      return;\n    }\n\n    markTracked(this);\n    this._isDisposed = true;\n    this.clear();\n  };\n  /**\r\n   * Dispose of all registered disposables but do not mark this object as disposed.\r\n   */\n\n\n  DisposableStore.prototype.clear = function () {\n    this._toDispose.forEach(function (item) {\n      return item.dispose();\n    });\n\n    this._toDispose.clear();\n  };\n\n  DisposableStore.prototype.add = function (t) {\n    if (!t) {\n      return t;\n    }\n\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    markTracked(t);\n\n    if (this._isDisposed) {\n      console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n    } else {\n      this._toDispose.add(t);\n    }\n\n    return t;\n  };\n\n  return DisposableStore;\n}();\n\nexport { DisposableStore };\n\nvar Disposable =\n/** @class */\nfunction () {\n  function Disposable() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n  }\n\n  Disposable.prototype.dispose = function () {\n    markTracked(this);\n\n    this._store.dispose();\n  };\n\n  Disposable.prototype._register = function (t) {\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    return this._store.add(t);\n  };\n\n  Disposable.None = Object.freeze({\n    dispose: function () {}\n  });\n  return Disposable;\n}();\n\nexport { Disposable };\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\n\nvar MutableDisposable =\n/** @class */\nfunction () {\n  function MutableDisposable() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n\n  Object.defineProperty(MutableDisposable.prototype, \"value\", {\n    get: function () {\n      return this._isDisposed ? undefined : this._value;\n    },\n    set: function (value) {\n      if (this._isDisposed || value === this._value) {\n        return;\n      }\n\n      if (this._value) {\n        this._value.dispose();\n      }\n\n      if (value) {\n        markTracked(value);\n      }\n\n      this._value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MutableDisposable.prototype.clear = function () {\n    this.value = undefined;\n  };\n\n  MutableDisposable.prototype.dispose = function () {\n    this._isDisposed = true;\n    markTracked(this);\n\n    if (this._value) {\n      this._value.dispose();\n    }\n\n    this._value = undefined;\n  };\n\n  return MutableDisposable;\n}();\n\nexport { MutableDisposable };\n\nvar ImmortalReference =\n/** @class */\nfunction () {\n  function ImmortalReference(object) {\n    this.object = object;\n  }\n\n  ImmortalReference.prototype.dispose = function () {};\n\n  return ImmortalReference;\n}();\n\nexport { ImmortalReference };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"names":["TRACK_DISPOSABLES","__is_disposable_tracked__","markTracked","x","Disposable","None","_a","trackDisposable","stack","Error","setTimeout","console","log","isDisposable","thing","dispose","length","disposables","Array","isArray","forEach","d","undefined","combinedDisposable","_i","arguments","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","prototype","clear","item","add","t","warn","_store","_register","Object","freeze","MutableDisposable","defineProperty","get","_value","set","value","enumerable","configurable","ImmortalReference","object"],"mappings":"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","sourcesContent":["/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nvar TRACK_DISPOSABLES = false;\r\nvar __is_disposable_tracked__ = '__is_disposable_tracked__';\r\nfunction markTracked(x) {\r\n    if (!TRACK_DISPOSABLES) {\r\n        return;\r\n    }\r\n    if (x && x !== Disposable.None) {\r\n        try {\r\n            x[__is_disposable_tracked__] = true;\r\n        }\r\n        catch (_a) {\r\n            // noop\r\n        }\r\n    }\r\n}\r\nfunction trackDisposable(x) {\r\n    if (!TRACK_DISPOSABLES) {\r\n        return x;\r\n    }\r\n    var stack = new Error('Potentially leaked disposable').stack;\r\n    setTimeout(function () {\r\n        if (!x[__is_disposable_tracked__]) {\r\n            console.log(stack);\r\n        }\r\n    }, 3000);\r\n    return x;\r\n}\r\nexport function isDisposable(thing) {\r\n    return typeof thing.dispose === 'function'\r\n        && thing.dispose.length === 0;\r\n}\r\nexport function dispose(disposables) {\r\n    if (Array.isArray(disposables)) {\r\n        disposables.forEach(function (d) {\r\n            if (d) {\r\n                markTracked(d);\r\n                d.dispose();\r\n            }\r\n        });\r\n        return [];\r\n    }\r\n    else if (disposables) {\r\n        markTracked(disposables);\r\n        disposables.dispose();\r\n        return disposables;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexport function combinedDisposable() {\r\n    var disposables = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        disposables[_i] = arguments[_i];\r\n    }\r\n    disposables.forEach(markTracked);\r\n    return trackDisposable({ dispose: function () { return dispose(disposables); } });\r\n}\r\nexport function toDisposable(fn) {\r\n    var self = trackDisposable({\r\n        dispose: function () {\r\n            markTracked(self);\r\n            fn();\r\n        }\r\n    });\r\n    return self;\r\n}\r\nvar DisposableStore = /** @class */ (function () {\r\n    function DisposableStore() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    DisposableStore.prototype.dispose = function () {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markTracked(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    };\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    DisposableStore.prototype.clear = function () {\r\n        this._toDispose.forEach(function (item) { return item.dispose(); });\r\n        this._toDispose.clear();\r\n    };\r\n    DisposableStore.prototype.add = function (t) {\r\n        if (!t) {\r\n            return t;\r\n        }\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        markTracked(t);\r\n        if (this._isDisposed) {\r\n            console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n        }\r\n        else {\r\n            this._toDispose.add(t);\r\n        }\r\n        return t;\r\n    };\r\n    return DisposableStore;\r\n}());\r\nexport { DisposableStore };\r\nvar Disposable = /** @class */ (function () {\r\n    function Disposable() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n    }\r\n    Disposable.prototype.dispose = function () {\r\n        markTracked(this);\r\n        this._store.dispose();\r\n    };\r\n    Disposable.prototype._register = function (t) {\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(t);\r\n    };\r\n    Disposable.None = Object.freeze({ dispose: function () { } });\r\n    return Disposable;\r\n}());\r\nexport { Disposable };\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nvar MutableDisposable = /** @class */ (function () {\r\n    function MutableDisposable() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    Object.defineProperty(MutableDisposable.prototype, \"value\", {\r\n        get: function () {\r\n            return this._isDisposed ? undefined : this._value;\r\n        },\r\n        set: function (value) {\r\n            if (this._isDisposed || value === this._value) {\r\n                return;\r\n            }\r\n            if (this._value) {\r\n                this._value.dispose();\r\n            }\r\n            if (value) {\r\n                markTracked(value);\r\n            }\r\n            this._value = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MutableDisposable.prototype.clear = function () {\r\n        this.value = undefined;\r\n    };\r\n    MutableDisposable.prototype.dispose = function () {\r\n        this._isDisposed = true;\r\n        markTracked(this);\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        this._value = undefined;\r\n    };\r\n    return MutableDisposable;\r\n}());\r\nexport { MutableDisposable };\r\nvar ImmortalReference = /** @class */ (function () {\r\n    function ImmortalReference(object) {\r\n        this.object = object;\r\n    }\r\n    ImmortalReference.prototype.dispose = function () { };\r\n    return ImmortalReference;\r\n}());\r\nexport { ImmortalReference };\r\n"]},"metadata":{},"sourceType":"module"}