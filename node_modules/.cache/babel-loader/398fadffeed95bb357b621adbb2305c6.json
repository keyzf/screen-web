{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner.js';\nexport function format(documentText, range, options) {\n  var initialIndentLevel;\n  var formatText;\n  var formatTextStart;\n  var rangeStart;\n  var rangeEnd;\n\n  if (range) {\n    rangeStart = range.offset;\n    rangeEnd = rangeStart + range.length;\n    formatTextStart = rangeStart;\n\n    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n      formatTextStart--;\n    }\n\n    var endOffset = rangeEnd;\n\n    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n      endOffset++;\n    }\n\n    formatText = documentText.substring(formatTextStart, endOffset);\n    initialIndentLevel = computeIndentLevel(formatText, options);\n  } else {\n    formatText = documentText;\n    initialIndentLevel = 0;\n    formatTextStart = 0;\n    rangeStart = 0;\n    rangeEnd = documentText.length;\n  }\n\n  var eol = getEOL(options, documentText);\n  var lineBreak = false;\n  var indentLevel = 0;\n  var indentValue;\n\n  if (options.insertSpaces) {\n    indentValue = repeat(' ', options.tabSize || 4);\n  } else {\n    indentValue = '\\t';\n  }\n\n  var scanner = createScanner(formatText, false);\n  var hasError = false;\n\n  function newLineAndIndent() {\n    return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n  }\n\n  function scanNext() {\n    var token = scanner.scan();\n    lineBreak = false;\n\n    while (token === 15\n    /* Trivia */\n    || token === 14\n    /* LineBreakTrivia */\n    ) {\n      lineBreak = lineBreak || token === 14\n      /* LineBreakTrivia */\n      ;\n      token = scanner.scan();\n    }\n\n    hasError = token === 16\n    /* Unknown */\n    || scanner.getTokenError() !== 0\n    /* None */\n    ;\n    return token;\n  }\n\n  var editOperations = [];\n\n  function addEdit(text, startOffset, endOffset) {\n    if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n      editOperations.push({\n        offset: startOffset,\n        length: endOffset - startOffset,\n        content: text\n      });\n    }\n  }\n\n  var firstToken = scanNext();\n\n  if (firstToken !== 17\n  /* EOF */\n  ) {\n      var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n      var initialIndent = repeat(indentValue, initialIndentLevel);\n      addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n\n  while (firstToken !== 17\n  /* EOF */\n  ) {\n    var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n    var secondToken = scanNext();\n    var replaceContent = '';\n\n    while (!lineBreak && (secondToken === 12\n    /* LineCommentTrivia */\n    || secondToken === 13\n    /* BlockCommentTrivia */\n    )) {\n      // comments on the same line: keep them on the same line, but ignore them otherwise\n      var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n      addEdit(' ', firstTokenEnd, commentTokenStart);\n      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n      replaceContent = secondToken === 12\n      /* LineCommentTrivia */\n      ? newLineAndIndent() : '';\n      secondToken = scanNext();\n    }\n\n    if (secondToken === 2\n    /* CloseBraceToken */\n    ) {\n        if (firstToken !== 1\n        /* OpenBraceToken */\n        ) {\n            indentLevel--;\n            replaceContent = newLineAndIndent();\n          }\n      } else if (secondToken === 4\n    /* CloseBracketToken */\n    ) {\n        if (firstToken !== 3\n        /* OpenBracketToken */\n        ) {\n            indentLevel--;\n            replaceContent = newLineAndIndent();\n          }\n      } else {\n      switch (firstToken) {\n        case 3\n        /* OpenBracketToken */\n        :\n        case 1\n        /* OpenBraceToken */\n        :\n          indentLevel++;\n          replaceContent = newLineAndIndent();\n          break;\n\n        case 5\n        /* CommaToken */\n        :\n        case 12\n        /* LineCommentTrivia */\n        :\n          replaceContent = newLineAndIndent();\n          break;\n\n        case 13\n        /* BlockCommentTrivia */\n        :\n          if (lineBreak) {\n            replaceContent = newLineAndIndent();\n          } else {\n            // symbol following comment on the same line: keep on same line, separate with ' '\n            replaceContent = ' ';\n          }\n\n          break;\n\n        case 6\n        /* ColonToken */\n        :\n          replaceContent = ' ';\n          break;\n\n        case 10\n        /* StringLiteral */\n        :\n          if (secondToken === 6\n          /* ColonToken */\n          ) {\n              replaceContent = '';\n              break;\n            }\n\n        // fall through\n\n        case 7\n        /* NullKeyword */\n        :\n        case 8\n        /* TrueKeyword */\n        :\n        case 9\n        /* FalseKeyword */\n        :\n        case 11\n        /* NumericLiteral */\n        :\n        case 2\n        /* CloseBraceToken */\n        :\n        case 4\n        /* CloseBracketToken */\n        :\n          if (secondToken === 12\n          /* LineCommentTrivia */\n          || secondToken === 13\n          /* BlockCommentTrivia */\n          ) {\n              replaceContent = ' ';\n            } else if (secondToken !== 5\n          /* CommaToken */\n          && secondToken !== 17\n          /* EOF */\n          ) {\n              hasError = true;\n            }\n\n          break;\n\n        case 16\n        /* Unknown */\n        :\n          hasError = true;\n          break;\n      }\n\n      if (lineBreak && (secondToken === 12\n      /* LineCommentTrivia */\n      || secondToken === 13\n      /* BlockCommentTrivia */\n      )) {\n        replaceContent = newLineAndIndent();\n      }\n    }\n\n    var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n    addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n    firstToken = secondToken;\n  }\n\n  return editOperations;\n}\n\nfunction repeat(s, count) {\n  var result = '';\n\n  for (var i = 0; i < count; i++) {\n    result += s;\n  }\n\n  return result;\n}\n\nfunction computeIndentLevel(content, options) {\n  var i = 0;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n\n  while (i < content.length) {\n    var ch = content.charAt(i);\n\n    if (ch === ' ') {\n      nChars++;\n    } else if (ch === '\\t') {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n\n    i++;\n  }\n\n  return Math.floor(nChars / tabSize);\n}\n\nfunction getEOL(options, text) {\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n\n    if (ch === '\\r') {\n      if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n        return '\\r\\n';\n      }\n\n      return '\\r';\n    } else if (ch === '\\n') {\n      return '\\n';\n    }\n  }\n\n  return options && options.eol || '\\n';\n}\n\nexport function isEOL(text, offset) {\n  return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/format.js"],"names":["createScanner","format","documentText","range","options","initialIndentLevel","formatText","formatTextStart","rangeStart","rangeEnd","offset","length","isEOL","endOffset","substring","computeIndentLevel","eol","getEOL","lineBreak","indentLevel","indentValue","insertSpaces","repeat","tabSize","scanner","hasError","newLineAndIndent","scanNext","token","scan","getTokenError","editOperations","addEdit","text","startOffset","push","content","firstToken","firstTokenStart","getTokenOffset","initialIndent","firstTokenEnd","getTokenLength","secondToken","replaceContent","commentTokenStart","secondTokenStart","s","count","result","i","nChars","ch","charAt","Math","floor","indexOf"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner.js';\nexport function format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = createScanner(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    replaceContent = ' ';\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        replaceContent = '';\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        replaceContent = ' ';\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nexport function isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n"]},"metadata":{},"sourceType":"module"}