{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\n\nvar LinePart =\n/** @class */\nfunction () {\n  function LinePart(endIndex, type) {\n    this.endIndex = endIndex;\n    this.type = type;\n  }\n\n  return LinePart;\n}();\n\nvar LineRange =\n/** @class */\nfunction () {\n  function LineRange(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n\n  LineRange.prototype.equals = function (otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  };\n\n  return LineRange;\n}();\n\nexport { LineRange };\n\nvar RenderLineInput =\n/** @class */\nfunction () {\n  function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.middotWidth = middotWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 3\n    /* All */\n    : renderWhitespace === 'boundary' ? 1\n    /* Boundary */\n    : renderWhitespace === 'selection' ? 2\n    /* Selection */\n    : 0\n    /* None */\n    ;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) {\n      return a.startOffset < b.startOffset ? -1 : 1;\n    });\n  }\n\n  RenderLineInput.prototype.sameSelection = function (otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n\n    if (otherSelections === null) {\n      return false;\n    }\n\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  RenderLineInput.prototype.equals = function (other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  };\n\n  return RenderLineInput;\n}();\n\nexport { RenderLineInput };\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\n\nvar CharacterMapping =\n/** @class */\nfunction () {\n  function CharacterMapping(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n\n  CharacterMapping.getPartIndex = function (partData) {\n    return (partData & 4294901760\n    /* PART_INDEX_MASK */\n    ) >>> 16\n    /* PART_INDEX_OFFSET */\n    ;\n  };\n\n  CharacterMapping.getCharIndex = function (partData) {\n    return (partData & 65535\n    /* CHAR_INDEX_MASK */\n    ) >>> 0\n    /* CHAR_INDEX_OFFSET */\n    ;\n  };\n\n  CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\n    var partData = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    this._data[charOffset] = partData;\n    this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n  };\n\n  CharacterMapping.prototype.getAbsoluteOffsets = function () {\n    return this._absoluteOffsets;\n  };\n\n  CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n\n    return this._data[charOffset];\n  };\n\n  CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    var searchEntry = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    var min = 0;\n    var max = this.length - 1;\n\n    while (min + 1 < max) {\n      var mid = min + max >>> 1;\n      var midEntry = this._data[mid];\n\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n\n    if (min === max) {\n      return min;\n    }\n\n    var minEntry = this._data[min];\n    var maxEntry = this._data[max];\n\n    if (minEntry === searchEntry) {\n      return min;\n    }\n\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n\n    var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    var maxCharIndex;\n\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n\n    var minEntryDistance = charIndex - minCharIndex;\n    var maxEntryDistance = maxCharIndex - charIndex;\n\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n\n    return max;\n  };\n\n  return CharacterMapping;\n}();\n\nexport { CharacterMapping };\n\nvar RenderLineOutput =\n/** @class */\nfunction () {\n  function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n  return RenderLineOutput;\n}();\n\nexport { RenderLineOutput };\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    var containsForeignElements = 0\n    /* None */\n    ; // This is basically for IE's hit test to work\n\n    var content = '<span><span>\\u00a0</span></span>';\n\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      var beforeClassNames = [];\n      var afterClassNames = [];\n\n      for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\n        var lineDecoration = input.lineDecorations[i];\n\n        if (lineDecoration.type === 1\n        /* Before */\n        ) {\n            beforeClassNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 1\n            /* Before */\n            ;\n          }\n\n        if (lineDecoration.type === 2\n        /* After */\n        ) {\n            afterClassNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 2\n            /* After */\n            ;\n          }\n      }\n\n      if (containsForeignElements !== 0\n      /* None */\n      ) {\n          var beforeSpan = beforeClassNames.length > 0 ? \"<span class=\\\"\" + beforeClassNames.join(' ') + \"\\\"></span>\" : \"\";\n          var afterSpan = afterClassNames.length > 0 ? \"<span class=\\\"\" + afterClassNames.join(' ') + \"\\\"></span>\" : \"\";\n          content = \"<span>\" + beforeSpan + afterSpan + \"</span>\";\n        }\n    }\n\n    sb.appendASCIIString(content);\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n  }\n\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\n\nvar RenderLineOutput2 =\n/** @class */\nfunction () {\n  function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n  return RenderLineOutput2;\n}();\n\nexport { RenderLineOutput2 };\nexport function renderViewLine2(input) {\n  var sb = createStringBuilder(10000);\n  var out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nvar ResolvedRenderLineInput =\n/** @class */\nfunction () {\n  function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, middotWidth, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.fauxIndentLength = fauxIndentLength;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.middotWidth = middotWidth;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters; //\n  }\n\n  return ResolvedRenderLineInput;\n}();\n\nfunction resolveRenderLineInput(input) {\n  var useMonospaceOptimizations = input.useMonospaceOptimizations;\n  var lineContent = input.lineContent;\n  var isOverflowing;\n  var len;\n\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n\n  var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n\n  if (input.renderWhitespace === 3\n  /* All */\n  || input.renderWhitespace === 1\n  /* Boundary */\n  || input.renderWhitespace === 2\n  /* Selection */\n  && !!input.selectionsOnLine) {\n    tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, useMonospaceOptimizations, input.selectionsOnLine, input.renderWhitespace === 1\n    /* Boundary */\n    );\n  }\n\n  var containsForeignElements = 0\n  /* None */\n  ;\n\n  if (input.lineDecorations.length > 0) {\n    for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\n      var lineDecoration = input.lineDecorations[i];\n\n      if (lineDecoration.type === 3\n      /* RegularAffectingLetterSpacing */\n      ) {\n          // Pretend there are foreign elements... although not 100% accurate.\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 1\n      /* Before */\n      ) {\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 2\n      /* After */\n      ) {\n          containsForeignElements |= 2\n          /* After */\n          ;\n        }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n\n  return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.middotWidth, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\n\n\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  var result = [],\n      resultLen = 0; // The faux indent part of the line should have no token type\n\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '');\n  }\n\n  for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    var endIndex = tokens.getEndOffset(tokenIndex);\n\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n\n    var type = tokens.getClassName(tokenIndex);\n\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type);\n      break;\n    }\n\n    result[resultLen++] = new LinePart(endIndex, type);\n  }\n\n  return result;\n}\n/**\r\n * See https://github.com/Microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\n\n\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  var lastTokenEndIndex = 0;\n  var result = [],\n      resultLen = 0;\n\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n\n      if (lastTokenEndIndex + 50\n      /* LongToken */\n      < tokenEndIndex) {\n        var tokenType = token.type;\n        var lastSpaceOffset = -1;\n        var currTokenStart = lastTokenEndIndex;\n\n        for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32\n          /* Space */\n          ) {\n              lastSpaceOffset = j;\n            }\n\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50\n          /* LongToken */\n          ) {\n              // Split at `lastSpaceOffset` + 1\n              result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n              currTokenStart = lastSpaceOffset + 1;\n              lastSpaceOffset = -1;\n            }\n        }\n\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n      var diff = tokenEndIndex - lastTokenEndIndex;\n\n      if (diff > 50\n      /* LongToken */\n      ) {\n          var tokenType = token.type;\n          var piecesCount = Math.ceil(diff / 50\n          /* LongToken */\n          );\n\n          for (var j = 1; j < piecesCount; j++) {\n            var pieceEndIndex = lastTokenEndIndex + j * 50\n            /* LongToken */\n            ;\n            result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n          }\n\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n        } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\n\n\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, startVisibleColumn, useMonospaceOptimizations, selections, onlyBoundary) {\n  var result = [],\n      resultLen = 0;\n  var tokenIndex = 0;\n  var tokenType = tokens[tokenIndex].type;\n  var tokenEndIndex = tokens[tokenIndex].endIndex;\n  var tokensLength = tokens.length;\n  var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  var lastNonWhitespaceIndex;\n\n  if (firstNonWhitespaceIndex === -1) {\n    // The entire line is whitespace\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n\n  var wasInWhitespace = false;\n  var currentSelectionIndex = 0;\n  var currentSelection = selections && selections[currentSelectionIndex];\n  var tmpIndent = startVisibleColumn % tabSize;\n\n  for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n\n    var isInWhitespace = void 0;\n\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9\n    /* Tab */\n    ) {\n        // a tab character is rendered both in all and boundary cases\n        isInWhitespace = true;\n      } else if (chCode === 32\n    /* Space */\n    ) {\n        // hit a space character\n        if (onlyBoundary) {\n          // rendering only boundary whitespace\n          if (wasInWhitespace) {\n            isInWhitespace = true;\n          } else {\n            var nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n            /* Null */\n            ;\n            isInWhitespace = nextChCode === 32\n            /* Space */\n            || nextChCode === 9\n            /* Tab */\n            ;\n          }\n        } else {\n          isInWhitespace = true;\n        }\n      } else {\n      isInWhitespace = false;\n    } // If rendering whitespace on selection, check that the charIndex falls within a selection\n\n\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n\n    if (chCode === 9\n    /* Tab */\n    ) {\n        tmpIndent = tabSize;\n      } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n\n    wasInWhitespace = isInWhitespace;\n\n    if (charIndex === tokenEndIndex) {\n      tokenIndex++;\n\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      }\n    }\n  }\n\n  var generateWhitespace = false;\n\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      var lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0\n      /* Null */\n      ;\n      var prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0\n      /* Null */\n      ;\n      var isSingleTrailingSpace = lastCharCode === 32\n      /* Space */\n      && prevCharCode !== 32\n      /* Space */\n      && prevCharCode !== 9\n      /* Tab */\n      ;\n\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n\n  result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n  return result;\n}\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\n\n\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n\n  var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  var lineDecorationsLen = lineDecorations.length;\n  var lineDecorationIndex = 0;\n  var result = [],\n      resultLen = 0,\n      lastResultEndIndex = 0;\n\n  for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\n    var token = tokens[tokenIndex];\n    var tokenEndIndex = token.endIndex;\n    var tokenType = token.type;\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      var lineDecoration = lineDecorations[lineDecorationIndex];\n\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n      }\n\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        break;\n      }\n    }\n\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n    }\n  }\n\n  var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    var classNames = [];\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      classNames.push(lineDecorations[lineDecorationIndex].className);\n      lineDecorationIndex++;\n    }\n\n    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n  }\n\n  return result;\n}\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\n\n\nfunction _renderLine(input, sb) {\n  var fontIsMonospace = input.fontIsMonospace;\n  var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  var containsForeignElements = input.containsForeignElements;\n  var lineContent = input.lineContent;\n  var len = input.len;\n  var isOverflowing = input.isOverflowing;\n  var parts = input.parts;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var containsRTL = input.containsRTL;\n  var spaceWidth = input.spaceWidth;\n  var middotWidth = input.middotWidth;\n  var renderWhitespace = input.renderWhitespace;\n  var renderControlCharacters = input.renderControlCharacters; // use U+2E31 - WORD SEPARATOR MIDDLE DOT or U+00B7 - MIDDLE DOT\n\n  var spaceRenderWhitespaceCharacter = middotWidth > spaceWidth ? 0x2E31 : 0xB7;\n  var characterMapping = new CharacterMapping(len + 1, parts.length);\n  var charIndex = 0;\n  var visibleColumn = startVisibleColumn;\n  var charOffsetInPart = 0;\n  var prevPartContentCnt = 0;\n  var partAbsoluteOffset = 0;\n  sb.appendASCIIString('<span>');\n\n  for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    var part = parts[partIndex];\n    var partEndIndex = part.endIndex;\n    var partType = part.type;\n    var partRendersWhitespace = renderWhitespace !== 0\n    /* None */\n    && partType.indexOf('vs-whitespace') >= 0;\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partType);\n    sb.appendASCII(34\n    /* DoubleQuote */\n    );\n\n    if (partRendersWhitespace) {\n      var partContentCnt = 0;\n      {\n        var _charIndex = charIndex;\n        var _visibleColumn = visibleColumn;\n\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          var charCode = lineContent.charCodeAt(_charIndex);\n          var charWidth = (charCode === 9\n          /* Tab */\n          ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partContentCnt += charWidth;\n\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n\n      if (!fontIsMonospace) {\n        var partIsOnlyWhitespace = partType === 'vs-whitespace';\n\n        if (partIsOnlyWhitespace || !containsForeignElements) {\n          sb.appendASCIIString(' style=\"display:inline-block;width:');\n          sb.appendASCIIString(String(spaceWidth * partContentCnt));\n          sb.appendASCIIString('px\"');\n        }\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n        var charWidth = void 0;\n\n        if (charCode === 9\n        /* Tab */\n        ) {\n            charWidth = tabSize - visibleColumn % tabSize | 0;\n\n            if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n              sb.write1(0x2192); // RIGHTWARDS ARROW\n            } else {\n              sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n            }\n\n            for (var space = 2; space <= charWidth; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n          } else {\n          // must be CharCode.Space\n          charWidth = 1;\n          sb.write1(spaceRenderWhitespaceCharacter); // &middot; or word separator middle dot\n        }\n\n        charOffsetInPart += charWidth;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n\n      prevPartContentCnt = partContentCnt;\n    } else {\n      var partContentCnt = 0;\n\n      if (containsRTL) {\n        sb.appendASCIIString(' dir=\"ltr\"');\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n        var producedCharacters = 1;\n        var charWidth = 1;\n\n        switch (charCode) {\n          case 9\n          /* Tab */\n          :\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            charWidth = producedCharacters;\n\n            for (var space = 1; space <= producedCharacters; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n\n            break;\n\n          case 32\n          /* Space */\n          :\n            sb.write1(0xA0); // &nbsp;\n\n            break;\n\n          case 60\n          /* LessThan */\n          :\n            sb.appendASCIIString('&lt;');\n            break;\n\n          case 62\n          /* GreaterThan */\n          :\n            sb.appendASCIIString('&gt;');\n            break;\n\n          case 38\n          /* Ampersand */\n          :\n            sb.appendASCIIString('&amp;');\n            break;\n\n          case 0\n          /* Null */\n          :\n            sb.appendASCIIString('&#00;');\n            break;\n\n          case 65279\n          /* UTF8_BOM */\n          :\n          case 8232\n          /* LINE_SEPARATOR_2028 */\n          :\n            sb.write1(0xFFFD);\n            break;\n\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              charWidth++;\n            }\n\n            if (renderControlCharacters && charCode < 32) {\n              sb.write1(9216 + charCode);\n            } else {\n              sb.write1(charCode);\n            }\n\n        }\n\n        charOffsetInPart += producedCharacters;\n        partContentCnt += producedCharacters;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n\n      prevPartContentCnt = partContentCnt;\n    }\n\n    sb.appendASCIIString('</span>');\n  } // When getting client rects for the last character, we will position the\n  // text range at the end of the span, insteaf of at the beginning of next span\n\n\n  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","endIndex","type","LineRange","startIndex","startOffset","endOffset","prototype","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","a","b","sameSelection","otherSelections","length","i","other","equalsArr","CharacterMapping","partCount","_data","Uint32Array","_absoluteOffsets","getPartIndex","partData","getCharIndex","setPartData","charOffset","partIndex","charIndex","partAbsoluteOffset","getAbsoluteOffsets","charOffsetToPartData","partDataToCharOffset","partLength","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","renderViewLine","input","sb","content","beforeClassNames","afterClassNames","len","lineDecoration","push","className","beforeSpan","join","afterSpan","appendASCIIString","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","parts","tokens","transformAndRemoveOverflowing","_applyRenderWhitespace","len_1","_applyInlineDecorations","splitLargeTokens","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","Math","ceil","pieceEndIndex","selections","onlyBoundary","tokensLength","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","compare","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","len_2","classNames","spaceRenderWhitespaceCharacter","visibleColumn","charOffsetInPart","prevPartContentCnt","part","partEndIndex","partType","partRendersWhitespace","indexOf","appendASCII","partContentCnt","_charIndex","_visibleColumn","charCode","charWidth","partIsOnlyWhitespace","String","write1","space","producedCharacters"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { createStringBuilder } from '../core/stringBuilder.js';\r\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\r\nvar LinePart = /** @class */ (function () {\r\n    function LinePart(endIndex, type) {\r\n        this.endIndex = endIndex;\r\n        this.type = type;\r\n    }\r\n    return LinePart;\r\n}());\r\nvar LineRange = /** @class */ (function () {\r\n    function LineRange(startIndex, endIndex) {\r\n        this.startOffset = startIndex;\r\n        this.endOffset = endIndex;\r\n    }\r\n    LineRange.prototype.equals = function (otherLineRange) {\r\n        return this.startOffset === otherLineRange.startOffset\r\n            && this.endOffset === otherLineRange.endOffset;\r\n    };\r\n    return LineRange;\r\n}());\r\nexport { LineRange };\r\nvar RenderLineInput = /** @class */ (function () {\r\n    function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\r\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\r\n        this.isBasicASCII = isBasicASCII;\r\n        this.containsRTL = containsRTL;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.lineTokens = lineTokens;\r\n        this.lineDecorations = lineDecorations;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.spaceWidth = spaceWidth;\r\n        this.middotWidth = middotWidth;\r\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\r\n        this.renderWhitespace = (renderWhitespace === 'all'\r\n            ? 3 /* All */\r\n            : renderWhitespace === 'boundary'\r\n                ? 1 /* Boundary */\r\n                : renderWhitespace === 'selection'\r\n                    ? 2 /* Selection */\r\n                    : 0 /* None */);\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        this.fontLigatures = fontLigatures;\r\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) { return a.startOffset < b.startOffset ? -1 : 1; });\r\n    }\r\n    RenderLineInput.prototype.sameSelection = function (otherSelections) {\r\n        if (this.selectionsOnLine === null) {\r\n            return otherSelections === null;\r\n        }\r\n        if (otherSelections === null) {\r\n            return false;\r\n        }\r\n        if (otherSelections.length !== this.selectionsOnLine.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < this.selectionsOnLine.length; i++) {\r\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    RenderLineInput.prototype.equals = function (other) {\r\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\r\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\r\n            && this.lineContent === other.lineContent\r\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\r\n            && this.isBasicASCII === other.isBasicASCII\r\n            && this.containsRTL === other.containsRTL\r\n            && this.fauxIndentLength === other.fauxIndentLength\r\n            && this.tabSize === other.tabSize\r\n            && this.startVisibleColumn === other.startVisibleColumn\r\n            && this.spaceWidth === other.spaceWidth\r\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\r\n            && this.renderWhitespace === other.renderWhitespace\r\n            && this.renderControlCharacters === other.renderControlCharacters\r\n            && this.fontLigatures === other.fontLigatures\r\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\r\n            && this.lineTokens.equals(other.lineTokens)\r\n            && this.sameSelection(other.selectionsOnLine));\r\n    };\r\n    return RenderLineInput;\r\n}());\r\nexport { RenderLineInput };\r\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\r\nvar CharacterMapping = /** @class */ (function () {\r\n    function CharacterMapping(length, partCount) {\r\n        this.length = length;\r\n        this._data = new Uint32Array(this.length);\r\n        this._absoluteOffsets = new Uint32Array(this.length);\r\n    }\r\n    CharacterMapping.getPartIndex = function (partData) {\r\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\r\n    };\r\n    CharacterMapping.getCharIndex = function (partData) {\r\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\r\n    };\r\n    CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\r\n        var partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        this._data[charOffset] = partData;\r\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\r\n    };\r\n    CharacterMapping.prototype.getAbsoluteOffsets = function () {\r\n        return this._absoluteOffsets;\r\n    };\r\n    CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        if (charOffset < 0) {\r\n            return this._data[0];\r\n        }\r\n        if (charOffset >= this.length) {\r\n            return this._data[this.length - 1];\r\n        }\r\n        return this._data[charOffset];\r\n    };\r\n    CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        var searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        var min = 0;\r\n        var max = this.length - 1;\r\n        while (min + 1 < max) {\r\n            var mid = ((min + max) >>> 1);\r\n            var midEntry = this._data[mid];\r\n            if (midEntry === searchEntry) {\r\n                return mid;\r\n            }\r\n            else if (midEntry > searchEntry) {\r\n                max = mid;\r\n            }\r\n            else {\r\n                min = mid;\r\n            }\r\n        }\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        var minEntry = this._data[min];\r\n        var maxEntry = this._data[max];\r\n        if (minEntry === searchEntry) {\r\n            return min;\r\n        }\r\n        if (maxEntry === searchEntry) {\r\n            return max;\r\n        }\r\n        var minPartIndex = CharacterMapping.getPartIndex(minEntry);\r\n        var minCharIndex = CharacterMapping.getCharIndex(minEntry);\r\n        var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\r\n        var maxCharIndex;\r\n        if (minPartIndex !== maxPartIndex) {\r\n            // sitting between parts\r\n            maxCharIndex = partLength;\r\n        }\r\n        else {\r\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\r\n        }\r\n        var minEntryDistance = charIndex - minCharIndex;\r\n        var maxEntryDistance = maxCharIndex - charIndex;\r\n        if (minEntryDistance <= maxEntryDistance) {\r\n            return min;\r\n        }\r\n        return max;\r\n    };\r\n    return CharacterMapping;\r\n}());\r\nexport { CharacterMapping };\r\nvar RenderLineOutput = /** @class */ (function () {\r\n    function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n    return RenderLineOutput;\r\n}());\r\nexport { RenderLineOutput };\r\nexport function renderViewLine(input, sb) {\r\n    if (input.lineContent.length === 0) {\r\n        var containsForeignElements = 0 /* None */;\r\n        // This is basically for IE's hit test to work\r\n        var content = '<span><span>\\u00a0</span></span>';\r\n        if (input.lineDecorations.length > 0) {\r\n            // This line is empty, but it contains inline decorations\r\n            var beforeClassNames = [];\r\n            var afterClassNames = [];\r\n            for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n                var lineDecoration = input.lineDecorations[i];\r\n                if (lineDecoration.type === 1 /* Before */) {\r\n                    beforeClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 1 /* Before */;\r\n                }\r\n                if (lineDecoration.type === 2 /* After */) {\r\n                    afterClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 2 /* After */;\r\n                }\r\n            }\r\n            if (containsForeignElements !== 0 /* None */) {\r\n                var beforeSpan = (beforeClassNames.length > 0 ? \"<span class=\\\"\" + beforeClassNames.join(' ') + \"\\\"></span>\" : \"\");\r\n                var afterSpan = (afterClassNames.length > 0 ? \"<span class=\\\"\" + afterClassNames.join(' ') + \"\\\"></span>\" : \"\");\r\n                content = \"<span>\" + beforeSpan + afterSpan + \"</span>\";\r\n            }\r\n        }\r\n        sb.appendASCIIString(content);\r\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\r\n    }\r\n    return _renderLine(resolveRenderLineInput(input), sb);\r\n}\r\nvar RenderLineOutput2 = /** @class */ (function () {\r\n    function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.html = html;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n    return RenderLineOutput2;\r\n}());\r\nexport { RenderLineOutput2 };\r\nexport function renderViewLine2(input) {\r\n    var sb = createStringBuilder(10000);\r\n    var out = renderViewLine(input, sb);\r\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\r\n}\r\nvar ResolvedRenderLineInput = /** @class */ (function () {\r\n    function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, middotWidth, renderWhitespace, renderControlCharacters) {\r\n        this.fontIsMonospace = fontIsMonospace;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.len = len;\r\n        this.isOverflowing = isOverflowing;\r\n        this.parts = parts;\r\n        this.containsForeignElements = containsForeignElements;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.containsRTL = containsRTL;\r\n        this.spaceWidth = spaceWidth;\r\n        this.middotWidth = middotWidth;\r\n        this.renderWhitespace = renderWhitespace;\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        //\r\n    }\r\n    return ResolvedRenderLineInput;\r\n}());\r\nfunction resolveRenderLineInput(input) {\r\n    var useMonospaceOptimizations = input.useMonospaceOptimizations;\r\n    var lineContent = input.lineContent;\r\n    var isOverflowing;\r\n    var len;\r\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\r\n        isOverflowing = true;\r\n        len = input.stopRenderingLineAfter;\r\n    }\r\n    else {\r\n        isOverflowing = false;\r\n        len = lineContent.length;\r\n    }\r\n    var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\r\n    if (input.renderWhitespace === 3 /* All */ || input.renderWhitespace === 1 /* Boundary */ || (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine)) {\r\n        tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, useMonospaceOptimizations, input.selectionsOnLine, input.renderWhitespace === 1 /* Boundary */);\r\n    }\r\n    var containsForeignElements = 0 /* None */;\r\n    if (input.lineDecorations.length > 0) {\r\n        for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\r\n            var lineDecoration = input.lineDecorations[i];\r\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\r\n                // Pretend there are foreign elements... although not 100% accurate.\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 1 /* Before */) {\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 2 /* After */) {\r\n                containsForeignElements |= 2 /* After */;\r\n            }\r\n        }\r\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\r\n    }\r\n    if (!input.containsRTL) {\r\n        // We can never split RTL text, as it ruins the rendering\r\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\r\n    }\r\n    return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.middotWidth, input.renderWhitespace, input.renderControlCharacters);\r\n}\r\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\r\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\r\n    var result = [], resultLen = 0;\r\n    // The faux indent part of the line should have no token type\r\n    if (fauxIndentLength > 0) {\r\n        result[resultLen++] = new LinePart(fauxIndentLength, '');\r\n    }\r\n    for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n        var endIndex = tokens.getEndOffset(tokenIndex);\r\n        if (endIndex <= fauxIndentLength) {\r\n            // The faux indent part of the line should have no token type\r\n            continue;\r\n        }\r\n        var type = tokens.getClassName(tokenIndex);\r\n        if (endIndex >= len) {\r\n            result[resultLen++] = new LinePart(len, type);\r\n            break;\r\n        }\r\n        result[resultLen++] = new LinePart(endIndex, type);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * See https://github.com/Microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\r\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\r\n    var lastTokenEndIndex = 0;\r\n    var result = [], resultLen = 0;\r\n    if (onlyAtSpaces) {\r\n        // Split only at spaces => we need to walk each character\r\n        for (var i = 0, len = tokens.length; i < len; i++) {\r\n            var token = tokens[i];\r\n            var tokenEndIndex = token.endIndex;\r\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\r\n                var tokenType = token.type;\r\n                var lastSpaceOffset = -1;\r\n                var currTokenStart = lastTokenEndIndex;\r\n                for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\r\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\r\n                        lastSpaceOffset = j;\r\n                    }\r\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\r\n                        // Split at `lastSpaceOffset` + 1\r\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\r\n                        currTokenStart = lastSpaceOffset + 1;\r\n                        lastSpaceOffset = -1;\r\n                    }\r\n                }\r\n                if (currTokenStart !== tokenEndIndex) {\r\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\r\n                }\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    else {\r\n        // Split anywhere => we don't need to walk each character\r\n        for (var i = 0, len = tokens.length; i < len; i++) {\r\n            var token = tokens[i];\r\n            var tokenEndIndex = token.endIndex;\r\n            var diff = (tokenEndIndex - lastTokenEndIndex);\r\n            if (diff > 50 /* LongToken */) {\r\n                var tokenType = token.type;\r\n                var piecesCount = Math.ceil(diff / 50 /* LongToken */);\r\n                for (var j = 1; j < piecesCount; j++) {\r\n                    var pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\r\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\r\n                }\r\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\r\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, startVisibleColumn, useMonospaceOptimizations, selections, onlyBoundary) {\r\n    var result = [], resultLen = 0;\r\n    var tokenIndex = 0;\r\n    var tokenType = tokens[tokenIndex].type;\r\n    var tokenEndIndex = tokens[tokenIndex].endIndex;\r\n    var tokensLength = tokens.length;\r\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n    var lastNonWhitespaceIndex;\r\n    if (firstNonWhitespaceIndex === -1) {\r\n        // The entire line is whitespace\r\n        firstNonWhitespaceIndex = len;\r\n        lastNonWhitespaceIndex = len;\r\n    }\r\n    else {\r\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\r\n    }\r\n    var wasInWhitespace = false;\r\n    var currentSelectionIndex = 0;\r\n    var currentSelection = selections && selections[currentSelectionIndex];\r\n    var tmpIndent = startVisibleColumn % tabSize;\r\n    for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\r\n        var chCode = lineContent.charCodeAt(charIndex);\r\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\r\n            currentSelectionIndex++;\r\n            currentSelection = selections && selections[currentSelectionIndex];\r\n        }\r\n        var isInWhitespace = void 0;\r\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\r\n            // in leading or trailing whitespace\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 9 /* Tab */) {\r\n            // a tab character is rendered both in all and boundary cases\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 32 /* Space */) {\r\n            // hit a space character\r\n            if (onlyBoundary) {\r\n                // rendering only boundary whitespace\r\n                if (wasInWhitespace) {\r\n                    isInWhitespace = true;\r\n                }\r\n                else {\r\n                    var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\r\n                }\r\n            }\r\n            else {\r\n                isInWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            isInWhitespace = false;\r\n        }\r\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\r\n        if (isInWhitespace && selections) {\r\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\r\n        }\r\n        if (wasInWhitespace) {\r\n            // was in whitespace token\r\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\r\n                // leaving whitespace token or entering a new indent\r\n                result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        else {\r\n            // was in regular token\r\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\r\n                result[resultLen++] = new LinePart(charIndex, tokenType);\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        if (chCode === 9 /* Tab */) {\r\n            tmpIndent = tabSize;\r\n        }\r\n        else if (strings.isFullWidthCharacter(chCode)) {\r\n            tmpIndent += 2;\r\n        }\r\n        else {\r\n            tmpIndent++;\r\n        }\r\n        wasInWhitespace = isInWhitespace;\r\n        if (charIndex === tokenEndIndex) {\r\n            tokenIndex++;\r\n            if (tokenIndex < tokensLength) {\r\n                tokenType = tokens[tokenIndex].type;\r\n                tokenEndIndex = tokens[tokenIndex].endIndex;\r\n            }\r\n        }\r\n    }\r\n    var generateWhitespace = false;\r\n    if (wasInWhitespace) {\r\n        // was in whitespace token\r\n        if (continuesWithWrappedLine && onlyBoundary) {\r\n            var lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\r\n            var prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\r\n            var isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\r\n            if (!isSingleTrailingSpace) {\r\n                generateWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            generateWhitespace = true;\r\n        }\r\n    }\r\n    result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\r\n    return result;\r\n}\r\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\r\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\r\n    _lineDecorations.sort(LineDecoration.compare);\r\n    var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\r\n    var lineDecorationsLen = lineDecorations.length;\r\n    var lineDecorationIndex = 0;\r\n    var result = [], resultLen = 0, lastResultEndIndex = 0;\r\n    for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\r\n        var token = tokens[tokenIndex];\r\n        var tokenEndIndex = token.endIndex;\r\n        var tokenType = token.type;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\r\n            var lineDecoration = lineDecorations[lineDecorationIndex];\r\n            if (lineDecoration.startOffset > lastResultEndIndex) {\r\n                lastResultEndIndex = lineDecoration.startOffset;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\r\n            }\r\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\r\n                // This line decoration ends before this token ends\r\n                lastResultEndIndex = lineDecoration.endOffset + 1;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\r\n                lineDecorationIndex++;\r\n            }\r\n            else {\r\n                // This line decoration continues on to the next token\r\n                lastResultEndIndex = tokenEndIndex;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\r\n                break;\r\n            }\r\n        }\r\n        if (tokenEndIndex > lastResultEndIndex) {\r\n            lastResultEndIndex = tokenEndIndex;\r\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\r\n        }\r\n    }\r\n    var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\r\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n        var classNames = [];\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n            classNames.push(lineDecorations[lineDecorationIndex].className);\r\n            lineDecorationIndex++;\r\n        }\r\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\r\nfunction _renderLine(input, sb) {\r\n    var fontIsMonospace = input.fontIsMonospace;\r\n    var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\r\n    var containsForeignElements = input.containsForeignElements;\r\n    var lineContent = input.lineContent;\r\n    var len = input.len;\r\n    var isOverflowing = input.isOverflowing;\r\n    var parts = input.parts;\r\n    var fauxIndentLength = input.fauxIndentLength;\r\n    var tabSize = input.tabSize;\r\n    var startVisibleColumn = input.startVisibleColumn;\r\n    var containsRTL = input.containsRTL;\r\n    var spaceWidth = input.spaceWidth;\r\n    var middotWidth = input.middotWidth;\r\n    var renderWhitespace = input.renderWhitespace;\r\n    var renderControlCharacters = input.renderControlCharacters;\r\n    // use U+2E31 - WORD SEPARATOR MIDDLE DOT or U+00B7 - MIDDLE DOT\r\n    var spaceRenderWhitespaceCharacter = (middotWidth > spaceWidth ? 0x2E31 : 0xB7);\r\n    var characterMapping = new CharacterMapping(len + 1, parts.length);\r\n    var charIndex = 0;\r\n    var visibleColumn = startVisibleColumn;\r\n    var charOffsetInPart = 0;\r\n    var prevPartContentCnt = 0;\r\n    var partAbsoluteOffset = 0;\r\n    sb.appendASCIIString('<span>');\r\n    for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\r\n        partAbsoluteOffset += prevPartContentCnt;\r\n        var part = parts[partIndex];\r\n        var partEndIndex = part.endIndex;\r\n        var partType = part.type;\r\n        var partRendersWhitespace = (renderWhitespace !== 0 /* None */ && (partType.indexOf('vs-whitespace') >= 0));\r\n        charOffsetInPart = 0;\r\n        sb.appendASCIIString('<span class=\"');\r\n        sb.appendASCIIString(partType);\r\n        sb.appendASCII(34 /* DoubleQuote */);\r\n        if (partRendersWhitespace) {\r\n            var partContentCnt = 0;\r\n            {\r\n                var _charIndex = charIndex;\r\n                var _visibleColumn = visibleColumn;\r\n                for (; _charIndex < partEndIndex; _charIndex++) {\r\n                    var charCode = lineContent.charCodeAt(_charIndex);\r\n                    var charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\r\n                    partContentCnt += charWidth;\r\n                    if (_charIndex >= fauxIndentLength) {\r\n                        _visibleColumn += charWidth;\r\n                    }\r\n                }\r\n            }\r\n            if (!fontIsMonospace) {\r\n                var partIsOnlyWhitespace = (partType === 'vs-whitespace');\r\n                if (partIsOnlyWhitespace || !containsForeignElements) {\r\n                    sb.appendASCIIString(' style=\"display:inline-block;width:');\r\n                    sb.appendASCIIString(String(spaceWidth * partContentCnt));\r\n                    sb.appendASCIIString('px\"');\r\n                }\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\r\n                var charCode = lineContent.charCodeAt(charIndex);\r\n                var charWidth = void 0;\r\n                if (charCode === 9 /* Tab */) {\r\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\r\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\r\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\r\n                    }\r\n                    else {\r\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\r\n                    }\r\n                    for (var space = 2; space <= charWidth; space++) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                }\r\n                else { // must be CharCode.Space\r\n                    charWidth = 1;\r\n                    sb.write1(spaceRenderWhitespaceCharacter); // &middot; or word separator middle dot\r\n                }\r\n                charOffsetInPart += charWidth;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        else {\r\n            var partContentCnt = 0;\r\n            if (containsRTL) {\r\n                sb.appendASCIIString(' dir=\"ltr\"');\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\r\n                var charCode = lineContent.charCodeAt(charIndex);\r\n                var producedCharacters = 1;\r\n                var charWidth = 1;\r\n                switch (charCode) {\r\n                    case 9 /* Tab */:\r\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                        charWidth = producedCharacters;\r\n                        for (var space = 1; space <= producedCharacters; space++) {\r\n                            sb.write1(0xA0); // &nbsp;\r\n                        }\r\n                        break;\r\n                    case 32 /* Space */:\r\n                        sb.write1(0xA0); // &nbsp;\r\n                        break;\r\n                    case 60 /* LessThan */:\r\n                        sb.appendASCIIString('&lt;');\r\n                        break;\r\n                    case 62 /* GreaterThan */:\r\n                        sb.appendASCIIString('&gt;');\r\n                        break;\r\n                    case 38 /* Ampersand */:\r\n                        sb.appendASCIIString('&amp;');\r\n                        break;\r\n                    case 0 /* Null */:\r\n                        sb.appendASCIIString('&#00;');\r\n                        break;\r\n                    case 65279 /* UTF8_BOM */:\r\n                    case 8232 /* LINE_SEPARATOR_2028 */:\r\n                        sb.write1(0xFFFD);\r\n                        break;\r\n                    default:\r\n                        if (strings.isFullWidthCharacter(charCode)) {\r\n                            charWidth++;\r\n                        }\r\n                        if (renderControlCharacters && charCode < 32) {\r\n                            sb.write1(9216 + charCode);\r\n                        }\r\n                        else {\r\n                            sb.write1(charCode);\r\n                        }\r\n                }\r\n                charOffsetInPart += producedCharacters;\r\n                partContentCnt += producedCharacters;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        sb.appendASCIIString('</span>');\r\n    }\r\n    // When getting client rects for the last character, we will position the\r\n    // text range at the end of the span, insteaf of at the beginning of next span\r\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\r\n    if (isOverflowing) {\r\n        sb.appendASCIIString('<span>&hellip;</span>');\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}