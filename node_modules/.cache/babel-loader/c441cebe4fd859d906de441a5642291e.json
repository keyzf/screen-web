{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nvar CACHE_STACK_DEPTH = 5;\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\n\nvar MonarchStackElementFactory =\n/** @class */\nfunction () {\n  function MonarchStackElementFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  MonarchStackElementFactory.create = function (parent, state) {\n    return this._INSTANCE.create(parent, state);\n  };\n\n  MonarchStackElementFactory.prototype.create = function (parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n\n    var stackElementId = MonarchStackElement.getStackElementId(parent);\n\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n\n    stackElementId += state;\n    var result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n\n  MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n  return MonarchStackElementFactory;\n}();\n\nvar MonarchStackElement =\n/** @class */\nfunction () {\n  function MonarchStackElement(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n\n  MonarchStackElement.getStackElementId = function (element) {\n    var result = '';\n\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n\n      result += element.state;\n      element = element.parent;\n    }\n\n    return result;\n  };\n\n  MonarchStackElement._equals = function (a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n\n      if (a.state !== b.state) {\n        return false;\n      }\n\n      a = a.parent;\n      b = b.parent;\n    }\n\n    if (a === null && b === null) {\n      return true;\n    }\n\n    return false;\n  };\n\n  MonarchStackElement.prototype.equals = function (other) {\n    return MonarchStackElement._equals(this, other);\n  };\n\n  MonarchStackElement.prototype.push = function (state) {\n    return MonarchStackElementFactory.create(this, state);\n  };\n\n  MonarchStackElement.prototype.pop = function () {\n    return this.parent;\n  };\n\n  MonarchStackElement.prototype.popall = function () {\n    var result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  };\n\n  MonarchStackElement.prototype.switchTo = function (state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  };\n\n  return MonarchStackElement;\n}();\n\nvar EmbeddedModeData =\n/** @class */\nfunction () {\n  function EmbeddedModeData(modeId, state) {\n    this.modeId = modeId;\n    this.state = state;\n  }\n\n  EmbeddedModeData.prototype.equals = function (other) {\n    return this.modeId === other.modeId && this.state.equals(other.state);\n  };\n\n  EmbeddedModeData.prototype.clone = function () {\n    var stateClone = this.state.clone(); // save an object\n\n    if (stateClone === this.state) {\n      return this;\n    }\n\n    return new EmbeddedModeData(this.modeId, this.state);\n  };\n\n  return EmbeddedModeData;\n}();\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\n\n\nvar MonarchLineStateFactory =\n/** @class */\nfunction () {\n  function MonarchLineStateFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  MonarchLineStateFactory.create = function (stack, embeddedModeData) {\n    return this._INSTANCE.create(stack, embeddedModeData);\n  };\n\n  MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {\n    if (embeddedModeData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    var stackElementId = MonarchStackElement.getStackElementId(stack);\n    var result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n\n  MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n  return MonarchLineStateFactory;\n}();\n\nvar MonarchLineState =\n/** @class */\nfunction () {\n  function MonarchLineState(stack, embeddedModeData) {\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n\n  MonarchLineState.prototype.clone = function () {\n    var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null; // save an object\n\n    if (embeddedModeDataClone === this.embeddedModeData) {\n      return this;\n    }\n\n    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n  };\n\n  MonarchLineState.prototype.equals = function (other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n\n    if (this.embeddedModeData === null && other.embeddedModeData === null) {\n      return true;\n    }\n\n    if (this.embeddedModeData === null || other.embeddedModeData === null) {\n      return false;\n    }\n\n    return this.embeddedModeData.equals(other.embeddedModeData);\n  };\n\n  return MonarchLineState;\n}();\n\nvar MonarchClassicTokensCollector =\n/** @class */\nfunction () {\n  function MonarchClassicTokensCollector() {\n    this._tokens = [];\n    this._language = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n\n  MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._language = modeId;\n  };\n\n  MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n      return;\n    }\n\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._language;\n\n    this._tokens.push(new Token(startOffset, type, this._language));\n  };\n\n  MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._tokens = this._tokens.concat(nestedResult.tokens);\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._language = null;\n    return nestedResult.endState;\n  };\n\n  MonarchClassicTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult(this._tokens, endState);\n  };\n\n  return MonarchClassicTokensCollector;\n}();\n\nvar MonarchModernTokensCollector =\n/** @class */\nfunction () {\n  function MonarchModernTokensCollector(modeService, theme) {\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0\n    /* Null */\n    ;\n    this._lastTokenMetadata = 0;\n  }\n\n  MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n  };\n\n  MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {\n    var metadata = this._theme.match(this._currentLanguageId, type);\n\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n\n    this._lastTokenMetadata = metadata;\n\n    this._tokens.push(startOffset);\n\n    this._tokens.push(metadata);\n  };\n\n  MonarchModernTokensCollector._merge = function (a, b, c) {\n    var aLen = a !== null ? a.length : 0;\n    var bLen = b.length;\n    var cLen = c !== null ? c.length : 0;\n\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n\n    var result = new Uint32Array(aLen + bLen + cLen);\n\n    if (a !== null) {\n      result.set(a);\n    }\n\n    for (var i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n\n    return result;\n  };\n\n  MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  };\n\n  MonarchModernTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  };\n\n  return MonarchModernTokensCollector;\n}();\n\nvar MonarchTokenizer =\n/** @class */\nfunction () {\n  function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\n    var _this = this;\n\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._modeId = modeId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined); // Set up listening for embedded modes\n\n    var emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\n      if (emitting) {\n        return;\n      }\n\n      var isOneOfMyEmbeddedModes = false;\n\n      for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\n        var language = e.changedLanguages[i];\n\n        if (_this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([_this._modeId]);\n        emitting = false;\n      }\n    });\n  }\n\n  MonarchTokenizer.prototype.dispose = function () {\n    this._tokenizationRegistryListener.dispose();\n  };\n\n  MonarchTokenizer.prototype.getLoadStatus = function () {\n    var promises = [];\n\n    for (var nestedModeId in this._embeddedModes) {\n      var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (tokenizationSupport) {\n        // The nested mode is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          var nestedModeStatus = tokenizationSupport.getLoadStatus();\n\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n\n        continue;\n      }\n\n      var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n\n      if (tokenizationSupportPromise) {\n        // The nested mode is in the process of being loaded\n        promises.push(tokenizationSupportPromise);\n      }\n    }\n\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(function (_) {\n        return undefined;\n      })\n    };\n  };\n\n  MonarchTokenizer.prototype.getInitialState = function () {\n    var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  };\n\n  MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchClassicTokensCollector();\n\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  };\n\n  MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\n\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  };\n\n  MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {\n    if (lineState.embeddedModeData) {\n      return this._nestedTokenize(line, lineState, offsetDelta, collector);\n    } else {\n      return this._myTokenize(line, lineState, offsetDelta, collector);\n    }\n  };\n\n  MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {\n    var rules = this._lexer.tokenizer[state.stack.state];\n\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n\n    var popOffset = -1;\n    var hasEmbeddedPopRule = false;\n\n    for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\n      var rule = rules_1[_i];\n\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n\n      hasEmbeddedPopRule = true;\n      var regex = rule.regex;\n      var regexSource = rule.regex.source;\n\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\n      }\n\n      var result = line.search(regex);\n\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n\n    return popOffset;\n  };\n\n  MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    var popOffset = this._findLeavingNestedModeOffset(line, lineState);\n\n    if (popOffset === -1) {\n      // tokenization will not leave nested mode\n      var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n    }\n\n    var nestedModeLine = line.substring(0, popOffset);\n\n    if (nestedModeLine.length > 0) {\n      // tokenize with the nested mode\n      tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\n    }\n\n    var restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\n  };\n\n  MonarchTokenizer.prototype._safeRuleName = function (rule) {\n    if (rule) {\n      return rule.name;\n    }\n\n    return '(unknown)';\n  };\n\n  MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterMode(offsetDelta, this._modeId);\n    var lineLength = line.length;\n    var embeddedModeData = lineState.embeddedModeData;\n    var stack = lineState.stack;\n    var pos = 0;\n    var groupMatching = null; // See https://github.com/Microsoft/monaco-editor/issues/1235:\n    // Evaluate rules at least once for an empty line\n\n    var forceEvaluation = true;\n\n    while (forceEvaluation || pos < lineLength) {\n      var pos0 = pos;\n      var stackLen0 = stack.depth;\n      var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      var state = stack.state;\n      var matches = null;\n      var matched = null;\n      var action = null;\n      var rule = null;\n      var enteringEmbeddedMode = null; // check if we need to process group matches first\n\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        var groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule; // cleanup if necessary\n\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n\n        forceEvaluation = false; // get the rules for this state\n\n        var rules = this._lexer.tokenizer[state];\n\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        } // try each rule until we match\n\n\n        var restOfLine = line.substr(pos);\n\n        for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {\n          var rule_1 = rules_2[_i];\n\n          if (pos === 0 || !rule_1.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule_1.regex);\n\n            if (matches) {\n              matched = matches[0];\n              action = rule_1.action;\n              break;\n            }\n          }\n        }\n      } // We matched 'rule' with 'matches' and 'action'\n\n\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n\n        action = this._lexer.defaultToken;\n      }\n\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      } // advance stream\n\n\n      pos += matched.length; // maybe call action function (used for 'cases')\n\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n\n      var result = null; // set the result: either a string or an array of actions\n\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        } // enter embedded mode?\n\n\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n            }\n\n            embeddedModeData = null;\n          } else if (embeddedModeData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n          } else {\n            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        } // state transformations\n\n\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      } // check result\n\n\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      } // is the result a group match?\n\n\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n\n        var totalLen = 0;\n\n        for (var i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n\n        for (var i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n\n        pos -= matched.length; // call recursively to initiate first result match\n\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n\n          matches = null;\n          result = '';\n        } // check progress\n\n\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        } // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n\n\n        var tokenType = null;\n\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          var rest = result.substr('@brackets'.length);\n          var bracket = findBracket(this._lexer, matched);\n\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          var token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n\n        tokensCollector.emit(pos0 + offsetDelta, tokenType);\n      }\n\n      if (enteringEmbeddedMode !== null) {\n        // substitute language alias to known modes to support syntax highlighting\n        var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n\n        if (enteringEmbeddedModeId) {\n          enteringEmbeddedMode = enteringEmbeddedModeId;\n        }\n\n        var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n\n        if (pos < lineLength) {\n          // there is content from the embedded mode on this line\n          var restOfLine = line.substr(pos);\n          return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedModeData_1);\n        }\n      }\n    }\n\n    return MonarchLineStateFactory.create(stack, embeddedModeData);\n  };\n\n  MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {\n    var nestedModeId = this._locateMode(mimetypeOrModeId);\n\n    if (nestedModeId) {\n      var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (tokenizationSupport) {\n        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n      }\n    }\n\n    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n  };\n\n  MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {\n    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n      return null;\n    }\n\n    if (mimetypeOrModeId === this._modeId) {\n      // embedding myself...\n      return mimetypeOrModeId;\n    }\n\n    var modeId = this._modeService.getModeId(mimetypeOrModeId);\n\n    if (modeId) {\n      // Fire mode loading event\n      this._modeService.triggerMode(modeId);\n\n      this._embeddedModes[modeId] = true;\n    }\n\n    return modeId;\n  };\n\n  return MonarchTokenizer;\n}();\n\nexport { MonarchTokenizer };\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\n\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n\n  matched = monarchCommon.fixCase(lexer, matched);\n  var brackets = lexer.brackets;\n\n  for (var _i = 0, brackets_1 = brackets; _i < brackets_1.length; _i++) {\n    var bracket = brackets_1[_i];\n\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1\n        /* Open */\n\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1\n        /* Close */\n\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"names":["Token","TokenizationResult","TokenizationResult2","modes","NULL_MODE_ID","NULL_STATE","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","_INSTANCE","prototype","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedModeData","modeId","clone","stateClone","MonarchLineStateFactory","stack","embeddedModeData","MonarchLineState","embeddedModeDataClone","MonarchClassicTokensCollector","_tokens","_language","_lastTokenType","_lastTokenLanguage","enterMode","startOffset","emit","type","nestedModeTokenize","embeddedModeLine","offsetDelta","nestedModeId","embeddedModeState","nestedModeTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","concat","tokens","endState","finalize","MonarchModernTokensCollector","modeService","theme","_modeService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","getLanguageIdentifier","id","metadata","match","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","tokenize2","MonarchTokenizer","standaloneThemeService","lexer","_this","_standaloneThemeService","_modeId","_lexer","_embeddedModes","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","len","changedLanguages","language","fire","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","tokenizationSupportPromise","getPromise","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedModeOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","_i","rules_1","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","RegExp","ignoreCase","search","matchOnlyAtLineStart","nestedEndState","nestedModeLine","substring","restOfTheLine","_safeRuleName","name","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedMode","groupEntry","shift","restOfLine","rules_2","rule_1","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","token","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","languageId","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","enteringEmbeddedModeId","getModeIdForLanguageName","embeddedModeData_1","_getNestedEmbeddedModeData","mimetypeOrModeId","_locateMode","isRegisteredMode","getModeId","triggerMode","fixCase","brackets","brackets_1","open","bracketType","close","createTokenizationSupport"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\r\nimport * as modes from '../../../common/modes.js';\r\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\r\nimport * as monarchCommon from './monarchCommon.js';\r\nvar CACHE_STACK_DEPTH = 5;\r\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\r\nvar MonarchStackElementFactory = /** @class */ (function () {\r\n    function MonarchStackElementFactory(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    MonarchStackElementFactory.create = function (parent, state) {\r\n        return this._INSTANCE.create(parent, state);\r\n    };\r\n    MonarchStackElementFactory.prototype.create = function (parent, state) {\r\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchStackElement(parent, state);\r\n        }\r\n        var stackElementId = MonarchStackElement.getStackElementId(parent);\r\n        if (stackElementId.length > 0) {\r\n            stackElementId += '|';\r\n        }\r\n        stackElementId += state;\r\n        var result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchStackElement(parent, state);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    };\r\n    MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\r\n    return MonarchStackElementFactory;\r\n}());\r\nvar MonarchStackElement = /** @class */ (function () {\r\n    function MonarchStackElement(parent, state) {\r\n        this.parent = parent;\r\n        this.state = state;\r\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\r\n    }\r\n    MonarchStackElement.getStackElementId = function (element) {\r\n        var result = '';\r\n        while (element !== null) {\r\n            if (result.length > 0) {\r\n                result += '|';\r\n            }\r\n            result += element.state;\r\n            element = element.parent;\r\n        }\r\n        return result;\r\n    };\r\n    MonarchStackElement._equals = function (a, b) {\r\n        while (a !== null && b !== null) {\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n            if (a.state !== b.state) {\r\n                return false;\r\n            }\r\n            a = a.parent;\r\n            b = b.parent;\r\n        }\r\n        if (a === null && b === null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    MonarchStackElement.prototype.equals = function (other) {\r\n        return MonarchStackElement._equals(this, other);\r\n    };\r\n    MonarchStackElement.prototype.push = function (state) {\r\n        return MonarchStackElementFactory.create(this, state);\r\n    };\r\n    MonarchStackElement.prototype.pop = function () {\r\n        return this.parent;\r\n    };\r\n    MonarchStackElement.prototype.popall = function () {\r\n        var result = this;\r\n        while (result.parent) {\r\n            result = result.parent;\r\n        }\r\n        return result;\r\n    };\r\n    MonarchStackElement.prototype.switchTo = function (state) {\r\n        return MonarchStackElementFactory.create(this.parent, state);\r\n    };\r\n    return MonarchStackElement;\r\n}());\r\nvar EmbeddedModeData = /** @class */ (function () {\r\n    function EmbeddedModeData(modeId, state) {\r\n        this.modeId = modeId;\r\n        this.state = state;\r\n    }\r\n    EmbeddedModeData.prototype.equals = function (other) {\r\n        return (this.modeId === other.modeId\r\n            && this.state.equals(other.state));\r\n    };\r\n    EmbeddedModeData.prototype.clone = function () {\r\n        var stateClone = this.state.clone();\r\n        // save an object\r\n        if (stateClone === this.state) {\r\n            return this;\r\n        }\r\n        return new EmbeddedModeData(this.modeId, this.state);\r\n    };\r\n    return EmbeddedModeData;\r\n}());\r\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\r\nvar MonarchLineStateFactory = /** @class */ (function () {\r\n    function MonarchLineStateFactory(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    MonarchLineStateFactory.create = function (stack, embeddedModeData) {\r\n        return this._INSTANCE.create(stack, embeddedModeData);\r\n    };\r\n    MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {\r\n        if (embeddedModeData !== null) {\r\n            // no caching when embedding\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        var stackElementId = MonarchStackElement.getStackElementId(stack);\r\n        var result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchLineState(stack, null);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    };\r\n    MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\r\n    return MonarchLineStateFactory;\r\n}());\r\nvar MonarchLineState = /** @class */ (function () {\r\n    function MonarchLineState(stack, embeddedModeData) {\r\n        this.stack = stack;\r\n        this.embeddedModeData = embeddedModeData;\r\n    }\r\n    MonarchLineState.prototype.clone = function () {\r\n        var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\r\n        // save an object\r\n        if (embeddedModeDataClone === this.embeddedModeData) {\r\n            return this;\r\n        }\r\n        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\r\n    };\r\n    MonarchLineState.prototype.equals = function (other) {\r\n        if (!(other instanceof MonarchLineState)) {\r\n            return false;\r\n        }\r\n        if (!this.stack.equals(other.stack)) {\r\n            return false;\r\n        }\r\n        if (this.embeddedModeData === null && other.embeddedModeData === null) {\r\n            return true;\r\n        }\r\n        if (this.embeddedModeData === null || other.embeddedModeData === null) {\r\n            return false;\r\n        }\r\n        return this.embeddedModeData.equals(other.embeddedModeData);\r\n    };\r\n    return MonarchLineState;\r\n}());\r\nvar MonarchClassicTokensCollector = /** @class */ (function () {\r\n    function MonarchClassicTokensCollector() {\r\n        this._tokens = [];\r\n        this._language = null;\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n    }\r\n    MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {\r\n        this._language = modeId;\r\n    };\r\n    MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {\r\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\r\n            return;\r\n        }\r\n        this._lastTokenType = type;\r\n        this._lastTokenLanguage = this._language;\r\n        this._tokens.push(new Token(startOffset, type, this._language));\r\n    };\r\n    MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\r\n        var nestedModeId = embeddedModeData.modeId;\r\n        var embeddedModeState = embeddedModeData.state;\r\n        var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\r\n        this._tokens = this._tokens.concat(nestedResult.tokens);\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n        this._language = null;\r\n        return nestedResult.endState;\r\n    };\r\n    MonarchClassicTokensCollector.prototype.finalize = function (endState) {\r\n        return new TokenizationResult(this._tokens, endState);\r\n    };\r\n    return MonarchClassicTokensCollector;\r\n}());\r\nvar MonarchModernTokensCollector = /** @class */ (function () {\r\n    function MonarchModernTokensCollector(modeService, theme) {\r\n        this._modeService = modeService;\r\n        this._theme = theme;\r\n        this._prependTokens = null;\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0 /* Null */;\r\n        this._lastTokenMetadata = 0;\r\n    }\r\n    MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {\r\n        this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\r\n    };\r\n    MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {\r\n        var metadata = this._theme.match(this._currentLanguageId, type);\r\n        if (this._lastTokenMetadata === metadata) {\r\n            return;\r\n        }\r\n        this._lastTokenMetadata = metadata;\r\n        this._tokens.push(startOffset);\r\n        this._tokens.push(metadata);\r\n    };\r\n    MonarchModernTokensCollector._merge = function (a, b, c) {\r\n        var aLen = (a !== null ? a.length : 0);\r\n        var bLen = b.length;\r\n        var cLen = (c !== null ? c.length : 0);\r\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\r\n            return new Uint32Array(0);\r\n        }\r\n        if (aLen === 0 && bLen === 0) {\r\n            return c;\r\n        }\r\n        if (bLen === 0 && cLen === 0) {\r\n            return a;\r\n        }\r\n        var result = new Uint32Array(aLen + bLen + cLen);\r\n        if (a !== null) {\r\n            result.set(a);\r\n        }\r\n        for (var i = 0; i < bLen; i++) {\r\n            result[aLen + i] = b[i];\r\n        }\r\n        if (c !== null) {\r\n            result.set(c, aLen + bLen);\r\n        }\r\n        return result;\r\n    };\r\n    MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\r\n        var nestedModeId = embeddedModeData.modeId;\r\n        var embeddedModeState = embeddedModeData.state;\r\n        var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\r\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0;\r\n        this._lastTokenMetadata = 0;\r\n        return nestedResult.endState;\r\n    };\r\n    MonarchModernTokensCollector.prototype.finalize = function (endState) {\r\n        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\r\n    };\r\n    return MonarchModernTokensCollector;\r\n}());\r\nvar MonarchTokenizer = /** @class */ (function () {\r\n    function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\r\n        var _this = this;\r\n        this._modeService = modeService;\r\n        this._standaloneThemeService = standaloneThemeService;\r\n        this._modeId = modeId;\r\n        this._lexer = lexer;\r\n        this._embeddedModes = Object.create(null);\r\n        this.embeddedLoaded = Promise.resolve(undefined);\r\n        // Set up listening for embedded modes\r\n        var emitting = false;\r\n        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\r\n            if (emitting) {\r\n                return;\r\n            }\r\n            var isOneOfMyEmbeddedModes = false;\r\n            for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\r\n                var language = e.changedLanguages[i];\r\n                if (_this._embeddedModes[language]) {\r\n                    isOneOfMyEmbeddedModes = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isOneOfMyEmbeddedModes) {\r\n                emitting = true;\r\n                modes.TokenizationRegistry.fire([_this._modeId]);\r\n                emitting = false;\r\n            }\r\n        });\r\n    }\r\n    MonarchTokenizer.prototype.dispose = function () {\r\n        this._tokenizationRegistryListener.dispose();\r\n    };\r\n    MonarchTokenizer.prototype.getLoadStatus = function () {\r\n        var promises = [];\r\n        for (var nestedModeId in this._embeddedModes) {\r\n            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                // The nested mode is already loaded\r\n                if (tokenizationSupport instanceof MonarchTokenizer) {\r\n                    var nestedModeStatus = tokenizationSupport.getLoadStatus();\r\n                    if (nestedModeStatus.loaded === false) {\r\n                        promises.push(nestedModeStatus.promise);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\r\n            if (tokenizationSupportPromise) {\r\n                // The nested mode is in the process of being loaded\r\n                promises.push(tokenizationSupportPromise);\r\n            }\r\n        }\r\n        if (promises.length === 0) {\r\n            return {\r\n                loaded: true\r\n            };\r\n        }\r\n        return {\r\n            loaded: false,\r\n            promise: Promise.all(promises).then(function (_) { return undefined; })\r\n        };\r\n    };\r\n    MonarchTokenizer.prototype.getInitialState = function () {\r\n        var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\r\n        return MonarchLineStateFactory.create(rootState, null);\r\n    };\r\n    MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {\r\n        var tokensCollector = new MonarchClassicTokensCollector();\r\n        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    };\r\n    MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {\r\n        var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\r\n        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    };\r\n    MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {\r\n        if (lineState.embeddedModeData) {\r\n            return this._nestedTokenize(line, lineState, offsetDelta, collector);\r\n        }\r\n        else {\r\n            return this._myTokenize(line, lineState, offsetDelta, collector);\r\n        }\r\n    };\r\n    MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {\r\n        var rules = this._lexer.tokenizer[state.stack.state];\r\n        if (!rules) {\r\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\r\n            if (!rules) {\r\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\r\n            }\r\n        }\r\n        var popOffset = -1;\r\n        var hasEmbeddedPopRule = false;\r\n        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\r\n            var rule = rules_1[_i];\r\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\r\n                continue;\r\n            }\r\n            hasEmbeddedPopRule = true;\r\n            var regex = rule.regex;\r\n            var regexSource = rule.regex.source;\r\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\r\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\r\n            }\r\n            var result = line.search(regex);\r\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\r\n                continue;\r\n            }\r\n            if (popOffset === -1 || result < popOffset) {\r\n                popOffset = result;\r\n            }\r\n        }\r\n        if (!hasEmbeddedPopRule) {\r\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\r\n        }\r\n        return popOffset;\r\n    };\r\n    MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {\r\n        var popOffset = this._findLeavingNestedModeOffset(line, lineState);\r\n        if (popOffset === -1) {\r\n            // tokenization will not leave nested mode\r\n            var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\r\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\r\n        }\r\n        var nestedModeLine = line.substring(0, popOffset);\r\n        if (nestedModeLine.length > 0) {\r\n            // tokenize with the nested mode\r\n            tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\r\n        }\r\n        var restOfTheLine = line.substring(popOffset);\r\n        return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\r\n    };\r\n    MonarchTokenizer.prototype._safeRuleName = function (rule) {\r\n        if (rule) {\r\n            return rule.name;\r\n        }\r\n        return '(unknown)';\r\n    };\r\n    MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {\r\n        tokensCollector.enterMode(offsetDelta, this._modeId);\r\n        var lineLength = line.length;\r\n        var embeddedModeData = lineState.embeddedModeData;\r\n        var stack = lineState.stack;\r\n        var pos = 0;\r\n        var groupMatching = null;\r\n        // See https://github.com/Microsoft/monaco-editor/issues/1235:\r\n        // Evaluate rules at least once for an empty line\r\n        var forceEvaluation = true;\r\n        while (forceEvaluation || pos < lineLength) {\r\n            var pos0 = pos;\r\n            var stackLen0 = stack.depth;\r\n            var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\r\n            var state = stack.state;\r\n            var matches = null;\r\n            var matched = null;\r\n            var action = null;\r\n            var rule = null;\r\n            var enteringEmbeddedMode = null;\r\n            // check if we need to process group matches first\r\n            if (groupMatching) {\r\n                matches = groupMatching.matches;\r\n                var groupEntry = groupMatching.groups.shift();\r\n                matched = groupEntry.matched;\r\n                action = groupEntry.action;\r\n                rule = groupMatching.rule;\r\n                // cleanup if necessary\r\n                if (groupMatching.groups.length === 0) {\r\n                    groupMatching = null;\r\n                }\r\n            }\r\n            else {\r\n                // otherwise we match on the token stream\r\n                if (!forceEvaluation && pos >= lineLength) {\r\n                    // nothing to do\r\n                    break;\r\n                }\r\n                forceEvaluation = false;\r\n                // get the rules for this state\r\n                var rules = this._lexer.tokenizer[state];\r\n                if (!rules) {\r\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\r\n                    if (!rules) {\r\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\r\n                    }\r\n                }\r\n                // try each rule until we match\r\n                var restOfLine = line.substr(pos);\r\n                for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {\r\n                    var rule_1 = rules_2[_i];\r\n                    if (pos === 0 || !rule_1.matchOnlyAtLineStart) {\r\n                        matches = restOfLine.match(rule_1.regex);\r\n                        if (matches) {\r\n                            matched = matches[0];\r\n                            action = rule_1.action;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // We matched 'rule' with 'matches' and 'action'\r\n            if (!matches) {\r\n                matches = [''];\r\n                matched = '';\r\n            }\r\n            if (!action) {\r\n                // bad: we didn't match anything, and there is no action to take\r\n                // we need to advance the stream or we get progress trouble\r\n                if (pos < lineLength) {\r\n                    matches = [line.charAt(pos)];\r\n                    matched = matches[0];\r\n                }\r\n                action = this._lexer.defaultToken;\r\n            }\r\n            if (matched === null) {\r\n                // should never happen, needed for strict null checking\r\n                break;\r\n            }\r\n            // advance stream\r\n            pos += matched.length;\r\n            // maybe call action function (used for 'cases')\r\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\r\n                action = action.test(matched, matches, state, pos === lineLength);\r\n            }\r\n            var result = null;\r\n            // set the result: either a string or an array of actions\r\n            if (typeof action === 'string' || Array.isArray(action)) {\r\n                result = action;\r\n            }\r\n            else if (action.group) {\r\n                result = action.group;\r\n            }\r\n            else if (action.token !== null && action.token !== undefined) {\r\n                // do $n replacements?\r\n                if (action.tokenSubst) {\r\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\r\n                }\r\n                else {\r\n                    result = action.token;\r\n                }\r\n                // enter embedded mode?\r\n                if (action.nextEmbedded) {\r\n                    if (action.nextEmbedded === '@pop') {\r\n                        if (!embeddedModeData) {\r\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\r\n                        }\r\n                        embeddedModeData = null;\r\n                    }\r\n                    else if (embeddedModeData) {\r\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\r\n                    }\r\n                    else {\r\n                        enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\r\n                    }\r\n                }\r\n                // state transformations\r\n                if (action.goBack) { // back up the stream..\r\n                    pos = Math.max(0, pos - action.goBack);\r\n                }\r\n                if (action.switchTo && typeof action.switchTo === 'string') {\r\n                    var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\r\n                    if (nextState[0] === '@') {\r\n                        nextState = nextState.substr(1); // peel off starting '@'\r\n                    }\r\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                    else {\r\n                        stack = stack.switchTo(nextState);\r\n                    }\r\n                }\r\n                else if (action.transform && typeof action.transform === 'function') {\r\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\r\n                }\r\n                else if (action.next) {\r\n                    if (action.next === '@push') {\r\n                        if (stack.depth >= this._lexer.maxStack) {\r\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\r\n                                stack.state + ',' + stack.parent.state + ',...]');\r\n                        }\r\n                        else {\r\n                            stack = stack.push(state);\r\n                        }\r\n                    }\r\n                    else if (action.next === '@pop') {\r\n                        if (stack.depth <= 1) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.pop();\r\n                        }\r\n                    }\r\n                    else if (action.next === '@popall') {\r\n                        stack = stack.popall();\r\n                    }\r\n                    else {\r\n                        var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\r\n                        if (nextState[0] === '@') {\r\n                            nextState = nextState.substr(1); // peel off starting '@'\r\n                        }\r\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.push(nextState);\r\n                        }\r\n                    }\r\n                }\r\n                if (action.log && typeof (action.log) === 'string') {\r\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\r\n                }\r\n            }\r\n            // check result\r\n            if (result === null) {\r\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\r\n            }\r\n            // is the result a group match?\r\n            if (Array.isArray(result)) {\r\n                if (groupMatching && groupMatching.groups.length > 0) {\r\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\r\n                }\r\n                if (matches.length !== result.length + 1) {\r\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                var totalLen = 0;\r\n                for (var i = 1; i < matches.length; i++) {\r\n                    totalLen += matches[i].length;\r\n                }\r\n                if (totalLen !== matched.length) {\r\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                groupMatching = {\r\n                    rule: rule,\r\n                    matches: matches,\r\n                    groups: []\r\n                };\r\n                for (var i = 0; i < result.length; i++) {\r\n                    groupMatching.groups[i] = {\r\n                        action: result[i],\r\n                        matched: matches[i + 1]\r\n                    };\r\n                }\r\n                pos -= matched.length;\r\n                // call recursively to initiate first result match\r\n                continue;\r\n            }\r\n            else {\r\n                // regular result\r\n                // check for '@rematch'\r\n                if (result === '@rematch') {\r\n                    pos -= matched.length;\r\n                    matched = ''; // better set the next state too..\r\n                    matches = null;\r\n                    result = '';\r\n                }\r\n                // check progress\r\n                if (matched.length === 0) {\r\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                }\r\n                // return the result (and check for brace matching)\r\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\r\n                var tokenType = null;\r\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\r\n                    var rest = result.substr('@brackets'.length);\r\n                    var bracket = findBracket(this._lexer, matched);\r\n                    if (!bracket) {\r\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\r\n                    }\r\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\r\n                }\r\n                else {\r\n                    var token = (result === '' ? '' : result + this._lexer.tokenPostfix);\r\n                    tokenType = monarchCommon.sanitize(token);\r\n                }\r\n                tokensCollector.emit(pos0 + offsetDelta, tokenType);\r\n            }\r\n            if (enteringEmbeddedMode !== null) {\r\n                // substitute language alias to known modes to support syntax highlighting\r\n                var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\r\n                if (enteringEmbeddedModeId) {\r\n                    enteringEmbeddedMode = enteringEmbeddedModeId;\r\n                }\r\n                var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\r\n                if (pos < lineLength) {\r\n                    // there is content from the embedded mode on this line\r\n                    var restOfLine = line.substr(pos);\r\n                    return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);\r\n                }\r\n                else {\r\n                    return MonarchLineStateFactory.create(stack, embeddedModeData_1);\r\n                }\r\n            }\r\n        }\r\n        return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n    };\r\n    MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {\r\n        var nestedModeId = this._locateMode(mimetypeOrModeId);\r\n        if (nestedModeId) {\r\n            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\r\n            }\r\n        }\r\n        return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\r\n    };\r\n    MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {\r\n        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\r\n            return null;\r\n        }\r\n        if (mimetypeOrModeId === this._modeId) {\r\n            // embedding myself...\r\n            return mimetypeOrModeId;\r\n        }\r\n        var modeId = this._modeService.getModeId(mimetypeOrModeId);\r\n        if (modeId) {\r\n            // Fire mode loading event\r\n            this._modeService.triggerMode(modeId);\r\n            this._embeddedModes[modeId] = true;\r\n        }\r\n        return modeId;\r\n    };\r\n    return MonarchTokenizer;\r\n}());\r\nexport { MonarchTokenizer };\r\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\r\nfunction findBracket(lexer, matched) {\r\n    if (!matched) {\r\n        return null;\r\n    }\r\n    matched = monarchCommon.fixCase(lexer, matched);\r\n    var brackets = lexer.brackets;\r\n    for (var _i = 0, brackets_1 = brackets; _i < brackets_1.length; _i++) {\r\n        var bracket = brackets_1[_i];\r\n        if (bracket.open === matched) {\r\n            return { token: bracket.token, bracketType: 1 /* Open */ };\r\n        }\r\n        else if (bracket.close === matched) {\r\n            return { token: bracket.token, bracketType: -1 /* Close */ };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\r\n    return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}