{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n\n(function (ParseOptions) {\n  ParseOptions.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\n\n\nexport function getLocation(text, position) {\n  var segments = []; // strings or numbers\n\n  var earlyReturnException = new Object();\n  var previousNode = undefined;\n  var previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: undefined\n  };\n  var isAtPropertyKey = false;\n\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = undefined;\n    previousNode = previousNodeInst;\n  }\n\n  try {\n    visit(text, {\n      onObjectBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n      onObjectProperty: function (name, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onArrayBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.push(0);\n      },\n      onArrayEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onLiteralValue: function (value, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(value, offset, length, getNodeType(value));\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: function (sep, offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = undefined;\n        } else if (sep === ',') {\n          var last = segments[segments.length - 1];\n\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n\n          previousNode = undefined;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n\n  return {\n    path: segments,\n    previousNode: previousNode,\n    isAtPropertyKey: isAtPropertyKey,\n    matches: function (pattern) {\n      var k = 0;\n\n      for (var i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\n\nexport function parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n\n  var visitor = {\n    onObjectBegin: function () {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function (name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function () {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport function parseTree(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: undefined\n  }; // artificial root\n\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n\n  var visitor = {\n    onObjectBegin: function (offset) {\n      currentParent = onValue({\n        type: 'object',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: function (name, offset, length) {\n      currentParent = onValue({\n        type: 'property',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset: offset,\n        length: length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: function (offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: function (offset, length) {\n      currentParent = onValue({\n        type: 'array',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: function (offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: function (value, offset, length) {\n      onValue({\n        type: getNodeType(value),\n        offset: offset,\n        length: length,\n        parent: currentParent,\n        value: value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: function (sep, offset, length) {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  var result = currentParent.children[0];\n\n  if (result) {\n    delete result.parent;\n  }\n\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return undefined;\n  }\n\n  var node = root;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var segment = path_1[_i];\n\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return undefined;\n      }\n\n      var found = false;\n\n      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n        var propertyNode = _b[_a];\n\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return undefined;\n      }\n    } else {\n      var index = segment;\n\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return undefined;\n      }\n\n      node = node.children[index];\n    }\n  }\n\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n\n  var path = getNodePath(node.parent);\n\n  if (node.parent.type === 'property') {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    var index = node.parent.children.indexOf(node);\n\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n\n    case 'object':\n      var obj = Object.create(null);\n\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var valueNode = prop.children[1];\n\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n\n      return obj;\n\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n\n    default:\n      return undefined;\n  }\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n\n        if (item) {\n          return item;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport function visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var _scanner = createScanner(text, false);\n\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n      onObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n      onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n      onArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n      onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n      onLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n      onSeparator = toOneArgVisit(visitor.onSeparator),\n      onComment = toNoArgVisit(visitor.onComment),\n      onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options && options.disallowComments;\n  var allowTrailingComma = options && options.allowTrailingComma;\n\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n\n      switch (_scanner.getTokenError()) {\n        case 4\n        /* InvalidUnicode */\n        :\n          handleError(14\n          /* InvalidUnicode */\n          );\n          break;\n\n        case 5\n        /* InvalidEscapeCharacter */\n        :\n          handleError(15\n          /* InvalidEscapeCharacter */\n          );\n          break;\n\n        case 3\n        /* UnexpectedEndOfNumber */\n        :\n          handleError(13\n          /* UnexpectedEndOfNumber */\n          );\n          break;\n\n        case 1\n        /* UnexpectedEndOfComment */\n        :\n          if (!disallowComments) {\n            handleError(11\n            /* UnexpectedEndOfComment */\n            );\n          }\n\n          break;\n\n        case 2\n        /* UnexpectedEndOfString */\n        :\n          handleError(12\n          /* UnexpectedEndOfString */\n          );\n          break;\n\n        case 6\n        /* InvalidCharacter */\n        :\n          handleError(16\n          /* InvalidCharacter */\n          );\n          break;\n      }\n\n      switch (token) {\n        case 12\n        /* LineCommentTrivia */\n        :\n        case 13\n        /* BlockCommentTrivia */\n        :\n          if (disallowComments) {\n            handleError(10\n            /* InvalidCommentToken */\n            );\n          } else {\n            onComment();\n          }\n\n          break;\n\n        case 16\n        /* Unknown */\n        :\n          handleError(1\n          /* InvalidSymbol */\n          );\n          break;\n\n        case 15\n        /* Trivia */\n        :\n        case 14\n        /* LineBreakTrivia */\n        :\n          break;\n\n        default:\n          return token;\n      }\n    }\n  }\n\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n\n    onError(error);\n\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token = _scanner.getToken();\n\n      while (token !== 17\n      /* EOF */\n      ) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n\n        token = scanNext();\n      }\n    }\n  }\n\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value);\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11\n      /* NumericLiteral */\n      :\n        var value = 0;\n\n        try {\n          value = JSON.parse(_scanner.getTokenValue());\n\n          if (typeof value !== 'number') {\n            handleError(2\n            /* InvalidNumberFormat */\n            );\n            value = 0;\n          }\n        } catch (e) {\n          handleError(2\n          /* InvalidNumberFormat */\n          );\n        }\n\n        onLiteralValue(value);\n        break;\n\n      case 7\n      /* NullKeyword */\n      :\n        onLiteralValue(null);\n        break;\n\n      case 8\n      /* TrueKeyword */\n      :\n        onLiteralValue(true);\n        break;\n\n      case 9\n      /* FalseKeyword */\n      :\n        onLiteralValue(false);\n        break;\n\n      default:\n        return false;\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseProperty() {\n    if (_scanner.getToken() !== 10\n    /* StringLiteral */\n    ) {\n        handleError(3\n        /* PropertyNameExpected */\n        , [], [2\n        /* CloseBraceToken */\n        , 5\n        /* CommaToken */\n        ]);\n        return false;\n      }\n\n    parseString(false);\n\n    if (_scanner.getToken() === 6\n    /* ColonToken */\n    ) {\n        onSeparator(':');\n        scanNext(); // consume colon\n\n        if (!parseValue()) {\n          handleError(4\n          /* ValueExpected */\n          , [], [2\n          /* CloseBraceToken */\n          , 5\n          /* CommaToken */\n          ]);\n        }\n      } else {\n      handleError(5\n      /* ColonExpected */\n      , [], [2\n      /* CloseBraceToken */\n      , 5\n      /* CommaToken */\n      ]);\n    }\n\n    return true;\n  }\n\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 2\n    /* CloseBraceToken */\n    && _scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            handleError(4\n            /* ValueExpected */\n            , [], []);\n          }\n\n          onSeparator(',');\n          scanNext(); // consume comma\n\n          if (_scanner.getToken() === 2\n          /* CloseBraceToken */\n          && allowTrailingComma) {\n            break;\n          }\n        } else if (needsComma) {\n        handleError(6\n        /* CommaExpected */\n        , [], []);\n      }\n\n      if (!parseProperty()) {\n        handleError(4\n        /* ValueExpected */\n        , [], [2\n        /* CloseBraceToken */\n        , 5\n        /* CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onObjectEnd();\n\n    if (_scanner.getToken() !== 2\n    /* CloseBraceToken */\n    ) {\n        handleError(7\n        /* CloseBraceExpected */\n        , [2\n        /* CloseBraceToken */\n        ], []);\n      } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 4\n    /* CloseBracketToken */\n    && _scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            handleError(4\n            /* ValueExpected */\n            , [], []);\n          }\n\n          onSeparator(',');\n          scanNext(); // consume comma\n\n          if (_scanner.getToken() === 4\n          /* CloseBracketToken */\n          && allowTrailingComma) {\n            break;\n          }\n        } else if (needsComma) {\n        handleError(6\n        /* CommaExpected */\n        , [], []);\n      }\n\n      if (!parseValue()) {\n        handleError(4\n        /* ValueExpected */\n        , [], [4\n        /* CloseBracketToken */\n        , 5\n        /* CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onArrayEnd();\n\n    if (_scanner.getToken() !== 4\n    /* CloseBracketToken */\n    ) {\n        handleError(8\n        /* CloseBracketExpected */\n        , [4\n        /* CloseBracketToken */\n        ], []);\n      } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3\n      /* OpenBracketToken */\n      :\n        return parseArray();\n\n      case 1\n      /* OpenBraceToken */\n      :\n        return parseObject();\n\n      case 10\n      /* StringLiteral */\n      :\n        return parseString(true);\n\n      default:\n        return parseLiteral();\n    }\n  }\n\n  scanNext();\n\n  if (_scanner.getToken() === 17\n  /* EOF */\n  ) {\n      if (options.allowEmptyContent) {\n        return true;\n      }\n\n      handleError(4\n      /* ValueExpected */\n      , [], []);\n      return false;\n    }\n\n  if (!parseValue()) {\n    handleError(4\n    /* ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (_scanner.getToken() !== 17\n  /* EOF */\n  ) {\n      handleError(9\n      /* EndOfFileExpected */\n      , [], []);\n    }\n\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport function stripComments(text, replaceCh) {\n  var _scanner = createScanner(text),\n      parts = [],\n      kind,\n      offset = 0,\n      pos;\n\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n\n    switch (kind) {\n      case 12\n      /* LineCommentTrivia */\n      :\n      case 13\n      /* BlockCommentTrivia */\n      :\n      case 17\n      /* EOF */\n      :\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n\n        if (replaceCh !== undefined) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17\n  /* EOF */\n  );\n\n  return parts.join('');\n}\nexport function getNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n\n    case 'number':\n      return 'number';\n\n    case 'string':\n      return 'string';\n\n    case 'object':\n      {\n        if (!value) {\n          return 'null';\n        } else if (Array.isArray(value)) {\n          return 'array';\n        }\n\n        return 'object';\n      }\n\n    default:\n      return 'null';\n  }\n}","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js"],"names":["createScanner","ParseOptions","DEFAULT","allowTrailingComma","getLocation","text","position","segments","earlyReturnException","Object","previousNode","undefined","previousNodeInst","value","offset","length","type","parent","isAtPropertyKey","setPreviousNode","colonOffset","visit","onObjectBegin","push","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","getNodeType","onSeparator","sep","last","e","path","matches","pattern","k","i","parse","errors","options","currentProperty","currentParent","previousParents","onValue","Array","isArray","visitor","object","array","onError","error","parseTree","children","ensurePropertyComplete","endOffset","valueNode","result","findNodeAtLocation","root","node","_i","path_1","segment","found","_a","_b","propertyNode","index","getNodePath","key","indexOf","getNodeValue","map","obj","create","prop","contains","includeRightBound","findNodeAtOffset","item","_scanner","toNoArgVisit","visitFunction","getTokenOffset","getTokenLength","getTokenStartLine","getTokenStartCharacter","toOneArgVisit","arg","onComment","disallowComments","scanNext","token","scan","getTokenError","handleError","skipUntilAfter","skipUntil","getToken","parseString","isValue","getTokenValue","parseLiteral","JSON","parseProperty","parseValue","parseObject","needsComma","parseArray","allowEmptyContent","stripComments","replaceCh","parts","kind","pos","getPosition","substring","replace","join"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 /* InvalidNumberFormat */);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 /* InvalidNumberFormat */);\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n"]},"metadata":{},"sourceType":"module"}