{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\n\nvar LineTokens =\n/** @class */\nfunction () {\n  function LineTokens(tokens, text) {\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n  }\n\n  LineTokens.prototype.equals = function (other) {\n    if (other instanceof LineTokens) {\n      return this.slicedEquals(other, 0, this._tokensCount);\n    }\n\n    return false;\n  };\n\n  LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {\n    if (this._text !== other._text) {\n      return false;\n    }\n\n    if (this._tokensCount !== other._tokensCount) {\n      return false;\n    }\n\n    var from = sliceFromTokenIndex << 1;\n    var to = from + (sliceTokenCount << 1);\n\n    for (var i = from; i < to; i++) {\n      if (this._tokens[i] !== other._tokens[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  LineTokens.prototype.getLineContent = function () {\n    return this._text;\n  };\n\n  LineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n\n  LineTokens.prototype.getStartOffset = function (tokenIndex) {\n    if (tokenIndex > 0) {\n      return this._tokens[tokenIndex - 1 << 1];\n    }\n\n    return 0;\n  };\n\n  LineTokens.prototype.getMetadata = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return metadata;\n  };\n\n  LineTokens.prototype.getLanguageId = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getLanguageId(metadata);\n  };\n\n  LineTokens.prototype.getStandardTokenType = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getTokenType(metadata);\n  };\n\n  LineTokens.prototype.getForeground = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getForeground(metadata);\n  };\n\n  LineTokens.prototype.getClassName = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getClassNameFromMetadata(metadata);\n  };\n\n  LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n  };\n\n  LineTokens.prototype.getEndOffset = function (tokenIndex) {\n    return this._tokens[tokenIndex << 1];\n  };\n  /**\r\n   * Find the token containing offset `offset`.\r\n   * @param offset The search offset\r\n   * @return The index of the token containing the offset.\r\n   */\n\n\n  LineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return LineTokens.findIndexInTokensArray(this._tokens, offset);\n  };\n\n  LineTokens.prototype.inflate = function () {\n    return this;\n  };\n\n  LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {\n    return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n  };\n\n  LineTokens.convertToEndOffset = function (tokens, lineTextLength) {\n    var tokenCount = tokens.length >>> 1;\n    var lastTokenIndex = tokenCount - 1;\n\n    for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n    }\n\n    tokens[lastTokenIndex << 1] = lineTextLength;\n  };\n\n  LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {\n    if (tokens.length <= 2) {\n      return 0;\n    }\n\n    var low = 0;\n    var high = (tokens.length >>> 1) - 1;\n\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      var endOffset = tokens[mid << 1];\n\n      if (endOffset === desiredIndex) {\n        return mid + 1;\n      } else if (endOffset < desiredIndex) {\n        low = mid + 1;\n      } else if (endOffset > desiredIndex) {\n        high = mid;\n      }\n    }\n\n    return low;\n  };\n\n  return LineTokens;\n}();\n\nexport { LineTokens };\n\nvar SlicedLineTokens =\n/** @class */\nfunction () {\n  function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n\n    for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      var tokenStartOffset = source.getStartOffset(i);\n\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n\n      this._tokensCount++;\n    }\n  }\n\n  SlicedLineTokens.prototype.equals = function (other) {\n    if (other instanceof SlicedLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n\n    return false;\n  };\n\n  SlicedLineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n\n  SlicedLineTokens.prototype.getForeground = function (tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  };\n\n  SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {\n    var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  };\n\n  SlicedLineTokens.prototype.getClassName = function (tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  };\n\n  SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  };\n\n  SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  };\n\n  return SlicedLineTokens;\n}();\n\nexport { SlicedLineTokens };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js"],"names":["TokenMetadata","LineTokens","tokens","text","_tokens","_tokensCount","length","_text","prototype","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","metadata","getLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SlicedLineTokens","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TokenMetadata } from '../modes.js';\r\nvar LineTokens = /** @class */ (function () {\r\n    function LineTokens(tokens, text) {\r\n        this._tokens = tokens;\r\n        this._tokensCount = (this._tokens.length >>> 1);\r\n        this._text = text;\r\n    }\r\n    LineTokens.prototype.equals = function (other) {\r\n        if (other instanceof LineTokens) {\r\n            return this.slicedEquals(other, 0, this._tokensCount);\r\n        }\r\n        return false;\r\n    };\r\n    LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {\r\n        if (this._text !== other._text) {\r\n            return false;\r\n        }\r\n        if (this._tokensCount !== other._tokensCount) {\r\n            return false;\r\n        }\r\n        var from = (sliceFromTokenIndex << 1);\r\n        var to = from + (sliceTokenCount << 1);\r\n        for (var i = from; i < to; i++) {\r\n            if (this._tokens[i] !== other._tokens[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    LineTokens.prototype.getLineContent = function () {\r\n        return this._text;\r\n    };\r\n    LineTokens.prototype.getCount = function () {\r\n        return this._tokensCount;\r\n    };\r\n    LineTokens.prototype.getStartOffset = function (tokenIndex) {\r\n        if (tokenIndex > 0) {\r\n            return this._tokens[(tokenIndex - 1) << 1];\r\n        }\r\n        return 0;\r\n    };\r\n    LineTokens.prototype.getMetadata = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return metadata;\r\n    };\r\n    LineTokens.prototype.getLanguageId = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getLanguageId(metadata);\r\n    };\r\n    LineTokens.prototype.getStandardTokenType = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getTokenType(metadata);\r\n    };\r\n    LineTokens.prototype.getForeground = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getForeground(metadata);\r\n    };\r\n    LineTokens.prototype.getClassName = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getClassNameFromMetadata(metadata);\r\n    };\r\n    LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\r\n    };\r\n    LineTokens.prototype.getEndOffset = function (tokenIndex) {\r\n        return this._tokens[tokenIndex << 1];\r\n    };\r\n    /**\r\n     * Find the token containing offset `offset`.\r\n     * @param offset The search offset\r\n     * @return The index of the token containing the offset.\r\n     */\r\n    LineTokens.prototype.findTokenIndexAtOffset = function (offset) {\r\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\r\n    };\r\n    LineTokens.prototype.inflate = function () {\r\n        return this;\r\n    };\r\n    LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {\r\n        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\r\n    };\r\n    LineTokens.convertToEndOffset = function (tokens, lineTextLength) {\r\n        var tokenCount = (tokens.length >>> 1);\r\n        var lastTokenIndex = tokenCount - 1;\r\n        for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\r\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\r\n        }\r\n        tokens[lastTokenIndex << 1] = lineTextLength;\r\n    };\r\n    LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {\r\n        if (tokens.length <= 2) {\r\n            return 0;\r\n        }\r\n        var low = 0;\r\n        var high = (tokens.length >>> 1) - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            var endOffset = tokens[(mid << 1)];\r\n            if (endOffset === desiredIndex) {\r\n                return mid + 1;\r\n            }\r\n            else if (endOffset < desiredIndex) {\r\n                low = mid + 1;\r\n            }\r\n            else if (endOffset > desiredIndex) {\r\n                high = mid;\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n    return LineTokens;\r\n}());\r\nexport { LineTokens };\r\nvar SlicedLineTokens = /** @class */ (function () {\r\n    function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\r\n        this._source = source;\r\n        this._startOffset = startOffset;\r\n        this._endOffset = endOffset;\r\n        this._deltaOffset = deltaOffset;\r\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\r\n        this._tokensCount = 0;\r\n        for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\r\n            var tokenStartOffset = source.getStartOffset(i);\r\n            if (tokenStartOffset >= endOffset) {\r\n                break;\r\n            }\r\n            this._tokensCount++;\r\n        }\r\n    }\r\n    SlicedLineTokens.prototype.equals = function (other) {\r\n        if (other instanceof SlicedLineTokens) {\r\n            return (this._startOffset === other._startOffset\r\n                && this._endOffset === other._endOffset\r\n                && this._deltaOffset === other._deltaOffset\r\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\r\n        }\r\n        return false;\r\n    };\r\n    SlicedLineTokens.prototype.getCount = function () {\r\n        return this._tokensCount;\r\n    };\r\n    SlicedLineTokens.prototype.getForeground = function (tokenIndex) {\r\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\r\n    };\r\n    SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {\r\n        var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\r\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\r\n    };\r\n    SlicedLineTokens.prototype.getClassName = function (tokenIndex) {\r\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\r\n    };\r\n    SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\r\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\r\n    };\r\n    SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {\r\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\r\n    };\r\n    return SlicedLineTokens;\r\n}());\r\nexport { SlicedLineTokens };\r\n"]},"metadata":{},"sourceType":"module"}