{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\n\nvar PieceTreeTextBuffer =\n/** @class */\nfunction () {\n  function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n\n  PieceTreeTextBuffer.prototype.mightContainRTL = function () {\n    return this._mightContainRTL;\n  };\n\n  PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\n    return this._mightContainNonBasicASCII;\n  };\n\n  PieceTreeTextBuffer.prototype.getBOM = function () {\n    return this._BOM;\n  };\n\n  PieceTreeTextBuffer.prototype.getEOL = function () {\n    return this._pieceTree.getEOL();\n  };\n\n  PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  };\n\n  PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\n    return this._pieceTree.getPositionAt(offset);\n  };\n\n  PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\n    var end = start + length;\n    var startPosition = this.getPositionAt(start);\n    var endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n\n  PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    if (range.isEmpty()) {\n      return '';\n    }\n\n    var lineEnding = this._getEndOfLine(eol);\n\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  };\n\n  PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    if (range.isEmpty()) {\n      return 0;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n\n    var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  };\n\n  PieceTreeTextBuffer.prototype.getCharacterCountInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      var result = 0;\n      var fromLineNumber = range.startLineNumber;\n      var toLineNumber = range.endLineNumber;\n\n      for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        var lineContent = this.getLineContent(lineNumber);\n        var fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        var toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n\n        for (var offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n\n    return this.getValueLengthInRange(range, eol);\n  };\n\n  PieceTreeTextBuffer.prototype.getLength = function () {\n    return this._pieceTree.getLength();\n  };\n\n  PieceTreeTextBuffer.prototype.getLineCount = function () {\n    return this._pieceTree.getLineCount();\n  };\n\n  PieceTreeTextBuffer.prototype.getLinesContent = function () {\n    return this._pieceTree.getLinesContent();\n  };\n\n  PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  };\n\n  PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  };\n\n  PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\n    switch (eol) {\n      case 1\n      /* LF */\n      :\n        return '\\n';\n\n      case 2\n      /* CRLF */\n      :\n        return '\\r\\n';\n\n      case 0\n      /* TextDefined */\n      :\n        return this.getEOL();\n    }\n\n    throw new Error('Unknown EOL preference');\n  };\n\n  PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  };\n\n  PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\n    var mightContainRTL = this._mightContainRTL;\n    var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    var canReduceOperations = true;\n    var operations = [];\n\n    for (var i = 0; i < rawOperations.length; i++) {\n      var op = rawOperations[i];\n\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n\n      var validatedRange = op.range;\n\n      if (!mightContainRTL && op.text) {\n        // check if the new inserted text contains RTL\n        mightContainRTL = strings.containsRTL(op.text);\n      }\n\n      if (!mightContainNonBasicASCII && op.text) {\n        mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n      }\n\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    } // Sort operations ascending\n\n\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    var hasTouchingRanges = false;\n\n    for (var i = 0, count = operations.length - 1; i < count; i++) {\n      var rangeEnd = operations[i].range.getEndPosition();\n      var nextRangeStart = operations[i + 1].range.getStartPosition();\n\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n\n        hasTouchingRanges = true;\n      }\n    }\n\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    } // Delta encode operations\n\n\n    var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n\n    var newTrimAutoWhitespaceCandidates = [];\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n\n      if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n        // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n        for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n          var currentLineContent = '';\n\n          if (lineNumber === reverseRange.startLineNumber) {\n            currentLineContent = this.getLineContent(op.range.startLineNumber);\n\n            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n              continue;\n            }\n          }\n\n          newTrimAutoWhitespaceCandidates.push({\n            lineNumber: lineNumber,\n            oldContent: currentLineContent\n          });\n        }\n      }\n    }\n\n    var reverseOperations = [];\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n      reverseOperations[i] = {\n        sortIndex: op.sortIndex,\n        identifier: op.identifier,\n        range: reverseRange,\n        text: this.getValueInRange(op.range),\n        forceMoveMarkers: op.forceMoveMarkers\n      };\n    } // Can only sort reverse operations when the order is not significant\n\n\n    if (!hasTouchingRanges) {\n      reverseOperations.sort(function (a, b) {\n        return a.sortIndex - b.sortIndex;\n      });\n    }\n\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n    var contentChanges = this._doApplyEdits(operations);\n\n    var trimAutoWhitespaceLineNumbers = null;\n\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort(function (a, b) {\n        return b.lineNumber - a.lineNumber;\n      });\n      trimAutoWhitespaceLineNumbers = [];\n\n      for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n\n        var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        var lineContent = this.getLineContent(lineNumber);\n\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  };\n  /**\r\n   * Transform operations such that they represent the same logic edit,\r\n   * but that they also do not cause OOM crashes.\r\n   */\n\n\n  PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    } // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\n\n    return [this._toSingleEditOperation(operations)];\n  };\n\n  PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\n    var forceMoveMarkers = false,\n        firstEditRange = operations[0].range,\n        lastEditRange = operations[operations.length - 1].range,\n        entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn),\n        lastEndLineNumber = firstEditRange.startLineNumber,\n        lastEndColumn = firstEditRange.startColumn,\n        result = [];\n\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var operation = operations[i],\n          range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers; // (1) -- Push old text\n\n      for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n        if (lineNumber === lastEndLineNumber) {\n          result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n        } else {\n          result.push('\\n');\n          result.push(this.getLineContent(lineNumber));\n        }\n      }\n\n      if (range.startLineNumber === lastEndLineNumber) {\n        result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n      } else {\n        result.push('\\n');\n        result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n      } // (2) -- Push new text\n\n\n      if (operation.lines) {\n        for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n          if (j !== 0) {\n            result.push('\\n');\n          }\n\n          result.push(operation.lines[j]);\n        }\n      }\n\n      lastEndLineNumber = operation.range.endLineNumber;\n      lastEndColumn = operation.range.endColumn;\n    }\n\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0\n      /* TextDefined */\n      ),\n      lines: result.join('').split('\\n'),\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  };\n\n  PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    var contentChanges = []; // operations are from bottom to top\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var startLineNumber = op.range.startLineNumber;\n      var startColumn = op.range.startColumn;\n      var endLineNumber = op.range.endLineNumber;\n      var endColumn = op.range.endColumn;\n\n      if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n        // no-op\n        continue;\n      }\n\n      var deletingLinesCnt = endLineNumber - startLineNumber;\n      var insertingLinesCnt = op.lines ? op.lines.length - 1 : 0;\n      var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n      var text = op.lines ? op.lines.join(this.getEOL()) : '';\n\n      if (text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\n        this._pieceTree.insert(op.rangeOffset, text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n\n      if (editingLinesCnt < insertingLinesCnt) {\n        var newLinesContent = [];\n\n        for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n          newLinesContent.push(op.lines[j]);\n        }\n\n        newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n      }\n\n      var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n\n    return contentChanges;\n  };\n\n  PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\r\n   * Assumes `operations` are validated and sorted ascending\r\n   */\n\n\n  PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\n    var result = [];\n    var prevOpEndLineNumber = 0;\n    var prevOpEndColumn = 0;\n    var prevOp = null;\n\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var op = operations[i];\n      var startLineNumber = void 0;\n      var startColumn = void 0;\n\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n\n      var resultRange = void 0;\n\n      if (op.lines && op.lines.length > 0) {\n        // the operation inserts something\n        var lineCount = op.lines.length;\n        var firstLine = op.lines[0];\n        var lastLine = op.lines[lineCount - 1];\n\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n\n    return result;\n  };\n\n  PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n\n    return r;\n  };\n\n  PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n\n    return -r;\n  };\n\n  return PieceTreeTextBuffer;\n}();\n\nexport { PieceTreeTextBuffer };","map":{"version":3,"sources":["/Users/ifudata/eclipse-workspace/screen-web/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"names":["strings","Range","ApplyEditsResult","PieceTreeBase","PieceTreeTextBuffer","chunks","BOM","eol","containsRTL","isBasicASCII","eolNormalized","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_pieceTree","prototype","mightContainRTL","mightContainNonBasicASCII","getBOM","getEOL","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","sortIndex","identifier","rangeOffset","rangeLength","lines","split","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","substring","j","lenJ","join","_sortOpsDescending","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","Math","min","delete","insert","newLinesContent","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","firstLine","lastLine","r","compareRangesUsingEnds"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { ApplyEditsResult } from '../../model.js';\r\nimport { PieceTreeBase } from './pieceTreeBase.js';\r\nvar PieceTreeTextBuffer = /** @class */ (function () {\r\n    function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\r\n        this._BOM = BOM;\r\n        this._mightContainNonBasicASCII = !isBasicASCII;\r\n        this._mightContainRTL = containsRTL;\r\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\r\n    }\r\n    PieceTreeTextBuffer.prototype.mightContainRTL = function () {\r\n        return this._mightContainRTL;\r\n    };\r\n    PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\r\n        return this._mightContainNonBasicASCII;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getBOM = function () {\r\n        return this._BOM;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getEOL = function () {\r\n        return this._pieceTree.getEOL();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\r\n        return this._pieceTree.getOffsetAt(lineNumber, column);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\r\n        return this._pieceTree.getPositionAt(offset);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\r\n        var end = start + length;\r\n        var startPosition = this.getPositionAt(start);\r\n        var endPosition = this.getPositionAt(end);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (range.isEmpty()) {\r\n            return '';\r\n        }\r\n        var lineEnding = this._getEndOfLine(eol);\r\n        return this._pieceTree.getValueInRange(range, lineEnding);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (range.isEmpty()) {\r\n            return 0;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return (range.endColumn - range.startColumn);\r\n        }\r\n        var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        return endOffset - startOffset;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getCharacterCountInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (this._mightContainNonBasicASCII) {\r\n            // we must count by iterating\r\n            var result = 0;\r\n            var fromLineNumber = range.startLineNumber;\r\n            var toLineNumber = range.endLineNumber;\r\n            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\r\n                var lineContent = this.getLineContent(lineNumber);\r\n                var fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\r\n                var toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\r\n                for (var offset = fromOffset; offset < toOffset; offset++) {\r\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\r\n                        result = result + 1;\r\n                        offset = offset + 1;\r\n                    }\r\n                    else {\r\n                        result = result + 1;\r\n                    }\r\n                }\r\n            }\r\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\r\n            return result;\r\n        }\r\n        return this.getValueLengthInRange(range, eol);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLength = function () {\r\n        return this._pieceTree.getLength();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineCount = function () {\r\n        return this._pieceTree.getLineCount();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLinesContent = function () {\r\n        return this._pieceTree.getLinesContent();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\r\n        return this._pieceTree.getLineContent(lineNumber);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\r\n        return this._pieceTree.getLineCharCode(lineNumber, index);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\r\n        return this._pieceTree.getLineLength(lineNumber);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\r\n        var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 1;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\r\n        var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 2;\r\n    };\r\n    PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\r\n        switch (eol) {\r\n            case 1 /* LF */:\r\n                return '\\n';\r\n            case 2 /* CRLF */:\r\n                return '\\r\\n';\r\n            case 0 /* TextDefined */:\r\n                return this.getEOL();\r\n        }\r\n        throw new Error('Unknown EOL preference');\r\n    };\r\n    PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\r\n        this._pieceTree.setEOL(newEOL);\r\n    };\r\n    PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\r\n        var mightContainRTL = this._mightContainRTL;\r\n        var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\r\n        var canReduceOperations = true;\r\n        var operations = [];\r\n        for (var i = 0; i < rawOperations.length; i++) {\r\n            var op = rawOperations[i];\r\n            if (canReduceOperations && op._isTracked) {\r\n                canReduceOperations = false;\r\n            }\r\n            var validatedRange = op.range;\r\n            if (!mightContainRTL && op.text) {\r\n                // check if the new inserted text contains RTL\r\n                mightContainRTL = strings.containsRTL(op.text);\r\n            }\r\n            if (!mightContainNonBasicASCII && op.text) {\r\n                mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\r\n            }\r\n            operations[i] = {\r\n                sortIndex: i,\r\n                identifier: op.identifier || null,\r\n                range: validatedRange,\r\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\r\n                rangeLength: this.getValueLengthInRange(validatedRange),\r\n                lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\r\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\r\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\r\n            };\r\n        }\r\n        // Sort operations ascending\r\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\r\n        var hasTouchingRanges = false;\r\n        for (var i = 0, count = operations.length - 1; i < count; i++) {\r\n            var rangeEnd = operations[i].range.getEndPosition();\r\n            var nextRangeStart = operations[i + 1].range.getStartPosition();\r\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\r\n                if (nextRangeStart.isBefore(rangeEnd)) {\r\n                    // overlapping ranges\r\n                    throw new Error('Overlapping ranges are not allowed!');\r\n                }\r\n                hasTouchingRanges = true;\r\n            }\r\n        }\r\n        if (canReduceOperations) {\r\n            operations = this._reduceOperations(operations);\r\n        }\r\n        // Delta encode operations\r\n        var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\r\n        var newTrimAutoWhitespaceCandidates = [];\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var reverseRange = reverseRanges[i];\r\n            if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\r\n                // Record already the future line numbers that might be auto whitespace removal candidates on next edit\r\n                for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\r\n                    var currentLineContent = '';\r\n                    if (lineNumber === reverseRange.startLineNumber) {\r\n                        currentLineContent = this.getLineContent(op.range.startLineNumber);\r\n                        if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\r\n                }\r\n            }\r\n        }\r\n        var reverseOperations = [];\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var reverseRange = reverseRanges[i];\r\n            reverseOperations[i] = {\r\n                sortIndex: op.sortIndex,\r\n                identifier: op.identifier,\r\n                range: reverseRange,\r\n                text: this.getValueInRange(op.range),\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            };\r\n        }\r\n        // Can only sort reverse operations when the order is not significant\r\n        if (!hasTouchingRanges) {\r\n            reverseOperations.sort(function (a, b) { return a.sortIndex - b.sortIndex; });\r\n        }\r\n        this._mightContainRTL = mightContainRTL;\r\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\r\n        var contentChanges = this._doApplyEdits(operations);\r\n        var trimAutoWhitespaceLineNumbers = null;\r\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\r\n            // sort line numbers auto whitespace removal candidates for next edit descending\r\n            newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });\r\n            trimAutoWhitespaceLineNumbers = [];\r\n            for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\r\n                var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\r\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\r\n                    // Do not have the same line number twice\r\n                    continue;\r\n                }\r\n                var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\r\n                var lineContent = this.getLineContent(lineNumber);\r\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\r\n                    continue;\r\n                }\r\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\r\n            }\r\n        }\r\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\r\n    };\r\n    /**\r\n     * Transform operations such that they represent the same logic edit,\r\n     * but that they also do not cause OOM crashes.\r\n     */\r\n    PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\r\n        if (operations.length < 1000) {\r\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\r\n            return operations;\r\n        }\r\n        // At one point, due to how events are emitted and how each operation is handled,\r\n        // some operations can trigger a high amount of temporary string allocations,\r\n        // that will immediately get edited again.\r\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\r\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\r\n        return [this._toSingleEditOperation(operations)];\r\n    };\r\n    PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\r\n        var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];\r\n        for (var i = 0, len = operations.length; i < len; i++) {\r\n            var operation = operations[i], range = operation.range;\r\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\r\n            // (1) -- Push old text\r\n            for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\r\n                if (lineNumber === lastEndLineNumber) {\r\n                    result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\r\n                }\r\n                else {\r\n                    result.push('\\n');\r\n                    result.push(this.getLineContent(lineNumber));\r\n                }\r\n            }\r\n            if (range.startLineNumber === lastEndLineNumber) {\r\n                result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\r\n            }\r\n            else {\r\n                result.push('\\n');\r\n                result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\r\n            }\r\n            // (2) -- Push new text\r\n            if (operation.lines) {\r\n                for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\r\n                    if (j !== 0) {\r\n                        result.push('\\n');\r\n                    }\r\n                    result.push(operation.lines[j]);\r\n                }\r\n            }\r\n            lastEndLineNumber = operation.range.endLineNumber;\r\n            lastEndColumn = operation.range.endColumn;\r\n        }\r\n        return {\r\n            sortIndex: 0,\r\n            identifier: operations[0].identifier,\r\n            range: entireEditRange,\r\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\r\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\r\n            lines: result.join('').split('\\n'),\r\n            forceMoveMarkers: forceMoveMarkers,\r\n            isAutoWhitespaceEdit: false\r\n        };\r\n    };\r\n    PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\r\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\r\n        var contentChanges = [];\r\n        // operations are from bottom to top\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var startLineNumber = op.range.startLineNumber;\r\n            var startColumn = op.range.startColumn;\r\n            var endLineNumber = op.range.endLineNumber;\r\n            var endColumn = op.range.endColumn;\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\r\n                // no-op\r\n                continue;\r\n            }\r\n            var deletingLinesCnt = endLineNumber - startLineNumber;\r\n            var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);\r\n            var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n            var text = (op.lines ? op.lines.join(this.getEOL()) : '');\r\n            if (text) {\r\n                // replacement\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n                this._pieceTree.insert(op.rangeOffset, text, true);\r\n            }\r\n            else {\r\n                // deletion\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n            }\r\n            if (editingLinesCnt < insertingLinesCnt) {\r\n                var newLinesContent = [];\r\n                for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\r\n                    newLinesContent.push(op.lines[j]);\r\n                }\r\n                newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\r\n            }\r\n            var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            contentChanges.push({\r\n                range: contentChangeRange,\r\n                rangeLength: op.rangeLength,\r\n                text: text,\r\n                rangeOffset: op.rangeOffset,\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            });\r\n        }\r\n        return contentChanges;\r\n    };\r\n    PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    /**\r\n     * Assumes `operations` are validated and sorted ascending\r\n     */\r\n    PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\r\n        var result = [];\r\n        var prevOpEndLineNumber = 0;\r\n        var prevOpEndColumn = 0;\r\n        var prevOp = null;\r\n        for (var i = 0, len = operations.length; i < len; i++) {\r\n            var op = operations[i];\r\n            var startLineNumber = void 0;\r\n            var startColumn = void 0;\r\n            if (prevOp) {\r\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\r\n                    startLineNumber = prevOpEndLineNumber;\r\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\r\n                }\r\n                else {\r\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\r\n                    startColumn = op.range.startColumn;\r\n                }\r\n            }\r\n            else {\r\n                startLineNumber = op.range.startLineNumber;\r\n                startColumn = op.range.startColumn;\r\n            }\r\n            var resultRange = void 0;\r\n            if (op.lines && op.lines.length > 0) {\r\n                // the operation inserts something\r\n                var lineCount = op.lines.length;\r\n                var firstLine = op.lines[0];\r\n                var lastLine = op.lines[lineCount - 1];\r\n                if (lineCount === 1) {\r\n                    // single line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\r\n                }\r\n                else {\r\n                    // multi line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\r\n                }\r\n            }\r\n            else {\r\n                // There is nothing to insert\r\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\r\n            }\r\n            prevOpEndLineNumber = resultRange.endLineNumber;\r\n            prevOpEndColumn = resultRange.endColumn;\r\n            result.push(resultRange);\r\n            prevOp = op;\r\n        }\r\n        return result;\r\n    };\r\n    PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\r\n        var r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return a.sortIndex - b.sortIndex;\r\n        }\r\n        return r;\r\n    };\r\n    PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\r\n        var r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return b.sortIndex - a.sortIndex;\r\n        }\r\n        return -r;\r\n    };\r\n    return PieceTreeTextBuffer;\r\n}());\r\nexport { PieceTreeTextBuffer };\r\n"]},"metadata":{},"sourceType":"module"}